/*! For license information please see 78760.a6e0803d.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_design_system_rte_angular_builder=self.webpackChunk_design_system_rte_angular_builder||[]).push([[78760],{"../../node_modules/@angular/forms/fesm2022/forms.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{kq:()=>NG_VALUE_ACCESSOR});var asyncToGenerator=__webpack_require__("../../node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");let _currentInjector;function getCurrentInjector(){return _currentInjector}function setCurrentInjector(injector){const former=_currentInjector;return _currentInjector=injector,former}const NOT_FOUND=Symbol("NotFound");Error;function isNotFound(e){return e===NOT_FOUND||"ɵNotFound"===e?.name}let activeConsumer=null,inNotificationPhase=!1,epoch=1,postProducerCreatedFn=null;const SIGNAL=Symbol("SIGNAL");function setActiveConsumer(consumer){const prev=activeConsumer;return activeConsumer=consumer,prev}function getActiveConsumer(){return activeConsumer}const REACTIVE_NODE={version:0,lastCleanEpoch:0,dirty:!1,producers:void 0,producersTail:void 0,consumers:void 0,consumersTail:void 0,recomputing:!1,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function producerAccessed(node){if(inNotificationPhase)throw new Error("undefined"!=typeof ngDevMode&&ngDevMode?"Assertion error: signal read during notification phase":"");if(null===activeConsumer)return;activeConsumer.consumerOnSignalRead(node);const prevProducerLink=activeConsumer.producersTail;if(void 0!==prevProducerLink&&prevProducerLink.producer===node)return;let nextProducerLink;const isRecomputing=activeConsumer.recomputing;if(isRecomputing&&(nextProducerLink=void 0!==prevProducerLink?prevProducerLink.nextProducer:activeConsumer.producers,void 0!==nextProducerLink&&nextProducerLink.producer===node))return activeConsumer.producersTail=nextProducerLink,void(nextProducerLink.lastReadVersion=node.version);const prevConsumerLink=node.consumersTail;if(void 0!==prevConsumerLink&&prevConsumerLink.consumer===activeConsumer&&(!isRecomputing||function isValidLink(checkLink,consumer){const producersTail=consumer.producersTail;if(void 0!==producersTail){let link=consumer.producers;do{if(link===checkLink)return!0;if(link===producersTail)break;link=link.nextProducer}while(void 0!==link)}return!1}(prevConsumerLink,activeConsumer)))return;const isLive=consumerIsLive(activeConsumer),newLink={producer:node,consumer:activeConsumer,nextProducer:nextProducerLink,prevConsumer:prevConsumerLink,lastReadVersion:node.version,nextConsumer:void 0};activeConsumer.producersTail=newLink,void 0!==prevProducerLink?prevProducerLink.nextProducer=newLink:activeConsumer.producers=newLink,isLive&&producerAddLiveConsumer(node,newLink)}function producerUpdateValueVersion(node){consumerIsLive(node)&&!node.dirty||(node.dirty||node.lastCleanEpoch!==epoch)&&(node.producerMustRecompute(node)||consumerPollProducersForChange(node)?(node.producerRecomputeValue(node),producerMarkClean(node)):producerMarkClean(node))}function producerNotifyConsumers(node){if(void 0===node.consumers)return;const prev=inNotificationPhase;inNotificationPhase=!0;try{for(let link=node.consumers;void 0!==link;link=link.nextConsumer){const consumer=link.consumer;consumer.dirty||consumerMarkDirty(consumer)}}finally{inNotificationPhase=prev}}function producerUpdatesAllowed(){return!1!==activeConsumer?.consumerAllowSignalWrites}function consumerMarkDirty(node){node.dirty=!0,producerNotifyConsumers(node),node.consumerMarkedDirty?.(node)}function producerMarkClean(node){node.dirty=!1,node.lastCleanEpoch=epoch}function consumerBeforeComputation(node){return node&&function resetConsumerBeforeComputation(node){node.producersTail=void 0,node.recomputing=!0}(node),setActiveConsumer(node)}function consumerAfterComputation(node,prevConsumer){setActiveConsumer(prevConsumer),node&&function finalizeConsumerAfterComputation(node){node.recomputing=!1;const producersTail=node.producersTail;let toRemove=void 0!==producersTail?producersTail.nextProducer:node.producers;if(void 0!==toRemove){if(consumerIsLive(node))do{toRemove=producerRemoveLiveConsumerLink(toRemove)}while(void 0!==toRemove);void 0!==producersTail?producersTail.nextProducer=void 0:node.producers=void 0}}(node)}function consumerPollProducersForChange(node){for(let link=node.producers;void 0!==link;link=link.nextProducer){const producer=link.producer,seenVersion=link.lastReadVersion;if(seenVersion!==producer.version)return!0;if(producerUpdateValueVersion(producer),seenVersion!==producer.version)return!0}return!1}function consumerDestroy(node){if(consumerIsLive(node)){let link=node.producers;for(;void 0!==link;)link=producerRemoveLiveConsumerLink(link)}node.producers=void 0,node.producersTail=void 0,node.consumers=void 0,node.consumersTail=void 0}function producerAddLiveConsumer(node,link){const consumersTail=node.consumersTail,wasLive=consumerIsLive(node);if(void 0!==consumersTail?(link.nextConsumer=consumersTail.nextConsumer,consumersTail.nextConsumer=link):(link.nextConsumer=void 0,node.consumers=link),link.prevConsumer=consumersTail,node.consumersTail=link,!wasLive)for(let link=node.producers;void 0!==link;link=link.nextProducer)producerAddLiveConsumer(link.producer,link)}function producerRemoveLiveConsumerLink(link){const producer=link.producer,nextProducer=link.nextProducer,nextConsumer=link.nextConsumer,prevConsumer=link.prevConsumer;if(link.nextConsumer=void 0,link.prevConsumer=void 0,void 0!==nextConsumer?nextConsumer.prevConsumer=prevConsumer:producer.consumersTail=prevConsumer,void 0!==prevConsumer)prevConsumer.nextConsumer=nextConsumer;else if(producer.consumers=nextConsumer,!consumerIsLive(producer)){let producerLink=producer.producers;for(;void 0!==producerLink;)producerLink=producerRemoveLiveConsumerLink(producerLink)}return nextProducer}function consumerIsLive(node){return node.consumerIsAlwaysLive||void 0!==node.consumers}function runPostProducerCreatedFn(node){postProducerCreatedFn?.(node)}function defaultEquals(a,b){return Object.is(a,b)}function createComputed(computation,equal){const node=Object.create(COMPUTED_NODE);node.computation=computation,void 0!==equal&&(node.equal=equal);const computed=()=>{if(producerUpdateValueVersion(node),producerAccessed(node),node.value===ERRORED)throw node.error;return node.value};if(computed[SIGNAL]=node,"undefined"!=typeof ngDevMode&&ngDevMode){const debugName=node.debugName?" ("+node.debugName+")":"";computed.toString=()=>`[Computed${debugName}: ${node.value}]`}return runPostProducerCreatedFn(node),computed}const UNSET=Symbol("UNSET"),COMPUTING=Symbol("COMPUTING"),ERRORED=Symbol("ERRORED"),COMPUTED_NODE=(()=>({...REACTIVE_NODE,value:UNSET,dirty:!0,error:null,equal:defaultEquals,kind:"computed",producerMustRecompute:node=>node.value===UNSET||node.value===COMPUTING,producerRecomputeValue(node){if(node.value===COMPUTING)throw new Error("undefined"!=typeof ngDevMode&&ngDevMode?"Detected cycle in computations.":"");const oldValue=node.value;node.value=COMPUTING;const prevConsumer=consumerBeforeComputation(node);let newValue,wasEqual=!1;try{newValue=node.computation(),setActiveConsumer(null),wasEqual=oldValue!==UNSET&&oldValue!==ERRORED&&newValue!==ERRORED&&node.equal(oldValue,newValue)}catch(err){newValue=ERRORED,node.error=err}finally{consumerAfterComputation(node,prevConsumer)}wasEqual?node.value=oldValue:(node.value=newValue,node.version++)}}))();let throwInvalidWriteToSignalErrorFn=function defaultThrowError(){throw new Error};function throwInvalidWriteToSignalError(node){throwInvalidWriteToSignalErrorFn(node)}let postSignalSetFn=null;function createSignal(initialValue,equal){const node=Object.create(SIGNAL_NODE);node.value=initialValue,void 0!==equal&&(node.equal=equal);const getter=()=>function signalGetFn(node){return producerAccessed(node),node.value}(node);if(getter[SIGNAL]=node,"undefined"!=typeof ngDevMode&&ngDevMode){const debugName=node.debugName?" ("+node.debugName+")":"";getter.toString=()=>`[Signal${debugName}: ${node.value}]`}runPostProducerCreatedFn(node);return[getter,newValue=>signalSetFn(node,newValue),updateFn=>signalUpdateFn(node,updateFn)]}function signalSetFn(node,newValue){producerUpdatesAllowed()||throwInvalidWriteToSignalError(node),node.equal(node.value,newValue)||(node.value=newValue,function signalValueChanged(node){node.version++,function producerIncrementEpoch(){epoch++}(),producerNotifyConsumers(node),postSignalSetFn?.(node)}(node))}function signalUpdateFn(node,updater){producerUpdatesAllowed()||throwInvalidWriteToSignalError(node),signalSetFn(node,updater(node.value))}const SIGNAL_NODE=(()=>({...REACTIVE_NODE,equal:defaultEquals,value:void 0,kind:"signal"}))();var BehaviorSubject=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),Observable=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/Observable.js");class Version{full;major;minor;patch;constructor(full){this.full=full;const parts=full.split(".");this.major=parts[0],this.minor=parts[1],this.patch=parts.slice(2).join(".")}}const VERSION=new Version("20.3.11"),ERROR_DETAILS_PAGE_BASE_URL=`https://${"0"!==VERSION.major?`v${VERSION.major}.`:""}angular.dev/errors`,XSS_SECURITY_URL="https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss";class root_effect_scheduler_RuntimeError extends Error{code;constructor(code,message){super(root_effect_scheduler_formatRuntimeError(code,message)),this.code=code}}function root_effect_scheduler_formatRuntimeError(code,message){const fullCode=function formatRuntimeErrorCode(code){return`NG0${Math.abs(code)}`}(code);let errorMessage=`${fullCode}${message?": "+message:""}`;if(ngDevMode&&code<0){const addPeriodSeparator=!errorMessage.match(/[.,;!?\n]$/);errorMessage=`${errorMessage}${addPeriodSeparator?".":""} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`}return errorMessage}const root_effect_scheduler_global=globalThis;function initNgDevMode(){return!("undefined"!=typeof ngDevMode&&!ngDevMode)&&("object"==typeof ngDevMode&&0!==Object.keys(ngDevMode).length||function ngDevModeResetPerfCounters(){const newCounters={hydratedNodes:0,hydratedComponents:0,dehydratedViewsRemoved:0,dehydratedViewsCleanupRuns:0,componentsSkippedHydration:0,deferBlocksWithIncrementalHydration:0};return-1===("undefined"!=typeof location?location.toString():"").indexOf("ngDevMode=false")?("object"!=typeof root_effect_scheduler_global.ngDevMode&&(root_effect_scheduler_global.ngDevMode={}),Object.assign(root_effect_scheduler_global.ngDevMode,newCounters)):root_effect_scheduler_global.ngDevMode=!1,newCounters}(),"undefined"!=typeof ngDevMode&&!!ngDevMode)}function getClosureSafeProperty(objWithPropertyToExtract){for(let key in objWithPropertyToExtract)if(objWithPropertyToExtract[key]===getClosureSafeProperty)return key;throw Error("undefined"!=typeof ngDevMode&&ngDevMode?"Could not find renamed property on target object.":"")}function fillProperties(target,source){for(const key in source)source.hasOwnProperty(key)&&!target.hasOwnProperty(key)&&(target[key]=source[key])}function stringify(token){if("string"==typeof token)return token;if(Array.isArray(token))return`[${token.map(stringify).join(", ")}]`;if(null==token)return""+token;const name=token.overriddenName||token.name;if(name)return`${name}`;const result=token.toString();if(null==result)return""+result;const newLineIndex=result.indexOf("\n");return newLineIndex>=0?result.slice(0,newLineIndex):result}function concatStringsWithSpace(before,after){return before?after?`${before} ${after}`:before:after||""}const __forward_ref__=getClosureSafeProperty({__forward_ref__:getClosureSafeProperty});function forwardRef(forwardRefFn){return forwardRefFn.__forward_ref__=forwardRef,forwardRefFn.toString=function(){return stringify(this())},forwardRefFn}function resolveForwardRef(type){return isForwardRef(type)?type():type}function isForwardRef(fn){return"function"==typeof fn&&fn.hasOwnProperty(__forward_ref__)&&fn.__forward_ref__===forwardRef}function root_effect_scheduler_assertNumber(actual,msg){"number"!=typeof actual&&throwError(msg,typeof actual,"number","===")}function assertNumberInRange(actual,minInclusive,maxInclusive){root_effect_scheduler_assertNumber(actual,"Expected a number"),assertLessThanOrEqual(actual,maxInclusive,"Expected number to be less than or equal to"),assertGreaterThanOrEqual(actual,minInclusive,"Expected number to be greater than or equal to")}function assertString(actual,msg){"string"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"string","===")}function assertFunction(actual,msg){"function"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"function","===")}function root_effect_scheduler_assertEqual(actual,expected,msg){actual!=expected&&throwError(msg,actual,expected,"==")}function root_effect_scheduler_assertNotEqual(actual,expected,msg){actual==expected&&throwError(msg,actual,expected,"!=")}function assertSame(actual,expected,msg){actual!==expected&&throwError(msg,actual,expected,"===")}function assertNotSame(actual,expected,msg){actual===expected&&throwError(msg,actual,expected,"!==")}function assertLessThan(actual,expected,msg){actual<expected||throwError(msg,actual,expected,"<")}function assertLessThanOrEqual(actual,expected,msg){actual<=expected||throwError(msg,actual,expected,"<=")}function assertGreaterThan(actual,expected,msg){actual>expected||throwError(msg,actual,expected,">")}function assertGreaterThanOrEqual(actual,expected,msg){actual>=expected||throwError(msg,actual,expected,">=")}function root_effect_scheduler_assertDefined(actual,msg){null==actual&&throwError(msg,actual,null,"!=")}function throwError(msg,actual,expected,comparison){throw new Error(`ASSERTION ERROR: ${msg}`+(null==comparison?"":` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`))}function assertDomNode(node){node instanceof Node||throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`)}function root_effect_scheduler_assertIndexInRange(arr,index){root_effect_scheduler_assertDefined(arr,"Array must be defined.");const maxLen=arr.length;(index<0||index>=maxLen)&&throwError(`Index expected to be less than ${maxLen} but got ${index}`)}function assertOneOf(value,...validValues){if(-1!==validValues.indexOf(value))return!0;throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`)}function assertNotReactive(fn){null!==getActiveConsumer()&&throwError(`${fn}() should never be called in a reactive context.`)}function ɵɵdefineInjectable(opts){return{token:opts.token,providedIn:opts.providedIn||null,factory:opts.factory,value:void 0}}function ɵɵdefineInjector(options){return{providers:options.providers||[],imports:options.imports||[]}}function getInjectableDef(type){return function getOwnDefinition(type,field){return type.hasOwnProperty(field)&&type[field]||null}(type,NG_PROV_DEF)}function getInjectorDef(type){return type&&type.hasOwnProperty(NG_INJ_DEF)?type[NG_INJ_DEF]:null}const NG_PROV_DEF=getClosureSafeProperty({ɵprov:getClosureSafeProperty}),NG_INJ_DEF=getClosureSafeProperty({ɵinj:getClosureSafeProperty});class InjectionToken{_desc;ngMetadataName="InjectionToken";ɵprov;constructor(_desc,options){this._desc=_desc,this.ɵprov=void 0,"number"==typeof options?(("undefined"==typeof ngDevMode||ngDevMode)&&assertLessThan(options,0,"Only negative numbers are supported here"),this.__NG_ELEMENT_ID__=options):void 0!==options&&(this.ɵprov=ɵɵdefineInjectable({token:this,providedIn:options.providedIn||"root",factory:options.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}let _injectorProfilerContext;function getInjectorProfilerContext(){return!ngDevMode&&throwError("getInjectorProfilerContext should never be called in production mode"),_injectorProfilerContext}function setInjectorProfilerContext(context){!ngDevMode&&throwError("setInjectorProfilerContext should never be called in production mode");const previous=_injectorProfilerContext;return _injectorProfilerContext=context,previous}const injectorProfilerCallbacks=[],NOOP_PROFILER_REMOVAL=()=>{};function setInjectorProfiler(injectorProfiler){return!ngDevMode&&throwError("setInjectorProfiler should never be called in production mode"),null!==injectorProfiler?(injectorProfilerCallbacks.includes(injectorProfiler)||injectorProfilerCallbacks.push(injectorProfiler),()=>function removeProfiler(profiler){const profilerIdx=injectorProfilerCallbacks.indexOf(profiler);-1!==profilerIdx&&injectorProfilerCallbacks.splice(profilerIdx,1)}(injectorProfiler)):(injectorProfilerCallbacks.length=0,NOOP_PROFILER_REMOVAL)}function injectorProfiler(event){!ngDevMode&&throwError("Injector profiler should never be called in production mode");for(let i=0;i<injectorProfilerCallbacks.length;i++){(0,injectorProfilerCallbacks[i])(event)}}function emitProviderConfiguredEvent(eventProvider,isViewProvider=!1){let token;!ngDevMode&&throwError("Injector profiler should never be called in production mode"),token="function"==typeof eventProvider||eventProvider instanceof InjectionToken?eventProvider:resolveForwardRef(eventProvider.provide);let provider=eventProvider;eventProvider instanceof InjectionToken&&(provider=eventProvider.ɵprov||eventProvider),injectorProfiler({type:2,context:getInjectorProfilerContext(),providerRecord:{token,provider,isViewProvider}})}function emitInjectorToCreateInstanceEvent(token){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:4,context:getInjectorProfilerContext(),token})}function emitInstanceCreatedByInjectorEvent(instance){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:1,context:getInjectorProfilerContext(),instance:{value:instance}})}function emitInjectEvent(token,value,flags){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:0,context:getInjectorProfilerContext(),service:{token,value,flags}})}function runInInjectorProfilerContext(injector,token,callback){!ngDevMode&&throwError("runInInjectorProfilerContext should never be called in production mode");const prevInjectContext=setInjectorProfilerContext({injector,token});try{callback()}finally{setInjectorProfilerContext(prevInjectContext)}}function isEnvironmentProviders(value){return value&&!!value.ɵproviders}const NG_COMP_DEF=getClosureSafeProperty({ɵcmp:getClosureSafeProperty}),NG_DIR_DEF=getClosureSafeProperty({ɵdir:getClosureSafeProperty}),NG_PIPE_DEF=getClosureSafeProperty({ɵpipe:getClosureSafeProperty}),NG_MOD_DEF=getClosureSafeProperty({ɵmod:getClosureSafeProperty}),NG_FACTORY_DEF=getClosureSafeProperty({ɵfac:getClosureSafeProperty}),NG_ELEMENT_ID=getClosureSafeProperty({__NG_ELEMENT_ID__:getClosureSafeProperty}),NG_ENV_ID=getClosureSafeProperty({__NG_ENV_ID__:getClosureSafeProperty});function root_effect_scheduler_renderStringify(value){return"string"==typeof value?value:null==value?"":String(value)}function root_effect_scheduler_stringifyForError(value){return"function"==typeof value?value.name||value.toString():"object"==typeof value&&null!=value&&"function"==typeof value.type?value.type.name||value.type.toString():root_effect_scheduler_renderStringify(value)}const NG_RUNTIME_ERROR_CODE=getClosureSafeProperty({ngErrorCode:getClosureSafeProperty}),NG_RUNTIME_ERROR_MESSAGE=getClosureSafeProperty({ngErrorMessage:getClosureSafeProperty}),NG_TOKEN_PATH=getClosureSafeProperty({ngTokenPath:getClosureSafeProperty});function cyclicDependencyError(token,path){return createRuntimeError(ngDevMode?`Circular dependency detected for \`${token}\`.`:"",-200,path)}function cyclicDependencyErrorWithDetails(token,path){return augmentRuntimeError(cyclicDependencyError(token,path),null)}function throwMixedMultiProviderError(){throw new Error("Cannot mix multi providers and regular providers")}function throwInvalidProviderError(ngModuleType,providers,provider){if(ngModuleType&&providers){const providerDetail=providers.map(v=>v==provider?"?"+provider+"?":"...");throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`)}throw isEnvironmentProviders(provider)?provider.ɵfromNgModule?new root_effect_scheduler_RuntimeError(207,"Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers."):new root_effect_scheduler_RuntimeError(207,"Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers."):new Error("Invalid provider")}function throwProviderNotFoundError(token,injectorName){const errorMessage=ngDevMode&&`No provider for ${root_effect_scheduler_stringifyForError(token)} found${injectorName?` in ${injectorName}`:""}`;throw new root_effect_scheduler_RuntimeError(-201,errorMessage)}function augmentRuntimeError(error,source){const tokenPath=error[NG_TOKEN_PATH],errorCode=error[NG_RUNTIME_ERROR_CODE],message=error[NG_RUNTIME_ERROR_MESSAGE]||error.message;return error.message=function formatErrorMessage(text,code,path=[],source=null){let pathDetails="";path&&path.length>1&&(pathDetails=` Path: ${path.join(" -> ")}.`);const sourceDetails=source?` Source: ${source}.`:"";return root_effect_scheduler_formatRuntimeError(code,`${text}${sourceDetails}${pathDetails}`)}(message,errorCode,tokenPath,source),error}function createRuntimeError(message,code,path){const error=new root_effect_scheduler_RuntimeError(code,message);return error[NG_RUNTIME_ERROR_CODE]=code,error[NG_RUNTIME_ERROR_MESSAGE]=message,path&&(error[NG_TOKEN_PATH]=path),error}let _injectImplementation;function getInjectImplementation(){return _injectImplementation}function setInjectImplementation(impl){const previous=_injectImplementation;return _injectImplementation=impl,previous}function injectRootLimpMode(token,notFoundValue,flags){const injectableDef=getInjectableDef(token);return injectableDef&&"root"==injectableDef.providedIn?void 0===injectableDef.value?injectableDef.value=injectableDef.factory():injectableDef.value:8&flags?null:void 0!==notFoundValue?notFoundValue:void throwProviderNotFoundError(token,"Injector")}const THROW_IF_NOT_FOUND={};class RetrievingInjector{injector;constructor(injector){this.injector=injector}retrieve(token,options){const flags=convertToBitFlags(options)||0;try{return this.injector.get(token,8&flags?null:THROW_IF_NOT_FOUND,flags)}catch(e){if(isNotFound(e))return e;throw e}}}function injectInjectorOnly(token,flags=0){const currentInjector=getCurrentInjector();if(void 0===currentInjector)throw new root_effect_scheduler_RuntimeError(-203,ngDevMode&&`The \`${stringify(token)}\` token injection failed. \`inject()\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);if(null===currentInjector)return injectRootLimpMode(token,void 0,flags);{const options=function convertToInjectOptions(flags){return{optional:!!(8&flags),host:!!(1&flags),self:!!(2&flags),skipSelf:!!(4&flags)}}(flags),value=currentInjector.retrieve(token,options);if(ngDevMode&&emitInjectEvent(token,value,flags),isNotFound(value)){if(options.optional)return null;throw value}return value}}function ɵɵinject(token,flags=0){return(getInjectImplementation()||injectInjectorOnly)(resolveForwardRef(token),flags)}function ɵɵinvalidFactoryDep(index){throw new root_effect_scheduler_RuntimeError(202,ngDevMode&&`This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`)}function root_effect_scheduler_inject(token,options){return ɵɵinject(token,convertToBitFlags(options))}function convertToBitFlags(flags){return void 0===flags||"number"==typeof flags?flags:0|(flags.optional&&8)|(flags.host&&1)|(flags.self&&2)|(flags.skipSelf&&4)}function injectArgs(types){const args=[];for(let i=0;i<types.length;i++){const arg=resolveForwardRef(types[i]);if(Array.isArray(arg)){if(0===arg.length)throw new root_effect_scheduler_RuntimeError(900,ngDevMode&&"Arguments array must have arguments.");let type,flags=0;for(let j=0;j<arg.length;j++){const meta=arg[j],flag=getInjectFlag(meta);"number"==typeof flag?-1===flag?type=meta.token:flags|=flag:type=meta}args.push(ɵɵinject(type,flags))}else args.push(ɵɵinject(arg))}return args}function attachInjectFlag(decorator,flag){return decorator.__NG_DI_FLAG__=flag,decorator.prototype.__NG_DI_FLAG__=flag,decorator}function getInjectFlag(token){return token.__NG_DI_FLAG__}function getFactoryDef(type,throwNotFound){const hasFactoryDef=type.hasOwnProperty(NG_FACTORY_DEF);if(!hasFactoryDef&&!0===throwNotFound&&ngDevMode)throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);return hasFactoryDef?type[NG_FACTORY_DEF]:null}function flatten(list){return list.flat(Number.POSITIVE_INFINITY)}function deepForEach(input,fn){input.forEach(value=>Array.isArray(value)?deepForEach(value,fn):fn(value))}function addToArray(arr,index,value){index>=arr.length?arr.push(value):arr.splice(index,0,value)}function removeFromArray(arr,index){return index>=arr.length-1?arr.pop():arr.splice(index,1)[0]}function newArray(size,value){const list=[];for(let i=0;i<size;i++)list.push(value);return list}function arraySplice(array,index,count){const length=array.length-count;for(;index<length;)array[index]=array[index+count],index++;for(;count--;)array.pop()}function arrayInsert2(array,index,value1,value2){ngDevMode&&assertLessThanOrEqual(index,array.length,"Can't insert past array end.");let end=array.length;if(end==index)array.push(value1,value2);else if(1===end)array.push(value2,array[0]),array[0]=value1;else{for(end--,array.push(array[end-1],array[end]);end>index;){const previousEnd=end-2;array[end]=array[previousEnd],end--}array[index]=value1,array[index+1]=value2}}function keyValueArraySet(keyValueArray,key,value){let index=keyValueArrayIndexOf(keyValueArray,key);return index>=0?keyValueArray[1|index]=value:(index=~index,arrayInsert2(keyValueArray,index,key,value)),index}function keyValueArrayGet(keyValueArray,key){const index=keyValueArrayIndexOf(keyValueArray,key);if(index>=0)return keyValueArray[1|index]}function keyValueArrayIndexOf(keyValueArray,key){return function _arrayIndexOfSorted(array,value,shift){ngDevMode&&root_effect_scheduler_assertEqual(Array.isArray(array),!0,"Expecting an array");let start=0,end=array.length>>shift;for(;end!==start;){const middle=start+(end-start>>1),current=array[middle<<shift];if(value===current)return middle<<shift;current>value?end=middle:start=middle+1}return~(end<<shift)}(keyValueArray,key,1)}const EMPTY_OBJ={},EMPTY_ARRAY=[];("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode()&&(Object.freeze(EMPTY_OBJ),Object.freeze(EMPTY_ARRAY));const root_effect_scheduler_ENVIRONMENT_INITIALIZER=new InjectionToken(ngDevMode?"ENVIRONMENT_INITIALIZER":""),INJECTOR$1=new InjectionToken(ngDevMode?"INJECTOR":"",-1),INJECTOR_DEF_TYPES=new InjectionToken(ngDevMode?"INJECTOR_DEF_TYPES":"");class NullInjector{get(token,notFoundValue=THROW_IF_NOT_FOUND){if(notFoundValue===THROW_IF_NOT_FOUND){const error=createRuntimeError(ngDevMode?`No provider found for \`${stringify(token)}\`.`:"",-201);throw error.name="ɵNotFound",error}return notFoundValue}}function getNgModuleDef(type){return type[NG_MOD_DEF]||null}function getNgModuleDefOrThrow(type){const ngModuleDef=getNgModuleDef(type);if(!ngModuleDef)throw new root_effect_scheduler_RuntimeError(915,("undefined"==typeof ngDevMode||ngDevMode)&&`Type ${stringify(type)} does not have 'ɵmod' property.`);return ngModuleDef}function root_effect_scheduler_getComponentDef(type){return type[NG_COMP_DEF]||null}function getDirectiveDefOrThrow(type){const def=getDirectiveDef(type);if(!def)throw new root_effect_scheduler_RuntimeError(916,("undefined"==typeof ngDevMode||ngDevMode)&&`Type ${stringify(type)} does not have 'ɵdir' property.`);return def}function getDirectiveDef(type){return type[NG_DIR_DEF]||null}function getPipeDef(type){return type[NG_PIPE_DEF]||null}function isStandalone(type){const def=root_effect_scheduler_getComponentDef(type)||getDirectiveDef(type)||getPipeDef(type);return null!==def&&def.standalone}function importProvidersFrom(...sources){return{ɵproviders:internalImportProvidersFrom(!0,sources),ɵfromNgModule:!0}}function internalImportProvidersFrom(checkForStandaloneCmp,...sources){const providersOut=[],dedup=new Set;let injectorTypesWithProviders;const collectProviders=provider=>{providersOut.push(provider)};return deepForEach(sources,source=>{if(("undefined"==typeof ngDevMode||ngDevMode)&&checkForStandaloneCmp){const cmpDef=root_effect_scheduler_getComponentDef(source);if(cmpDef?.standalone)throw new root_effect_scheduler_RuntimeError(800,`Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${root_effect_scheduler_stringifyForError(source)}"`)}const internalSource=source;walkProviderTree(internalSource,collectProviders,[],dedup)&&(injectorTypesWithProviders||=[],injectorTypesWithProviders.push(internalSource))}),void 0!==injectorTypesWithProviders&&processInjectorTypesWithProviders(injectorTypesWithProviders,collectProviders),providersOut}function processInjectorTypesWithProviders(typesWithProviders,visitor){for(let i=0;i<typesWithProviders.length;i++){const{ngModule,providers}=typesWithProviders[i];deepForEachProvider(providers,provider=>{ngDevMode&&validateProvider(provider,providers||EMPTY_ARRAY,ngModule),visitor(provider,ngModule)})}}function walkProviderTree(container,visitor,parents,dedup){if(!(container=resolveForwardRef(container)))return!1;let defType=null,injDef=getInjectorDef(container);const cmpDef=!injDef&&root_effect_scheduler_getComponentDef(container);if(injDef||cmpDef){if(cmpDef&&!cmpDef.standalone)return!1;defType=container}else{const ngModule=container.ngModule;if(injDef=getInjectorDef(ngModule),!injDef)return!1;defType=ngModule}if(ngDevMode&&-1!==parents.indexOf(defType)){const defName=stringify(defType);throw cyclicDependencyErrorWithDetails(defName,parents.map(stringify).concat(defName))}const isDuplicate=dedup.has(defType);if(cmpDef){if(isDuplicate)return!1;if(dedup.add(defType),cmpDef.dependencies){const deps="function"==typeof cmpDef.dependencies?cmpDef.dependencies():cmpDef.dependencies;for(const dep of deps)walkProviderTree(dep,visitor,parents,dedup)}}else{if(!injDef)return!1;{if(null!=injDef.imports&&!isDuplicate){let importTypesWithProviders;ngDevMode&&parents.push(defType),dedup.add(defType);try{deepForEach(injDef.imports,imported=>{walkProviderTree(imported,visitor,parents,dedup)&&(importTypesWithProviders||=[],importTypesWithProviders.push(imported))})}finally{ngDevMode&&parents.pop()}void 0!==importTypesWithProviders&&processInjectorTypesWithProviders(importTypesWithProviders,visitor)}if(!isDuplicate){const factory=getFactoryDef(defType)||(()=>new defType);visitor({provide:defType,useFactory:factory,deps:EMPTY_ARRAY},defType),visitor({provide:INJECTOR_DEF_TYPES,useValue:defType,multi:!0},defType),visitor({provide:root_effect_scheduler_ENVIRONMENT_INITIALIZER,useValue:()=>ɵɵinject(defType),multi:!0},defType)}const defProviders=injDef.providers;if(null!=defProviders&&!isDuplicate){const injectorType=container;deepForEachProvider(defProviders,provider=>{ngDevMode&&validateProvider(provider,defProviders,injectorType),visitor(provider,injectorType)})}}}return defType!==container&&void 0!==container.providers}function validateProvider(provider,providers,containerType){if(isTypeProvider(provider)||isValueProvider(provider)||isFactoryProvider(provider)||isExistingProvider(provider))return;resolveForwardRef(provider&&(provider.useClass||provider.provide))||throwInvalidProviderError(containerType,providers,provider)}function deepForEachProvider(providers,fn){for(let provider of providers)isEnvironmentProviders(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?deepForEachProvider(provider,fn):fn(provider)}const USE_VALUE=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isValueProvider(value){return null!==value&&"object"==typeof value&&USE_VALUE in value}function isExistingProvider(value){return!(!value||!value.useExisting)}function isFactoryProvider(value){return!(!value||!value.useFactory)}function isTypeProvider(value){return"function"==typeof value}function isClassProvider(value){return!!value.useClass}const INJECTOR_SCOPE=new InjectionToken(ngDevMode?"Set Injector scope.":""),NOT_YET={},CIRCULAR={};let NULL_INJECTOR;function root_effect_scheduler_getNullInjector(){return void 0===NULL_INJECTOR&&(NULL_INJECTOR=new NullInjector),NULL_INJECTOR}class EnvironmentInjector{}class R3Injector extends EnvironmentInjector{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(providers,parent,source,scopes){super(),this.parent=parent,this.source=source,this.scopes=scopes,forEachSingleProvider(providers,provider=>this.processProvider(provider)),this.records.set(INJECTOR$1,makeRecord(void 0,this)),scopes.has("environment")&&this.records.set(EnvironmentInjector,makeRecord(void 0,this));const record=this.records.get(INJECTOR_SCOPE);null!=record&&"string"==typeof record.value&&this.scopes.add(record.value),this.injectorDefTypes=new Set(this.get(INJECTOR_DEF_TYPES,EMPTY_ARRAY,{self:!0}))}retrieve(token,options){const flags=convertToBitFlags(options)||0;try{return this.get(token,THROW_IF_NOT_FOUND,flags)}catch(e){if(isNotFound(e))return e;throw e}}destroy(){assertNotDestroyed(this),this._destroyed=!0;const prevConsumer=setActiveConsumer(null);try{for(const service of this._ngOnDestroyHooks)service.ngOnDestroy();const onDestroyHooks=this._onDestroyHooks;this._onDestroyHooks=[];for(const hook of onDestroyHooks)hook()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),setActiveConsumer(prevConsumer)}}onDestroy(callback){return assertNotDestroyed(this),this._onDestroyHooks.push(callback),()=>this.removeOnDestroy(callback)}runInContext(fn){assertNotDestroyed(this);const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token:null}));try{return fn()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}get(token,notFoundValue=THROW_IF_NOT_FOUND,options){if(assertNotDestroyed(this),token.hasOwnProperty(NG_ENV_ID))return token[NG_ENV_ID](this);const flags=convertToBitFlags(options);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token}));const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);try{if(!(4&flags)){let record=this.records.get(token);if(void 0===record){const def=function couldBeInjectableType(value){return"function"==typeof value||"object"==typeof value&&"InjectionToken"===value.ngMetadataName}(token)&&getInjectableDef(token);def&&this.injectableDefInScope(def)?(ngDevMode&&runInInjectorProfilerContext(this,token,()=>{emitProviderConfiguredEvent(token)}),record=makeRecord(injectableDefOrInjectorDefFactory(token),NOT_YET)):record=null,this.records.set(token,record)}if(null!=record)return this.hydrate(token,record,flags)}const nextInjector=2&flags?root_effect_scheduler_getNullInjector():this.parent;return notFoundValue=8&flags&&notFoundValue===THROW_IF_NOT_FOUND?null:notFoundValue,nextInjector.get(token,notFoundValue)}catch(error){const errorCode=function getRuntimeErrorCode(error){return error[NG_RUNTIME_ERROR_CODE]}(error);throw-200===errorCode||-201===errorCode?ngDevMode?(function prependTokenToDependencyPath(error,token){error[NG_TOKEN_PATH]??=[];const currentPath=error[NG_TOKEN_PATH];let pathStr;"object"==typeof token&&"multi"in token&&!0===token?.multi?(root_effect_scheduler_assertDefined(token.provide,"Token with multi: true should have a provide property"),pathStr=root_effect_scheduler_stringifyForError(token.provide)):pathStr=root_effect_scheduler_stringifyForError(token),currentPath[0]!==pathStr&&error[NG_TOKEN_PATH].unshift(pathStr)}(error,token),previousInjector?error:augmentRuntimeError(error,this.source)):new root_effect_scheduler_RuntimeError(errorCode,null):error}finally{setInjectImplementation(previousInjectImplementation),setCurrentInjector(previousInjector),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}resolveInjectorInitializers(){const prevConsumer=setActiveConsumer(null),previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token:null}));try{const initializers=this.get(root_effect_scheduler_ENVIRONMENT_INITIALIZER,EMPTY_ARRAY,{self:!0});if(ngDevMode&&!Array.isArray(initializers))throw new root_effect_scheduler_RuntimeError(-209,`Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);for(const initializer of initializers)initializer()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(prevInjectContext),setActiveConsumer(prevConsumer)}}toString(){const tokens=[],records=this.records;for(const token of records.keys())tokens.push(stringify(token));return`R3Injector[${tokens.join(", ")}]`}processProvider(provider){let token=isTypeProvider(provider=resolveForwardRef(provider))?provider:resolveForwardRef(provider&&provider.provide);const record=function providerToRecord(provider){if(isValueProvider(provider))return makeRecord(void 0,provider.useValue);return makeRecord(providerToFactory(provider),NOT_YET)}(provider);if(ngDevMode&&runInInjectorProfilerContext(this,token,()=>{isValueProvider(provider)&&(emitInjectorToCreateInstanceEvent(token),emitInstanceCreatedByInjectorEvent(provider.useValue)),emitProviderConfiguredEvent(provider)}),isTypeProvider(provider)||!0!==provider.multi){if(ngDevMode){const existing=this.records.get(token);existing&&void 0!==existing.multi&&throwMixedMultiProviderError()}}else{let multiRecord=this.records.get(token);multiRecord?ngDevMode&&void 0===multiRecord.multi&&throwMixedMultiProviderError():(multiRecord=makeRecord(void 0,NOT_YET,!0),multiRecord.factory=()=>injectArgs(multiRecord.multi),this.records.set(token,multiRecord)),token=provider,multiRecord.multi.push(provider)}this.records.set(token,record)}hydrate(token,record,flags){const prevConsumer=setActiveConsumer(null);try{if(record.value===CIRCULAR)throw cyclicDependencyError(stringify(token));return record.value===NOT_YET&&(record.value=CIRCULAR,ngDevMode?runInInjectorProfilerContext(this,token,()=>{emitInjectorToCreateInstanceEvent(token),record.value=record.factory(void 0,flags),emitInstanceCreatedByInjectorEvent(record.value)}):record.value=record.factory(void 0,flags)),"object"==typeof record.value&&record.value&&function hasOnDestroy(value){return null!==value&&"object"==typeof value&&"function"==typeof value.ngOnDestroy}(record.value)&&this._ngOnDestroyHooks.add(record.value),record.value}finally{setActiveConsumer(prevConsumer)}}injectableDefInScope(def){if(!def.providedIn)return!1;const providedIn=resolveForwardRef(def.providedIn);return"string"==typeof providedIn?"any"===providedIn||this.scopes.has(providedIn):this.injectorDefTypes.has(providedIn)}removeOnDestroy(callback){const destroyCBIdx=this._onDestroyHooks.indexOf(callback);-1!==destroyCBIdx&&this._onDestroyHooks.splice(destroyCBIdx,1)}}function injectableDefOrInjectorDefFactory(token){const injectableDef=getInjectableDef(token),factory=null!==injectableDef?injectableDef.factory:getFactoryDef(token);if(null!==factory)return factory;if(token instanceof InjectionToken)throw new root_effect_scheduler_RuntimeError(204,ngDevMode&&`Token ${stringify(token)} is missing a ɵprov definition.`);if(token instanceof Function)return function getUndecoratedInjectableFactory(token){const paramLength=token.length;if(paramLength>0)throw new root_effect_scheduler_RuntimeError(204,ngDevMode&&`Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength,"?").join(", ")}).`);const inheritedInjectableDef=function getInheritedInjectableDef(type){const def=type?.[NG_PROV_DEF]??null;return def?(ngDevMode&&console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`),def):null}(token);return null!==inheritedInjectableDef?()=>inheritedInjectableDef.factory(token):()=>new token}(token);throw new root_effect_scheduler_RuntimeError(204,ngDevMode&&"unreachable")}function providerToFactory(provider,ngModuleType,providers){let factory;if(ngDevMode&&isEnvironmentProviders(provider)&&throwInvalidProviderError(void 0,providers,provider),isTypeProvider(provider)){const unwrappedProvider=resolveForwardRef(provider);return getFactoryDef(unwrappedProvider)||injectableDefOrInjectorDefFactory(unwrappedProvider)}if(isValueProvider(provider))factory=()=>resolveForwardRef(provider.useValue);else if(isFactoryProvider(provider))factory=()=>provider.useFactory(...injectArgs(provider.deps||[]));else if(isExistingProvider(provider))factory=(_,flags)=>ɵɵinject(resolveForwardRef(provider.useExisting),void 0!==flags&&8&flags?8:void 0);else{const classRef=resolveForwardRef(provider&&(provider.useClass||provider.provide));if(ngDevMode&&!classRef&&throwInvalidProviderError(ngModuleType,providers,provider),!function hasDeps(value){return!!value.deps}(provider))return getFactoryDef(classRef)||injectableDefOrInjectorDefFactory(classRef);factory=()=>new classRef(...injectArgs(provider.deps))}return factory}function assertNotDestroyed(injector){if(injector.destroyed)throw new root_effect_scheduler_RuntimeError(205,ngDevMode&&"Injector has already been destroyed.")}function makeRecord(factory,value,multi=!1){return{factory,value,multi:multi?[]:void 0}}function forEachSingleProvider(providers,fn){for(const provider of providers)Array.isArray(provider)?forEachSingleProvider(provider,fn):provider&&isEnvironmentProviders(provider)?forEachSingleProvider(provider.ɵproviders,fn):fn(provider)}function runInInjectionContext(injector,fn){let internalInjector,prevInjectorProfilerContext;injector instanceof R3Injector?(assertNotDestroyed(injector),internalInjector=injector):internalInjector=new RetrievingInjector(injector),ngDevMode&&(prevInjectorProfilerContext=setInjectorProfilerContext({injector,token:null}));const prevInjector=setCurrentInjector(internalInjector),previousInjectImplementation=setInjectImplementation(void 0);try{return fn()}finally{setCurrentInjector(prevInjector),ngDevMode&&setInjectorProfilerContext(prevInjectorProfilerContext),setInjectImplementation(previousInjectImplementation)}}function isInInjectionContext(){return void 0!==getInjectImplementation()||null!=getCurrentInjector()}function root_effect_scheduler_assertInInjectionContext(debugFn){if(!isInInjectionContext())throw new root_effect_scheduler_RuntimeError(-203,ngDevMode&&debugFn.name+"() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`")}function root_effect_scheduler_isLView(value){return Array.isArray(value)&&"object"==typeof value[1]}function root_effect_scheduler_isLContainer(value){return Array.isArray(value)&&!0===value[1]}function isContentQueryHost(tNode){return!!(4&tNode.flags)}function root_effect_scheduler_isComponentHost(tNode){return tNode.componentOffset>-1}function isDirectiveHost(tNode){return!(1&~tNode.flags)}function isComponentDef(def){return!!def.template}function root_effect_scheduler_isRootView(target){return!!(512&target[2])}function isDestroyed(lView){return!(256&~lView[2])}function assertTNodeForLView(tNode,lView){assertTNodeForTView(tNode,lView[1])}function assertTNodeCreationIndex(lView,index){const adjustedIndex=index+27;root_effect_scheduler_assertIndexInRange(lView,adjustedIndex),assertLessThan(adjustedIndex,lView[1].bindingStartIndex,"TNodes should be created before any bindings")}function assertTNodeForTView(tNode,tView){root_effect_scheduler_assertTNode(tNode);const tData=tView.data;for(let i=27;i<tData.length;i++)if(tData[i]===tNode)return;throwError("This TNode does not belong to this TView.")}function root_effect_scheduler_assertTNode(tNode){root_effect_scheduler_assertDefined(tNode,"TNode must be defined"),tNode&&"object"==typeof tNode&&tNode.hasOwnProperty("directiveStylingLast")||throwError("Not of type TNode, got: "+tNode)}function root_effect_scheduler_assertTIcu(tIcu){root_effect_scheduler_assertDefined(tIcu,"Expected TIcu to be defined"),"number"!=typeof tIcu.currentCaseLViewIndex&&throwError("Object is not of TIcu type.")}function assertLContainer(value){root_effect_scheduler_assertDefined(value,"LContainer must be defined"),root_effect_scheduler_assertEqual(root_effect_scheduler_isLContainer(value),!0,"Expecting LContainer")}function assertLViewOrUndefined(value){value&&root_effect_scheduler_assertEqual(root_effect_scheduler_isLView(value),!0,"Expecting LView or undefined or null")}function assertLView(value){root_effect_scheduler_assertDefined(value,"LView must be defined"),root_effect_scheduler_assertEqual(root_effect_scheduler_isLView(value),!0,"Expecting LView")}function assertFirstCreatePass(tView,errMessage){root_effect_scheduler_assertEqual(tView.firstCreatePass,!0,errMessage||"Should only be called in first create pass.")}function assertFirstUpdatePass(tView,errMessage){root_effect_scheduler_assertEqual(tView.firstUpdatePass,!0,"Should only be called in first update pass.")}function assertIndexInDeclRange(tView,index){assertBetween(27,tView.bindingStartIndex,index)}function assertIndexInExpandoRange(lView,index){assertBetween(lView[1].expandoStartIndex,lView.length,index)}function assertBetween(lower,upper,index){lower<=index&&index<upper||throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`)}function assertParentView(lView,errMessage){root_effect_scheduler_assertDefined(lView,"Component views should always have a parent view (component's host view)")}function assertNodeInjector(lView,injectorIndex){assertIndexInExpandoRange(lView,injectorIndex),assertIndexInExpandoRange(lView,injectorIndex+8),root_effect_scheduler_assertNumber(lView[injectorIndex+0],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+1],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+2],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+3],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+4],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+5],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+6],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+7],"injectorIndex should point to a bloom filter"),root_effect_scheduler_assertNumber(lView[injectorIndex+8],"injectorIndex should point to parent injector")}function root_effect_scheduler_unwrapRNode(value){for(;Array.isArray(value);)value=value[0];return value}function getNativeByIndex(index,lView){return ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,index),ngDevMode&&assertGreaterThanOrEqual(index,27,"Expected to be past HEADER_OFFSET"),root_effect_scheduler_unwrapRNode(lView[index])}function root_effect_scheduler_getNativeByTNode(tNode,lView){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,tNode.index);return root_effect_scheduler_unwrapRNode(lView[tNode.index])}function root_effect_scheduler_getTNode(tView,index){ngDevMode&&assertGreaterThan(index,-1,"wrong index for TNode"),ngDevMode&&assertLessThan(index,tView.data.length,"wrong index for TNode");const tNode=tView.data[index];return ngDevMode&&null!==tNode&&root_effect_scheduler_assertTNode(tNode),tNode}function load(view,index){return ngDevMode&&root_effect_scheduler_assertIndexInRange(view,index),view[index]}function store(tView,lView,index,value){index>=tView.data.length&&(tView.data[index]=null,tView.blueprint[index]=null),lView[index]=value}function root_effect_scheduler_getComponentLViewByIndex(nodeIndex,hostView){ngDevMode&&root_effect_scheduler_assertIndexInRange(hostView,nodeIndex);const slotValue=hostView[nodeIndex];return root_effect_scheduler_isLView(slotValue)?slotValue:slotValue[0]}function isCreationMode(view){return!(4&~view[2])}function viewAttachedToChangeDetector(view){return!(128&~view[2])}function getConstant(consts,index){return null==index?null:(ngDevMode&&root_effect_scheduler_assertIndexInRange(consts,index),consts[index])}function resetPreOrderHookFlags(lView){lView[17]=0}function root_effect_scheduler_markViewForRefresh(lView){1024&lView[2]||(lView[2]|=1024,viewAttachedToChangeDetector(lView)&&markAncestorsForTraversal(lView))}function walkUpViews(nestingLevel,currentView){for(;nestingLevel>0;)ngDevMode&&root_effect_scheduler_assertDefined(currentView[14],"Declaration view should be defined if nesting level is greater than 0."),currentView=currentView[14],nestingLevel--;return currentView}function root_effect_scheduler_requiresRefreshOrTraversal(lView){return!!(9216&lView[2]||lView[24]?.dirty)}function updateAncestorTraversalFlagsOnAttach(lView){lView[10].changeDetectionScheduler?.notify(8),64&lView[2]&&(lView[2]|=1024),root_effect_scheduler_requiresRefreshOrTraversal(lView)&&markAncestorsForTraversal(lView)}function markAncestorsForTraversal(lView){lView[10].changeDetectionScheduler?.notify(0);let parent=getLViewParent(lView);for(;null!==parent&&!(8192&parent[2])&&(parent[2]|=8192,viewAttachedToChangeDetector(parent));)parent=getLViewParent(parent)}function storeLViewOnDestroy(lView,onDestroyCallback){if(isDestroyed(lView))throw new root_effect_scheduler_RuntimeError(911,ngDevMode&&"View has already been destroyed.");null===lView[21]&&(lView[21]=[]),lView[21].push(onDestroyCallback)}function removeLViewOnDestroy(lView,onDestroyCallback){if(null===lView[21])return;const destroyCBIdx=lView[21].indexOf(onDestroyCallback);-1!==destroyCBIdx&&lView[21].splice(destroyCBIdx,1)}function getLViewParent(lView){ngDevMode&&assertLView(lView);const parent=lView[3];return root_effect_scheduler_isLContainer(parent)?parent[3]:parent}function getOrCreateLViewCleanup(view){return view[7]??=[]}function getOrCreateTViewCleanup(tView){return tView.cleanup??=[]}const instructionState={lFrame:createLFrame(null),bindingsEnabled:!0,skipHydrationRootTNode:null};var CheckNoChangesMode;!function(CheckNoChangesMode){CheckNoChangesMode[CheckNoChangesMode.Off=0]="Off",CheckNoChangesMode[CheckNoChangesMode.Exhaustive=1]="Exhaustive",CheckNoChangesMode[CheckNoChangesMode.OnlyDirtyViews=2]="OnlyDirtyViews"}(CheckNoChangesMode||(CheckNoChangesMode={}));let _checkNoChangesMode=0,_isRefreshingViews=!1;function decreaseElementDepthCount(){instructionState.lFrame.elementDepthCount--}function getBindingsEnabled(){return instructionState.bindingsEnabled}function root_effect_scheduler_isInSkipHydrationBlock(){return null!==instructionState.skipHydrationRootTNode}function isSkipHydrationRootTNode(tNode){return instructionState.skipHydrationRootTNode===tNode}function ɵɵenableBindings(){instructionState.bindingsEnabled=!0}function ɵɵdisableBindings(){instructionState.bindingsEnabled=!1}function leaveSkipHydrationBlock(){instructionState.skipHydrationRootTNode=null}function root_effect_scheduler_getLView(){return instructionState.lFrame.lView}function getTView(){return instructionState.lFrame.tView}function ɵɵrestoreView(viewToRestore){return instructionState.lFrame.contextLView=viewToRestore,viewToRestore[8]}function ɵɵresetView(value){return instructionState.lFrame.contextLView=null,value}function root_effect_scheduler_getCurrentTNode(){let currentTNode=getCurrentTNodePlaceholderOk();for(;null!==currentTNode&&64===currentTNode.type;)currentTNode=currentTNode.parent;return currentTNode}function getCurrentTNodePlaceholderOk(){return instructionState.lFrame.currentTNode}function getCurrentParentTNode(){const lFrame=instructionState.lFrame,currentTNode=lFrame.currentTNode;return lFrame.isParent?currentTNode:currentTNode.parent}function setCurrentTNode(tNode,isParent){ngDevMode&&tNode&&assertTNodeForTView(tNode,instructionState.lFrame.tView);const lFrame=instructionState.lFrame;lFrame.currentTNode=tNode,lFrame.isParent=isParent}function isCurrentTNodeParent(){return instructionState.lFrame.isParent}function setCurrentTNodeAsNotParent(){instructionState.lFrame.isParent=!1}function getContextLView(){const contextLView=instructionState.lFrame.contextLView;return ngDevMode&&root_effect_scheduler_assertDefined(contextLView,"contextLView must be defined."),contextLView}function isInCheckNoChangesMode(){return!ngDevMode&&throwError("Must never be called in production mode"),_checkNoChangesMode!==CheckNoChangesMode.Off}function isExhaustiveCheckNoChanges(){return!ngDevMode&&throwError("Must never be called in production mode"),_checkNoChangesMode===CheckNoChangesMode.Exhaustive}function setIsInCheckNoChangesMode(mode){!ngDevMode&&throwError("Must never be called in production mode"),_checkNoChangesMode=mode}function isRefreshingViews(){return _isRefreshingViews}function setIsRefreshingViews(mode){const prev=_isRefreshingViews;return _isRefreshingViews=mode,prev}function getBindingRoot(){const lFrame=instructionState.lFrame;let index=lFrame.bindingRootIndex;return-1===index&&(index=lFrame.bindingRootIndex=lFrame.tView.bindingStartIndex),index}function getBindingIndex(){return instructionState.lFrame.bindingIndex}function setBindingIndex(value){return instructionState.lFrame.bindingIndex=value}function root_effect_scheduler_nextBindingIndex(){return instructionState.lFrame.bindingIndex++}function incrementBindingIndex(count){const lFrame=instructionState.lFrame,index=lFrame.bindingIndex;return lFrame.bindingIndex=lFrame.bindingIndex+count,index}function setInI18nBlock(isInI18nBlock){instructionState.lFrame.inI18n=isInI18nBlock}function setBindingRootForHostBindings(bindingRootIndex,currentDirectiveIndex){const lFrame=instructionState.lFrame;lFrame.bindingIndex=lFrame.bindingRootIndex=bindingRootIndex,setCurrentDirectiveIndex(currentDirectiveIndex)}function setCurrentDirectiveIndex(currentDirectiveIndex){instructionState.lFrame.currentDirectiveIndex=currentDirectiveIndex}function getCurrentDirectiveDef(tData){const currentDirectiveIndex=instructionState.lFrame.currentDirectiveIndex;return-1===currentDirectiveIndex?null:tData[currentDirectiveIndex]}function getCurrentQueryIndex(){return instructionState.lFrame.currentQueryIndex}function setCurrentQueryIndex(value){instructionState.lFrame.currentQueryIndex=value}function getDeclarationTNode(lView){const tView=lView[1];return 2===tView.type?(ngDevMode&&root_effect_scheduler_assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tView.type?lView[5]:null}function enterDI(lView,tNode,flags){if(ngDevMode&&assertLViewOrUndefined(lView),4&flags){ngDevMode&&assertTNodeForTView(tNode,lView[1]);let parentTNode=tNode,parentLView=lView;for(;!(ngDevMode&&root_effect_scheduler_assertDefined(parentTNode,"Parent TNode should be defined"),parentTNode=parentTNode.parent,null!==parentTNode||1&flags||(parentTNode=getDeclarationTNode(parentLView),null===parentTNode)||(ngDevMode&&root_effect_scheduler_assertDefined(parentLView,"Parent LView should be defined"),parentLView=parentLView[14],10&parentTNode.type)););if(null===parentTNode)return!1;tNode=parentTNode,lView=parentLView}ngDevMode&&assertTNodeForLView(tNode,lView);const lFrame=instructionState.lFrame=allocLFrame();return lFrame.currentTNode=tNode,lFrame.lView=lView,!0}function enterView(newView){ngDevMode&&root_effect_scheduler_assertNotEqual(newView[0],newView[1],"????"),ngDevMode&&assertLViewOrUndefined(newView);const newLFrame=allocLFrame();ngDevMode&&(root_effect_scheduler_assertEqual(newLFrame.isParent,!0,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.lView,null,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.tView,null,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.selectedIndex,-1,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.elementDepthCount,0,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.currentDirectiveIndex,-1,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.currentNamespace,null,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.bindingRootIndex,-1,"Expected clean LFrame"),root_effect_scheduler_assertEqual(newLFrame.currentQueryIndex,0,"Expected clean LFrame"));const tView=newView[1];instructionState.lFrame=newLFrame,ngDevMode&&tView.firstChild&&assertTNodeForTView(tView.firstChild,tView),newLFrame.currentTNode=tView.firstChild,newLFrame.lView=newView,newLFrame.tView=tView,newLFrame.contextLView=newView,newLFrame.bindingIndex=tView.bindingStartIndex,newLFrame.inI18n=!1}function allocLFrame(){const currentLFrame=instructionState.lFrame,childLFrame=null===currentLFrame?null:currentLFrame.child;return null===childLFrame?createLFrame(currentLFrame):childLFrame}function createLFrame(parent){const lFrame={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent,child:null,inI18n:!1};return null!==parent&&(parent.child=lFrame),lFrame}function leaveViewLight(){const oldLFrame=instructionState.lFrame;return instructionState.lFrame=oldLFrame.parent,oldLFrame.currentTNode=null,oldLFrame.lView=null,oldLFrame}const leaveDI=leaveViewLight;function leaveView(){const oldLFrame=leaveViewLight();oldLFrame.isParent=!0,oldLFrame.tView=null,oldLFrame.selectedIndex=-1,oldLFrame.contextLView=null,oldLFrame.elementDepthCount=0,oldLFrame.currentDirectiveIndex=-1,oldLFrame.currentNamespace=null,oldLFrame.bindingRootIndex=-1,oldLFrame.bindingIndex=-1,oldLFrame.currentQueryIndex=0}function getSelectedIndex(){return instructionState.lFrame.selectedIndex}function setSelectedIndex(index){ngDevMode&&-1!==index&&assertGreaterThanOrEqual(index,27,"Index must be past HEADER_OFFSET (or -1)."),ngDevMode&&assertLessThan(index,instructionState.lFrame.lView.length,"Can't set index passed end of LView"),instructionState.lFrame.selectedIndex=index}function root_effect_scheduler_getSelectedTNode(){const lFrame=instructionState.lFrame;return root_effect_scheduler_getTNode(lFrame.tView,lFrame.selectedIndex)}function ɵɵnamespaceSVG(){instructionState.lFrame.currentNamespace="svg"}function ɵɵnamespaceMathML(){instructionState.lFrame.currentNamespace="math"}function ɵɵnamespaceHTML(){!function namespaceHTMLInternal(){instructionState.lFrame.currentNamespace=null}()}let _wasLastNodeCreated=!0;function wasLastNodeCreated(){return _wasLastNodeCreated}function root_effect_scheduler_lastNodeWasCreated(flag){_wasLastNodeCreated=flag}function createInjector(defType,parent=null,additionalProviders=null,name){const injector=createInjectorWithoutInjectorInstances(defType,parent,additionalProviders,name);return injector.resolveInjectorInitializers(),injector}function createInjectorWithoutInjectorInstances(defType,parent=null,additionalProviders=null,name,scopes=new Set){const providers=[additionalProviders||EMPTY_ARRAY,importProvidersFrom(defType)];return name=name||("object"==typeof defType?void 0:stringify(defType)),new R3Injector(providers,parent||root_effect_scheduler_getNullInjector(),name||null,scopes)}class root_effect_scheduler_Injector{static THROW_IF_NOT_FOUND=THROW_IF_NOT_FOUND;static NULL=new NullInjector;static create(options,parent){if(Array.isArray(options))return createInjector({name:""},parent,options,"");{const name=options.name??"";return createInjector({name},options.parent,options.providers,name)}}static ɵprov=ɵɵdefineInjectable({token:root_effect_scheduler_Injector,providedIn:"any",factory:()=>ɵɵinject(INJECTOR$1)});static __NG_ELEMENT_ID__=-1}const DOCUMENT=new InjectionToken(ngDevMode?"DocumentToken":"");class DestroyRef{static __NG_ELEMENT_ID__=injectDestroyRef;static __NG_ENV_ID__=injector=>injector}class NodeInjectorDestroyRef extends DestroyRef{_lView;constructor(_lView){super(),this._lView=_lView}get destroyed(){return isDestroyed(this._lView)}onDestroy(callback){const lView=this._lView;return storeLViewOnDestroy(lView,callback),()=>removeLViewOnDestroy(lView,callback)}}function injectDestroyRef(){return new NodeInjectorDestroyRef(root_effect_scheduler_getLView())}class root_effect_scheduler_ErrorHandler{_console=console;handleError(error){this._console.error("ERROR",error)}}const INTERNAL_APPLICATION_ERROR_HANDLER=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"internal error handler":"",{providedIn:"root",factory:()=>{const injector=root_effect_scheduler_inject(EnvironmentInjector);let userErrorHandler;return e=>{injector.destroyed&&!userErrorHandler?setTimeout(()=>{throw e}):(userErrorHandler??=injector.get(root_effect_scheduler_ErrorHandler),userErrorHandler.handleError(e))}}}),root_effect_scheduler_errorHandlerEnvironmentInitializer={provide:root_effect_scheduler_ENVIRONMENT_INITIALIZER,useValue:()=>{root_effect_scheduler_inject(root_effect_scheduler_ErrorHandler)},multi:!0};new InjectionToken(ngDevMode?"GlobalErrorListeners":"",{providedIn:"root",factory:()=>{if("undefined"!=typeof ngServerMode&&ngServerMode)return;const window=root_effect_scheduler_inject(DOCUMENT).defaultView;if(!window)return;const errorHandler=root_effect_scheduler_inject(INTERNAL_APPLICATION_ERROR_HANDLER),rejectionListener=e=>{errorHandler(e.reason),e.preventDefault()},errorListener=e=>{e.error?errorHandler(e.error):errorHandler(new Error(ngDevMode?`An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}`:e.message,{cause:e})),e.preventDefault()},setupEventListeners=()=>{window.addEventListener("unhandledrejection",rejectionListener),window.addEventListener("error",errorListener)};"undefined"!=typeof Zone?Zone.root.run(setupEventListeners):setupEventListeners(),root_effect_scheduler_inject(DestroyRef).onDestroy(()=>{window.removeEventListener("error",errorListener),window.removeEventListener("unhandledrejection",rejectionListener)})}});function isSignal(value){return"function"==typeof value&&void 0!==value[SIGNAL]}function root_effect_scheduler_signal(initialValue,options){const[get,set,update]=createSignal(initialValue,options?.equal),signalFn=get,node=signalFn[SIGNAL];return signalFn.set=set,signalFn.update=update,signalFn.asReadonly=signalAsReadonlyFn.bind(signalFn),ngDevMode&&(signalFn.toString=()=>`[Signal: ${signalFn()}]`,node.debugName=options?.debugName),signalFn}function signalAsReadonlyFn(){const node=this[SIGNAL];if(void 0===node.readonlyFn){const readonlyFn=()=>this();readonlyFn[SIGNAL]=node,node.readonlyFn=readonlyFn}return node.readonlyFn}function isWritableSignal(value){return isSignal(value)&&"function"==typeof value.set}function root_effect_scheduler_assertNotInReactiveContext(debugFn,extraContext){if(null!==getActiveConsumer())throw new root_effect_scheduler_RuntimeError(-602,ngDevMode&&`${debugFn.name}() cannot be called from within a reactive context.${extraContext?` ${extraContext}`:""}`)}class root_effect_scheduler_ViewContext{view;node;constructor(view,node){this.view=view,this.node=node}static __NG_ELEMENT_ID__=injectViewContext}function injectViewContext(){return new root_effect_scheduler_ViewContext(root_effect_scheduler_getLView(),root_effect_scheduler_getCurrentTNode())}class root_effect_scheduler_ChangeDetectionScheduler{}const root_effect_scheduler_ZONELESS_ENABLED=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"Zoneless enabled":"",{providedIn:"root",factory:()=>!1}),root_effect_scheduler_PROVIDED_ZONELESS=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"Zoneless provided":"",{providedIn:"root",factory:()=>!1}),ZONELESS_SCHEDULER_DISABLED=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"scheduler disabled":""),root_effect_scheduler_SCHEDULE_IN_ROOT_ZONE=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"run changes outside zone in root":"");class PendingTasksInternal{taskId=0;pendingTasks=new Set;destroyed=!1;pendingTask=new BehaviorSubject.t(!1);get hasPendingTasks(){return!this.destroyed&&this.pendingTask.value}get hasPendingTasksObservable(){return this.destroyed?new Observable.c(subscriber=>{subscriber.next(!1),subscriber.complete()}):this.pendingTask}add(){this.hasPendingTasks||this.destroyed||this.pendingTask.next(!0);const taskId=this.taskId++;return this.pendingTasks.add(taskId),taskId}has(taskId){return this.pendingTasks.has(taskId)}remove(taskId){this.pendingTasks.delete(taskId),0===this.pendingTasks.size&&this.hasPendingTasks&&this.pendingTask.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks&&this.pendingTask.next(!1),this.destroyed=!0,this.pendingTask.unsubscribe()}static ɵprov=ɵɵdefineInjectable({token:PendingTasksInternal,providedIn:"root",factory:()=>new PendingTasksInternal})}class PendingTasks{internalPendingTasks=root_effect_scheduler_inject(PendingTasksInternal);scheduler=root_effect_scheduler_inject(root_effect_scheduler_ChangeDetectionScheduler);errorHandler=root_effect_scheduler_inject(INTERNAL_APPLICATION_ERROR_HANDLER);add(){const taskId=this.internalPendingTasks.add();return()=>{this.internalPendingTasks.has(taskId)&&(this.scheduler.notify(11),this.internalPendingTasks.remove(taskId))}}run(fn){const removeTask=this.add();fn().catch(this.errorHandler).finally(removeTask)}static ɵprov=ɵɵdefineInjectable({token:PendingTasks,providedIn:"root",factory:()=>new PendingTasks})}function noop(...args){}class EffectScheduler{static ɵprov=ɵɵdefineInjectable({token:EffectScheduler,providedIn:"root",factory:()=>new ZoneAwareEffectScheduler})}class ZoneAwareEffectScheduler{dirtyEffectCount=0;queues=new Map;add(handle){this.enqueue(handle),this.schedule(handle)}schedule(handle){handle.dirty&&this.dirtyEffectCount++}remove(handle){const zone=handle.zone,queue=this.queues.get(zone);queue.has(handle)&&(queue.delete(handle),handle.dirty&&this.dirtyEffectCount--)}enqueue(handle){const zone=handle.zone;this.queues.has(zone)||this.queues.set(zone,new Set);const queue=this.queues.get(zone);queue.has(handle)||queue.add(handle)}flush(){for(;this.dirtyEffectCount>0;){let ranOneEffect=!1;for(const[zone,queue]of this.queues)ranOneEffect||=null===zone?this.flushQueue(queue):zone.run(()=>this.flushQueue(queue));ranOneEffect||(this.dirtyEffectCount=0)}}flushQueue(queue){let ranOneEffect=!1;for(const handle of queue)handle.dirty&&(this.dirtyEffectCount--,ranOneEffect=!0,handle.run());return ranOneEffect}}var Subject=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/Subject.js"),Subscription=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/Subscription.js"),map=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/operators/map.js");function noSideEffects(fn){return{toString:fn}.toString()}const ANNOTATIONS="__annotations__",PARAMETERS="__parameters__",PROP_METADATA="__prop__metadata__";function makeDecorator(name,props,parentClass,additionalProcessing,typeFn){return noSideEffects(()=>{const metaCtor=makeMetadataCtor(props);function DecoratorFactory(...args){if(this instanceof DecoratorFactory)return metaCtor.call(this,...args),this;const annotationInstance=new DecoratorFactory(...args);return function TypeDecorator(cls){typeFn&&typeFn(cls,...args);return(cls.hasOwnProperty(ANNOTATIONS)?cls[ANNOTATIONS]:Object.defineProperty(cls,ANNOTATIONS,{value:[]})[ANNOTATIONS]).push(annotationInstance),cls}}return parentClass&&(DecoratorFactory.prototype=Object.create(parentClass.prototype)),DecoratorFactory.prototype.ngMetadataName=name,DecoratorFactory.annotationCls=DecoratorFactory,DecoratorFactory})}function makeMetadataCtor(props){return function ctor(...args){if(props){const values=props(...args);for(const propName in values)this[propName]=values[propName]}}}function makeParamDecorator(name,props,parentClass){return noSideEffects(()=>{const metaCtor=makeMetadataCtor(props);function ParamDecoratorFactory(...args){if(this instanceof ParamDecoratorFactory)return metaCtor.apply(this,args),this;const annotationInstance=new ParamDecoratorFactory(...args);return ParamDecorator.annotation=annotationInstance,ParamDecorator;function ParamDecorator(cls,unusedKey,index){const parameters=cls.hasOwnProperty(PARAMETERS)?cls[PARAMETERS]:Object.defineProperty(cls,PARAMETERS,{value:[]})[PARAMETERS];for(;parameters.length<=index;)parameters.push(null);return(parameters[index]=parameters[index]||[]).push(annotationInstance),cls}}return ParamDecoratorFactory.prototype.ngMetadataName=name,ParamDecoratorFactory.annotationCls=ParamDecoratorFactory,ParamDecoratorFactory})}function makePropDecorator(name,props,parentClass,additionalProcessing){return noSideEffects(()=>{const metaCtor=makeMetadataCtor(props);function PropDecoratorFactory(...args){if(this instanceof PropDecoratorFactory)return metaCtor.apply(this,args),this;const decoratorInstance=new PropDecoratorFactory(...args);return function PropDecorator(target,name){if(void 0===target)throw new Error("Standard Angular field decorators are not supported in JIT mode.");const constructor=target.constructor,meta=constructor.hasOwnProperty(PROP_METADATA)?constructor[PROP_METADATA]:Object.defineProperty(constructor,PROP_METADATA,{value:{}})[PROP_METADATA];meta[name]=meta.hasOwnProperty(name)&&meta[name]||[],meta[name].unshift(decoratorInstance)}}return parentClass&&(PropDecoratorFactory.prototype=Object.create(parentClass.prototype)),PropDecoratorFactory.prototype.ngMetadataName=name,PropDecoratorFactory.annotationCls=PropDecoratorFactory,PropDecoratorFactory})}const Inject=attachInjectFlag(makeParamDecorator("Inject",token=>({token})),-1),Optional=attachInjectFlag(makeParamDecorator("Optional"),8),Self=attachInjectFlag(makeParamDecorator("Self"),2),SkipSelf=attachInjectFlag(makeParamDecorator("SkipSelf"),4),Host=attachInjectFlag(makeParamDecorator("Host"),1);function debug_node_getCompilerFacade(request){const globalNg=root_effect_scheduler_global.ng;if(globalNg&&globalNg.ɵcompilerFacade)return globalNg.ɵcompilerFacade;if("undefined"==typeof ngDevMode||ngDevMode){console.error(`JIT compilation failed for ${request.kind}`,request.type);let message=`The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;throw 1===request.usage?(message+=`The ${request.kind} is part of a library that has been partially compiled.\n`,message+="However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n",message+="\n",message+="Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n"):message+="JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n",message+="Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n",message+="or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.",new Error(message)}throw new Error("JIT compiler unavailable")}const angularCoreDiEnv={ɵɵdefineInjectable,ɵɵdefineInjector,ɵɵinject,ɵɵinvalidFactoryDep,resolveForwardRef},Type=Function;function isType(v){return"function"==typeof v}const ES5_DELEGATE_CTOR=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/,ES2015_INHERITED_CLASS=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,ES2015_INHERITED_CLASS_WITH_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;class ReflectionCapabilities{_reflect;constructor(reflect){this._reflect=reflect||root_effect_scheduler_global.Reflect}factory(t){return(...args)=>new t(...args)}_zipTypesAndAnnotations(paramTypes,paramAnnotations){let result;result=newArray(void 0===paramTypes?paramAnnotations.length:paramTypes.length);for(let i=0;i<result.length;i++)void 0===paramTypes?result[i]=[]:paramTypes[i]&&paramTypes[i]!=Object?result[i]=[paramTypes[i]]:result[i]=[],paramAnnotations&&null!=paramAnnotations[i]&&(result[i]=result[i].concat(paramAnnotations[i]));return result}_ownParameters(type,parentCtor){if(function isDelegateCtor(typeStr){return ES5_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS.test(typeStr)&&!ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr)}(type.toString()))return null;if(type.parameters&&type.parameters!==parentCtor.parameters)return type.parameters;const tsickleCtorParams=type.ctorParameters;if(tsickleCtorParams&&tsickleCtorParams!==parentCtor.ctorParameters){const ctorParameters="function"==typeof tsickleCtorParams?tsickleCtorParams():tsickleCtorParams,paramTypes=ctorParameters.map(ctorParam=>ctorParam&&ctorParam.type),paramAnnotations=ctorParameters.map(ctorParam=>ctorParam&&convertTsickleDecoratorIntoMetadata(ctorParam.decorators));return this._zipTypesAndAnnotations(paramTypes,paramAnnotations)}const paramAnnotations=type.hasOwnProperty(PARAMETERS)&&type[PARAMETERS],paramTypes=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata("design:paramtypes",type);return paramTypes||paramAnnotations?this._zipTypesAndAnnotations(paramTypes,paramAnnotations):newArray(type.length)}parameters(type){if(!isType(type))return[];const parentCtor=getParentCtor(type);let parameters=this._ownParameters(type,parentCtor);return parameters||parentCtor===Object||(parameters=this.parameters(parentCtor)),parameters||[]}_ownAnnotations(typeOrFunc,parentCtor){if(typeOrFunc.annotations&&typeOrFunc.annotations!==parentCtor.annotations){let annotations=typeOrFunc.annotations;return"function"==typeof annotations&&annotations.annotations&&(annotations=annotations.annotations),annotations}return typeOrFunc.decorators&&typeOrFunc.decorators!==parentCtor.decorators?convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators):typeOrFunc.hasOwnProperty(ANNOTATIONS)?typeOrFunc[ANNOTATIONS]:null}annotations(typeOrFunc){if(!isType(typeOrFunc))return[];const parentCtor=getParentCtor(typeOrFunc),ownAnnotations=this._ownAnnotations(typeOrFunc,parentCtor)||[];return(parentCtor!==Object?this.annotations(parentCtor):[]).concat(ownAnnotations)}_ownPropMetadata(typeOrFunc,parentCtor){if(typeOrFunc.propMetadata&&typeOrFunc.propMetadata!==parentCtor.propMetadata){let propMetadata=typeOrFunc.propMetadata;return"function"==typeof propMetadata&&propMetadata.propMetadata&&(propMetadata=propMetadata.propMetadata),propMetadata}if(typeOrFunc.propDecorators&&typeOrFunc.propDecorators!==parentCtor.propDecorators){const propDecorators=typeOrFunc.propDecorators,propMetadata={};return Object.keys(propDecorators).forEach(prop=>{propMetadata[prop]=convertTsickleDecoratorIntoMetadata(propDecorators[prop])}),propMetadata}return typeOrFunc.hasOwnProperty(PROP_METADATA)?typeOrFunc[PROP_METADATA]:null}propMetadata(typeOrFunc){if(!isType(typeOrFunc))return{};const parentCtor=getParentCtor(typeOrFunc),propMetadata={};if(parentCtor!==Object){const parentPropMetadata=this.propMetadata(parentCtor);Object.keys(parentPropMetadata).forEach(propName=>{propMetadata[propName]=parentPropMetadata[propName]})}const ownPropMetadata=this._ownPropMetadata(typeOrFunc,parentCtor);return ownPropMetadata&&Object.keys(ownPropMetadata).forEach(propName=>{const decorators=[];propMetadata.hasOwnProperty(propName)&&decorators.push(...propMetadata[propName]),decorators.push(...ownPropMetadata[propName]),propMetadata[propName]=decorators}),propMetadata}ownPropMetadata(typeOrFunc){return isType(typeOrFunc)&&this._ownPropMetadata(typeOrFunc,getParentCtor(typeOrFunc))||{}}hasLifecycleHook(type,lcProperty){return type instanceof Type&&lcProperty in type.prototype}}function convertTsickleDecoratorIntoMetadata(decoratorInvocations){return decoratorInvocations?decoratorInvocations.map(decoratorInvocation=>new(0,decoratorInvocation.type.annotationCls)(...decoratorInvocation.args?decoratorInvocation.args:[])):[]}function getParentCtor(ctor){const parentProto=ctor.prototype?Object.getPrototypeOf(ctor.prototype):null;return(parentProto?parentProto.constructor:null)||Object}class SimpleChange{previousValue;currentValue;firstChange;constructor(previousValue,currentValue,firstChange){this.previousValue=previousValue,this.currentValue=currentValue,this.firstChange=firstChange}isFirstChange(){return this.firstChange}}function applyValueToInputField(instance,inputSignalNode,privateName,value){null!==inputSignalNode?inputSignalNode.applyValueToInputSignal(inputSignalNode,value):instance[privateName]=value}const ɵɵNgOnChangesFeature=(()=>{const ɵɵNgOnChangesFeatureImpl=()=>NgOnChangesFeatureImpl;return ɵɵNgOnChangesFeatureImpl.ngInherit=!0,ɵɵNgOnChangesFeatureImpl})();function NgOnChangesFeatureImpl(definition){return definition.type.prototype.ngOnChanges&&(definition.setInput=ngOnChangesSetInput),rememberChangeHistoryAndInvokeOnChangesHook}function rememberChangeHistoryAndInvokeOnChangesHook(){const simpleChangesStore=getSimpleChangesStore(this),current=simpleChangesStore?.current;if(current){const previous=simpleChangesStore.previous;if(previous===EMPTY_OBJ)simpleChangesStore.previous=current;else for(let key in current)previous[key]=current[key];simpleChangesStore.current=null,this.ngOnChanges(current)}}function ngOnChangesSetInput(instance,inputSignalNode,value,publicName,privateName){const declaredName=this.declaredInputs[publicName];ngDevMode&&assertString(declaredName,"Name of input in ngOnChanges has to be a string");const simpleChangesStore=getSimpleChangesStore(instance)||function setSimpleChangesStore(instance,store){return instance[SIMPLE_CHANGES_STORE]=store}(instance,{previous:EMPTY_OBJ,current:null}),current=simpleChangesStore.current||(simpleChangesStore.current={}),previous=simpleChangesStore.previous,previousChange=previous[declaredName];current[declaredName]=new SimpleChange(previousChange&&previousChange.currentValue,value,previous===EMPTY_OBJ),applyValueToInputField(instance,inputSignalNode,privateName,value)}const SIMPLE_CHANGES_STORE="__ngSimpleChanges__";function getSimpleChangesStore(instance){return instance[SIMPLE_CHANGES_STORE]||null}const profilerCallbacks=[],debug_node_NOOP_PROFILER_REMOVAL=()=>{};function setProfiler(profiler){return null!==profiler?(profilerCallbacks.includes(profiler)||profilerCallbacks.push(profiler),()=>function debug_node_removeProfiler(profiler){const profilerIdx=profilerCallbacks.indexOf(profiler);-1!==profilerIdx&&profilerCallbacks.splice(profilerIdx,1)}(profiler)):(profilerCallbacks.length=0,debug_node_NOOP_PROFILER_REMOVAL)}const debug_node_profiler=function(event,instance=null,eventFn){for(let i=0;i<profilerCallbacks.length;i++){(0,profilerCallbacks[i])(event,instance,eventFn)}};function registerPostOrderHooks(tView,tNode){ngDevMode&&assertFirstCreatePass(tView);for(let i=tNode.directiveStart,end=tNode.directiveEnd;i<end;i++){const directiveDef=tView.data[i];ngDevMode&&root_effect_scheduler_assertDefined(directiveDef,"Expecting DirectiveDef");const lifecycleHooks=directiveDef.type.prototype,{ngAfterContentInit,ngAfterContentChecked,ngAfterViewInit,ngAfterViewChecked,ngOnDestroy}=lifecycleHooks;ngAfterContentInit&&(tView.contentHooks??=[]).push(-i,ngAfterContentInit),ngAfterContentChecked&&((tView.contentHooks??=[]).push(i,ngAfterContentChecked),(tView.contentCheckHooks??=[]).push(i,ngAfterContentChecked)),ngAfterViewInit&&(tView.viewHooks??=[]).push(-i,ngAfterViewInit),ngAfterViewChecked&&((tView.viewHooks??=[]).push(i,ngAfterViewChecked),(tView.viewCheckHooks??=[]).push(i,ngAfterViewChecked)),null!=ngOnDestroy&&(tView.destroyHooks??=[]).push(i,ngOnDestroy)}}function executeCheckHooks(lView,hooks,nodeIndex){callHooks(lView,hooks,3,nodeIndex)}function executeInitAndCheckHooks(lView,hooks,initPhase,nodeIndex){ngDevMode&&root_effect_scheduler_assertNotEqual(initPhase,3,"Init pre-order hooks should not be called more than once"),(3&lView[2])===initPhase&&callHooks(lView,hooks,initPhase,nodeIndex)}function incrementInitPhaseFlags(lView,initPhase){ngDevMode&&root_effect_scheduler_assertNotEqual(initPhase,3,"Init hooks phase should not be incremented after all init hooks have been run.");let flags=lView[2];(3&flags)===initPhase&&(flags&=16383,flags+=1,lView[2]=flags)}function callHooks(currentView,arr,initPhase,currentNodeIndex){ngDevMode&&root_effect_scheduler_assertEqual(isInCheckNoChangesMode(),!1,"Hooks should never be run when in check no changes mode.");const startIndex=void 0!==currentNodeIndex?65535&currentView[17]:0,nodeIndexLimit=null!=currentNodeIndex?currentNodeIndex:-1,max=arr.length-1;let lastNodeIndexFound=0;for(let i=startIndex;i<max;i++){if("number"==typeof arr[i+1]){if(lastNodeIndexFound=arr[i],null!=currentNodeIndex&&lastNodeIndexFound>=currentNodeIndex)break}else{arr[i]<0&&(currentView[17]+=65536),(lastNodeIndexFound<nodeIndexLimit||-1==nodeIndexLimit)&&(callHook(currentView,initPhase,arr,i),currentView[17]=(4294901760&currentView[17])+i+2),i++}}}function callHookInternal(directive,hook){debug_node_profiler(4,directive,hook);const prevConsumer=setActiveConsumer(null);try{hook.call(directive)}finally{setActiveConsumer(prevConsumer),debug_node_profiler(5,directive,hook)}}function callHook(currentView,initPhase,arr,i){const isInitHook=arr[i]<0,hook=arr[i+1],directive=currentView[isInitHook?-arr[i]:arr[i]];if(isInitHook){currentView[2]>>14<currentView[17]>>16&&(3&currentView[2])===initPhase&&(currentView[2]+=16384,callHookInternal(directive,hook))}else callHookInternal(directive,hook)}class NodeInjectorFactory{factory;name;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(factory,isViewProvider,injectImplementation,name){this.factory=factory,this.name=name,ngDevMode&&root_effect_scheduler_assertDefined(factory,"Factory not specified"),ngDevMode&&root_effect_scheduler_assertEqual(typeof factory,"function","Expected factory function."),this.canSeeViewProviders=isViewProvider,this.injectImpl=injectImplementation}}function toTNodeTypeAsString(tNodeType){let text="";return 1&tNodeType&&(text+="|Text"),2&tNodeType&&(text+="|Element"),4&tNodeType&&(text+="|Container"),8&tNodeType&&(text+="|ElementContainer"),16&tNodeType&&(text+="|Projection"),32&tNodeType&&(text+="|IcuContainer"),64&tNodeType&&(text+="|Placeholder"),128&tNodeType&&(text+="|LetDeclaration"),text.length>0?text.substring(1):text}function debug_node_isTNodeShape(value){return null!=value&&"object"==typeof value&&(null===value.insertBeforeIndex||"number"==typeof value.insertBeforeIndex||Array.isArray(value.insertBeforeIndex))}function assertTNodeType(tNode,expectedTypes,message){root_effect_scheduler_assertDefined(tNode,"should be called with a TNode"),0===(tNode.type&expectedTypes)&&throwError(message||`Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`)}function isNameOnlyAttributeMarker(marker){return 3===marker||4===marker||6===marker}function isAnimationProp(name){return 64===name.charCodeAt(0)}function mergeHostAttrs(dst,src){if(null===src||0===src.length);else if(null===dst||0===dst.length)dst=src.slice();else{let srcMarker=-1;for(let i=0;i<src.length;i++){const item=src[i];"number"==typeof item?srcMarker=item:0===srcMarker||mergeHostAttribute(dst,srcMarker,item,null,-1===srcMarker||2===srcMarker?src[++i]:null)}}return dst}function mergeHostAttribute(dst,marker,key1,key2,value){let i=0,markerInsertPosition=dst.length;if(-1===marker)markerInsertPosition=-1;else for(;i<dst.length;){const dstValue=dst[i++];if("number"==typeof dstValue){if(dstValue===marker){markerInsertPosition=-1;break}if(dstValue>marker){markerInsertPosition=i-1;break}}}for(;i<dst.length;){const item=dst[i];if("number"==typeof item)break;if(item===key1)return void(null!==value&&(dst[i+1]=value));i++,null!==value&&i++}-1!==markerInsertPosition&&(dst.splice(markerInsertPosition,0,marker),i=markerInsertPosition+1),dst.splice(i++,0,key1),null!==value&&dst.splice(i++,0,value)}function hasParentInjector(parentLocation){return-1!==parentLocation}function getParentInjectorIndex(parentLocation){if(ngDevMode){root_effect_scheduler_assertNumber(parentLocation,"Number expected"),root_effect_scheduler_assertNotEqual(parentLocation,-1,"Not a valid state.");assertGreaterThan(32767&parentLocation,27,"Parent injector must be pointing past HEADER_OFFSET.")}return 32767&parentLocation}function getParentInjectorView(location,startView){let viewOffset=function getParentInjectorViewOffset(parentLocation){return parentLocation>>16}(location),parentView=startView;for(;viewOffset>0;)parentView=parentView[14],viewOffset--;return parentView}let includeViewProviders=!0;function setIncludeViewProviders(v){const oldValue=includeViewProviders;return includeViewProviders=v,oldValue}let nextNgElementId=0;const debug_node_NOT_FOUND={};function getOrCreateNodeInjectorForNode(tNode,lView){const existingInjectorIndex=getInjectorIndex(tNode,lView);if(-1!==existingInjectorIndex)return existingInjectorIndex;const tView=lView[1];tView.firstCreatePass&&(tNode.injectorIndex=lView.length,insertBloom(tView.data,tNode),insertBloom(lView,null),insertBloom(tView.blueprint,null));const parentLoc=getParentInjectorLocation(tNode,lView),injectorIndex=tNode.injectorIndex;if(hasParentInjector(parentLoc)){const parentIndex=getParentInjectorIndex(parentLoc),parentLView=getParentInjectorView(parentLoc,lView),parentData=parentLView[1].data;for(let i=0;i<8;i++)lView[injectorIndex+i]=parentLView[parentIndex+i]|parentData[parentIndex+i]}return lView[injectorIndex+8]=parentLoc,injectorIndex}function insertBloom(arr,footer){arr.push(0,0,0,0,0,0,0,0,footer)}function getInjectorIndex(tNode,lView){return-1===tNode.injectorIndex||tNode.parent&&tNode.parent.injectorIndex===tNode.injectorIndex||null===lView[tNode.injectorIndex+8]?-1:(ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,tNode.injectorIndex),tNode.injectorIndex)}function getParentInjectorLocation(tNode,lView){if(tNode.parent&&-1!==tNode.parent.injectorIndex)return tNode.parent.injectorIndex;let declarationViewOffset=0,parentTNode=null,lViewCursor=lView;for(;null!==lViewCursor;){if(parentTNode=getTNodeFromLView(lViewCursor),null===parentTNode)return-1;if(ngDevMode&&parentTNode&&assertTNodeForLView(parentTNode,lViewCursor[14]),declarationViewOffset++,lViewCursor=lViewCursor[14],-1!==parentTNode.injectorIndex)return parentTNode.injectorIndex|declarationViewOffset<<16}return-1}function diPublicInInjector(injectorIndex,tView,token){!function bloomAdd(injectorIndex,tView,type){let id;ngDevMode&&root_effect_scheduler_assertEqual(tView.firstCreatePass,!0,"expected firstCreatePass to be true"),"string"==typeof type?id=type.charCodeAt(0)||0:type.hasOwnProperty(NG_ELEMENT_ID)&&(id=type[NG_ELEMENT_ID]),null==id&&(id=type[NG_ELEMENT_ID]=nextNgElementId++);const bloomHash=255&id,mask=1<<bloomHash;tView.data[injectorIndex+(bloomHash>>5)]|=mask}(injectorIndex,tView,token)}function notFoundValueOrThrow(notFoundValue,token,flags){if(8&flags||void 0!==notFoundValue)return notFoundValue;throwProviderNotFoundError(token,"NodeInjector")}function lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue){if(8&flags&&void 0===notFoundValue&&(notFoundValue=null),!(3&flags)){const moduleInjector=lView[9],previousInjectImplementation=setInjectImplementation(void 0);try{return moduleInjector?moduleInjector.get(token,notFoundValue,8&flags):injectRootLimpMode(token,notFoundValue,8&flags)}finally{setInjectImplementation(previousInjectImplementation)}}return notFoundValueOrThrow(notFoundValue,token,flags)}function getOrCreateInjectable(tNode,lView,token,flags=0,notFoundValue){if(null!==tNode){if(2048&lView[2]&&!(2&flags)){const embeddedInjectorValue=function lookupTokenUsingEmbeddedInjector(tNode,lView,token,flags,notFoundValue){let currentTNode=tNode,currentLView=lView;for(;null!==currentTNode&&null!==currentLView&&2048&currentLView[2]&&!root_effect_scheduler_isRootView(currentLView);){ngDevMode&&assertTNodeForLView(currentTNode,currentLView);const nodeInjectorValue=lookupTokenUsingNodeInjector(currentTNode,currentLView,token,2|flags,debug_node_NOT_FOUND);if(nodeInjectorValue!==debug_node_NOT_FOUND)return nodeInjectorValue;let parentTNode=currentTNode.parent;if(!parentTNode){const embeddedViewInjector=currentLView[20];if(embeddedViewInjector){const embeddedViewInjectorValue=embeddedViewInjector.get(token,debug_node_NOT_FOUND,flags);if(embeddedViewInjectorValue!==debug_node_NOT_FOUND)return embeddedViewInjectorValue}parentTNode=getTNodeFromLView(currentLView),currentLView=currentLView[14]}currentTNode=parentTNode}return notFoundValue}(tNode,lView,token,flags,debug_node_NOT_FOUND);if(embeddedInjectorValue!==debug_node_NOT_FOUND)return embeddedInjectorValue}const value=lookupTokenUsingNodeInjector(tNode,lView,token,flags,debug_node_NOT_FOUND);if(value!==debug_node_NOT_FOUND)return value}return lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue)}function lookupTokenUsingNodeInjector(tNode,lView,token,flags,notFoundValue){const bloomHash=function bloomHashBitOrFactory(token){if(ngDevMode&&root_effect_scheduler_assertDefined(token,"token must be defined"),"string"==typeof token)return token.charCodeAt(0)||0;const tokenId=token.hasOwnProperty(NG_ELEMENT_ID)?token[NG_ELEMENT_ID]:void 0;return"number"==typeof tokenId?tokenId>=0?255&tokenId:(ngDevMode&&root_effect_scheduler_assertEqual(tokenId,-1,"Expecting to get Special Injector Id"),createNodeInjector):tokenId}(token);if("function"==typeof bloomHash){if(!enterDI(lView,tNode,flags))return 1&flags?notFoundValueOrThrow(notFoundValue,token,flags):lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue);try{let value;if(ngDevMode?runInInjectorProfilerContext(new NodeInjector(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView()),token,()=>{emitInjectorToCreateInstanceEvent(token),value=bloomHash(flags),emitInstanceCreatedByInjectorEvent(value)}):value=bloomHash(flags),null!=value||8&flags)return value;throwProviderNotFoundError(token)}finally{leaveDI()}}else if("number"==typeof bloomHash){let previousTView=null,injectorIndex=getInjectorIndex(tNode,lView),parentLocation=-1,hostTElementNode=1&flags?lView[15][5]:null;for((-1===injectorIndex||4&flags)&&(parentLocation=-1===injectorIndex?getParentInjectorLocation(tNode,lView):lView[injectorIndex+8],-1!==parentLocation&&shouldSearchParent(flags,!1)?(previousTView=lView[1],injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1);-1!==injectorIndex;){ngDevMode&&assertNodeInjector(lView,injectorIndex);const tView=lView[1];if(ngDevMode&&assertTNodeForLView(tView.data[injectorIndex+8],lView),bloomHasToken(bloomHash,injectorIndex,tView.data)){const instance=searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode);if(instance!==debug_node_NOT_FOUND)return instance}parentLocation=lView[injectorIndex+8],-1!==parentLocation&&shouldSearchParent(flags,lView[1].data[injectorIndex+8]===hostTElementNode)&&bloomHasToken(bloomHash,injectorIndex,lView)?(previousTView=tView,injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1}}return notFoundValue}function searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode){const currentTView=lView[1],tNode=currentTView.data[injectorIndex+8],injectableIdx=locateDirectiveOrProvider(tNode,currentTView,token,null==previousTView?root_effect_scheduler_isComponentHost(tNode)&&includeViewProviders:previousTView!=currentTView&&!!(3&tNode.type),1&flags&&hostTElementNode===tNode);return null!==injectableIdx?getNodeInjectable(lView,currentTView,injectableIdx,tNode,flags):debug_node_NOT_FOUND}function locateDirectiveOrProvider(tNode,tView,token,canAccessViewProviders,isHostSpecialCase){const nodeProviderIndexes=tNode.providerIndexes,tInjectables=tView.data,injectablesStart=1048575&nodeProviderIndexes,directivesStart=tNode.directiveStart,directiveEnd=tNode.directiveEnd,cptViewProvidersCount=nodeProviderIndexes>>20,endIndex=isHostSpecialCase?injectablesStart+cptViewProvidersCount:directiveEnd;for(let i=canAccessViewProviders?injectablesStart:injectablesStart+cptViewProvidersCount;i<endIndex;i++){const providerTokenOrDef=tInjectables[i];if(i<directivesStart&&token===providerTokenOrDef||i>=directivesStart&&providerTokenOrDef.type===token)return i}if(isHostSpecialCase){const dirDef=tInjectables[directivesStart];if(dirDef&&isComponentDef(dirDef)&&dirDef.type===token)return directivesStart}return null}let injectionPath=[];function getNodeInjectable(lView,tView,index,tNode,flags){let value=lView[index];const tData=tView.data;if(value instanceof NodeInjectorFactory){const factory=value;if(ngDevMode&&injectionPath.push(factory.name??"unknown"),factory.resolving){const token=root_effect_scheduler_stringifyForError(tData[index]);throw ngDevMode?cyclicDependencyErrorWithDetails(token,injectionPath):cyclicDependencyError(token)}const previousIncludeViewProviders=setIncludeViewProviders(factory.canSeeViewProviders);factory.resolving=!0;const token=tData[index].type||tData[index];let prevInjectContext;if(ngDevMode){prevInjectContext=setInjectorProfilerContext({injector:new NodeInjector(tNode,lView),token})}const previousInjectImplementation=factory.injectImpl?setInjectImplementation(factory.injectImpl):null,success=enterDI(lView,tNode,0);ngDevMode&&root_effect_scheduler_assertEqual(success,!0,"Because flags do not contain `SkipSelf' we expect this to always succeed.");try{ngDevMode&&emitInjectorToCreateInstanceEvent(token),value=lView[index]=factory.factory(void 0,flags,tData,lView,tNode),ngDevMode&&emitInstanceCreatedByInjectorEvent(value),tView.firstCreatePass&&index>=tNode.directiveStart&&(ngDevMode&&function assertDirectiveDef(obj){void 0!==obj.type&&null!=obj.selectors&&void 0!==obj.inputs||throwError("Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.")}(tData[index]),function registerPreOrderHooks(directiveIndex,directiveDef,tView){ngDevMode&&assertFirstCreatePass(tView);const{ngOnChanges,ngOnInit,ngDoCheck}=directiveDef.type.prototype;if(ngOnChanges){const wrappedOnChanges=NgOnChangesFeatureImpl(directiveDef);(tView.preOrderHooks??=[]).push(directiveIndex,wrappedOnChanges),(tView.preOrderCheckHooks??=[]).push(directiveIndex,wrappedOnChanges)}ngOnInit&&(tView.preOrderHooks??=[]).push(0-directiveIndex,ngOnInit),ngDoCheck&&((tView.preOrderHooks??=[]).push(directiveIndex,ngDoCheck),(tView.preOrderCheckHooks??=[]).push(directiveIndex,ngDoCheck))}(index,tData[index],tView))}finally{ngDevMode&&setInjectorProfilerContext(prevInjectContext),null!==previousInjectImplementation&&setInjectImplementation(previousInjectImplementation),setIncludeViewProviders(previousIncludeViewProviders),factory.resolving=!1,leaveDI(),ngDevMode&&(injectionPath=[])}}return value}function bloomHasToken(bloomHash,injectorIndex,injectorView){const mask=1<<bloomHash;return!!(injectorView[injectorIndex+(bloomHash>>5)]&mask)}function shouldSearchParent(flags,isFirstHostTNode){return!(2&flags||1&flags&&isFirstHostTNode)}function getNodeInjectorLView(nodeInjector){return nodeInjector._lView}function getNodeInjectorTNode(nodeInjector){return nodeInjector._tNode}class NodeInjector{_tNode;_lView;constructor(_tNode,_lView){this._tNode=_tNode,this._lView=_lView}get(token,notFoundValue,flags){return getOrCreateInjectable(this._tNode,this._lView,token,convertToBitFlags(flags),notFoundValue)}}function createNodeInjector(){return new NodeInjector(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView())}function ɵɵgetInheritedFactory(type){return noSideEffects(()=>{const ownConstructor=type.prototype.constructor,ownFactory=ownConstructor[NG_FACTORY_DEF]||getFactoryOf(ownConstructor),objectPrototype=Object.prototype;let parent=Object.getPrototypeOf(type.prototype).constructor;for(;parent&&parent!==objectPrototype;){const factory=parent[NG_FACTORY_DEF]||getFactoryOf(parent);if(factory&&factory!==ownFactory)return factory;parent=Object.getPrototypeOf(parent)}return t=>new t})}function getFactoryOf(type){return isForwardRef(type)?()=>{const factory=getFactoryOf(resolveForwardRef(type));return factory&&factory()}:getFactoryDef(type)}function getTNodeFromLView(lView){const tView=lView[1],tViewType=tView.type;return 2===tViewType?(ngDevMode&&root_effect_scheduler_assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tViewType?lView[5]:null}function ɵɵinjectAttribute(attrNameToInject){return function injectAttributeImpl(tNode,attrNameToInject){if(ngDevMode&&assertTNodeType(tNode,15),ngDevMode&&root_effect_scheduler_assertDefined(tNode,"expecting tNode"),"class"===attrNameToInject)return tNode.classes;if("style"===attrNameToInject)return tNode.styles;const attrs=tNode.attrs;if(attrs){const attrsLength=attrs.length;let i=0;for(;i<attrsLength;){const value=attrs[i];if(isNameOnlyAttributeMarker(value))break;if(0===value)i+=2;else if("number"==typeof value)for(i++;i<attrsLength&&"string"==typeof attrs[i];)i++;else{if(value===attrNameToInject)return attrs[i+1];i+=2}}}return null}(root_effect_scheduler_getCurrentTNode(),attrNameToInject)}const debug_node_Attribute=makeParamDecorator("Attribute",attributeName=>({attributeName,__NG_ELEMENT_ID__:()=>ɵɵinjectAttribute(attributeName)}));let _reflect=null;function getReflect(){return _reflect=_reflect||new ReflectionCapabilities}function reflectDependencies(type){return convertDependencies(getReflect().parameters(type))}function convertDependencies(deps){return deps.map(dep=>function reflectDependency(dep){const meta={token:null,attribute:null,host:!1,optional:!1,self:!1,skipSelf:!1};if(Array.isArray(dep)&&dep.length>0)for(let j=0;j<dep.length;j++){const param=dep[j];if(void 0===param)continue;const proto=Object.getPrototypeOf(param);if(param instanceof Optional||"Optional"===proto.ngMetadataName)meta.optional=!0;else if(param instanceof SkipSelf||"SkipSelf"===proto.ngMetadataName)meta.skipSelf=!0;else if(param instanceof Self||"Self"===proto.ngMetadataName)meta.self=!0;else if(param instanceof Host||"Host"===proto.ngMetadataName)meta.host=!0;else if(param instanceof Inject)meta.token=param.token;else if(param instanceof debug_node_Attribute){if(void 0===param.attributeName)throw new root_effect_scheduler_RuntimeError(204,ngDevMode&&"Attribute name must be defined.");meta.attribute=param.attributeName}else meta.token=param}else void 0===dep||Array.isArray(dep)&&0===dep.length?meta.token=null:meta.token=dep;return meta}(dep))}function compileInjectable(type,meta){let ngInjectableDef=null,ngFactoryDef=null;type.hasOwnProperty(NG_PROV_DEF)||Object.defineProperty(type,NG_PROV_DEF,{get:()=>{if(null===ngInjectableDef){const compiler=debug_node_getCompilerFacade({usage:0,kind:"injectable",type});ngInjectableDef=compiler.compileInjectable(angularCoreDiEnv,`ng:///${type.name}/ɵprov.js`,function getInjectableMetadata(type,srcMeta){const meta=srcMeta||{providedIn:null},compilerMeta={name:type.name,type,typeArgumentCount:0,providedIn:meta.providedIn};(isUseClassProvider(meta)||isUseFactoryProvider(meta))&&void 0!==meta.deps&&(compilerMeta.deps=convertDependencies(meta.deps));isUseClassProvider(meta)?compilerMeta.useClass=meta.useClass:!function isUseValueProvider(meta){return debug_node_USE_VALUE in meta}(meta)?isUseFactoryProvider(meta)?compilerMeta.useFactory=meta.useFactory:function isUseExistingProvider(meta){return void 0!==meta.useExisting}(meta)&&(compilerMeta.useExisting=meta.useExisting):compilerMeta.useValue=meta.useValue;return compilerMeta}(type,meta))}return ngInjectableDef}}),type.hasOwnProperty(NG_FACTORY_DEF)||Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const compiler=debug_node_getCompilerFacade({usage:0,kind:"injectable",type});ngFactoryDef=compiler.compileFactory(angularCoreDiEnv,`ng:///${type.name}/ɵfac.js`,{name:type.name,type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Injectable})}return ngFactoryDef},configurable:!0})}const debug_node_USE_VALUE=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isUseClassProvider(meta){return void 0!==meta.useClass}function isUseFactoryProvider(meta){return void 0!==meta.useFactory}const Injectable=makeDecorator("Injectable",void 0,void 0,0,(type,meta)=>compileInjectable(type,meta));function injectElementRef(){return createElementRef(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView())}function createElementRef(tNode,lView){return new ElementRef(root_effect_scheduler_getNativeByTNode(tNode,lView))}class ElementRef{nativeElement;constructor(nativeElement){this.nativeElement=nativeElement}static __NG_ELEMENT_ID__=injectElementRef}function unwrapElementRef(value){return value instanceof ElementRef?value.nativeElement:value}function symbolIterator(){return this._results[Symbol.iterator]()}class QueryList{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new Subject.B}constructor(_emitDistinctChangesOnly=!1){this._emitDistinctChangesOnly=_emitDistinctChangesOnly}get(index){return this._results[index]}map(fn){return this._results.map(fn)}filter(fn){return this._results.filter(fn)}find(fn){return this._results.find(fn)}reduce(fn,init){return this._results.reduce(fn,init)}forEach(fn){this._results.forEach(fn)}some(fn){return this._results.some(fn)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(resultsTree,identityAccessor){this.dirty=!1;const newResultFlat=flatten(resultsTree);(this._changesDetected=!function arrayEquals(a,b,identityAccessor){if(a.length!==b.length)return!1;for(let i=0;i<a.length;i++){let valueA=a[i],valueB=b[i];if(identityAccessor&&(valueA=identityAccessor(valueA),valueB=identityAccessor(valueB)),valueB!==valueA)return!1}return!0}(this._results,newResultFlat,identityAccessor))&&(this._results=newResultFlat,this.length=newResultFlat.length,this.last=newResultFlat[this.length-1],this.first=newResultFlat[0])}notifyOnChanges(){void 0===this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.next(this)}onDirty(cb){this._onDirty=cb}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){void 0!==this._changes&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=(()=>symbolIterator)()}function hasInSkipHydrationBlockFlag(tNode){return!(128&~tNode.flags)}var ChangeDetectionStrategy;!function(ChangeDetectionStrategy){ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush=0]="OnPush",ChangeDetectionStrategy[ChangeDetectionStrategy.Default=1]="Default"}(ChangeDetectionStrategy||(ChangeDetectionStrategy={}));const TRACKED_LVIEWS=new Map;let uniqueIdCounter=0;function getLViewById(id){return ngDevMode&&root_effect_scheduler_assertNumber(id,"ID used for LView lookup must be a number"),TRACKED_LVIEWS.get(id)||null}function unregisterLView(lView){ngDevMode&&root_effect_scheduler_assertNumber(lView[19],"Cannot stop tracking an LView that does not have an ID"),TRACKED_LVIEWS.delete(lView[19])}class LContext{lViewId;nodeIndex;native;component;directives;localRefs;get lView(){return getLViewById(this.lViewId)}constructor(lViewId,nodeIndex,native){this.lViewId=lViewId,this.nodeIndex=nodeIndex,this.native=native}}function getLContext(target){let mpValue=readPatchedData(target);if(mpValue){if(root_effect_scheduler_isLView(mpValue)){const lView=mpValue;let nodeIndex,component,directives;if(isComponentInstance(target)){if(nodeIndex=findViaComponent(lView,target),-1==nodeIndex)throw new Error("The provided component was not found in the application");component=target}else if(function isDirectiveInstance(instance){return instance&&instance.constructor&&instance.constructor.ɵdir}(target)){if(nodeIndex=function findViaDirective(lView,directiveInstance){let tNode=lView[1].firstChild;for(;tNode;){const directiveIndexStart=tNode.directiveStart,directiveIndexEnd=tNode.directiveEnd;for(let i=directiveIndexStart;i<directiveIndexEnd;i++)if(lView[i]===directiveInstance)return tNode.index;tNode=traverseNextElement(tNode)}return-1}(lView,target),-1==nodeIndex)throw new Error("The provided directive was not found in the application");directives=getDirectivesAtNodeIndex(nodeIndex,lView)}else if(nodeIndex=findViaNativeElement(lView,target),-1==nodeIndex)return null;const native=root_effect_scheduler_unwrapRNode(lView[nodeIndex]),existingCtx=readPatchedData(native),context=existingCtx&&!Array.isArray(existingCtx)?existingCtx:createLContext(lView,nodeIndex,native);if(component&&void 0===context.component&&(context.component=component,attachPatchData(context.component,context)),directives&&void 0===context.directives){context.directives=directives;for(let i=0;i<directives.length;i++)attachPatchData(directives[i],context)}attachPatchData(context.native,context),mpValue=context}}else{const rElement=target;ngDevMode&&assertDomNode(rElement);let parent=rElement;for(;parent=parent.parentNode;){const parentContext=readPatchedData(parent);if(parentContext){const lView=Array.isArray(parentContext)?parentContext:parentContext.lView;if(!lView)return null;const index=findViaNativeElement(lView,rElement);if(index>=0){const native=root_effect_scheduler_unwrapRNode(lView[index]),context=createLContext(lView,index,native);attachPatchData(native,context),mpValue=context;break}}}}return mpValue||null}function createLContext(lView,nodeIndex,native){return new LContext(lView[19],nodeIndex,native)}function getComponentViewByInstance(componentInstance){let lView,patchedData=readPatchedData(componentInstance);if(root_effect_scheduler_isLView(patchedData)){const contextLView=patchedData,nodeIndex=findViaComponent(contextLView,componentInstance);lView=root_effect_scheduler_getComponentLViewByIndex(nodeIndex,contextLView);const context=createLContext(contextLView,nodeIndex,lView[0]);context.component=componentInstance,attachPatchData(componentInstance,context),attachPatchData(context.native,context)}else{const context=patchedData,contextLView=context.lView;ngDevMode&&assertLView(contextLView),lView=root_effect_scheduler_getComponentLViewByIndex(context.nodeIndex,contextLView)}return lView}const MONKEY_PATCH_KEY_NAME="__ngContext__";function attachPatchData(target,data){ngDevMode&&root_effect_scheduler_assertDefined(target,"Target expected"),root_effect_scheduler_isLView(data)?(target[MONKEY_PATCH_KEY_NAME]=data[19],function registerLView(lView){ngDevMode&&root_effect_scheduler_assertNumber(lView[19],"LView must have an ID in order to be registered"),TRACKED_LVIEWS.set(lView[19],lView)}(data)):target[MONKEY_PATCH_KEY_NAME]=data}function readPatchedData(target){ngDevMode&&root_effect_scheduler_assertDefined(target,"Target expected");const data=target[MONKEY_PATCH_KEY_NAME];return"number"==typeof data?getLViewById(data):data||null}function debug_node_readPatchedLView(target){const value=readPatchedData(target);return value?root_effect_scheduler_isLView(value)?value:value.lView:null}function isComponentInstance(instance){return instance&&instance.constructor&&instance.constructor.ɵcmp}function findViaNativeElement(lView,target){const tView=lView[1];for(let i=27;i<tView.bindingStartIndex;i++)if(root_effect_scheduler_unwrapRNode(lView[i])===target)return i;return-1}function traverseNextElement(tNode){if(tNode.child)return tNode.child;if(tNode.next)return tNode.next;for(;tNode.parent&&!tNode.parent.next;)tNode=tNode.parent;return tNode.parent&&tNode.parent.next}function findViaComponent(lView,componentInstance){const componentIndices=lView[1].components;if(componentIndices)for(let i=0;i<componentIndices.length;i++){const elementComponentIndex=componentIndices[i];if(root_effect_scheduler_getComponentLViewByIndex(elementComponentIndex,lView)[8]===componentInstance)return elementComponentIndex}else{if(root_effect_scheduler_getComponentLViewByIndex(27,lView)[8]===componentInstance)return 27}return-1}function getDirectivesAtNodeIndex(nodeIndex,lView){const tNode=lView[1].data[nodeIndex];if(0===tNode.directiveStart)return EMPTY_ARRAY;const results=[];for(let i=tNode.directiveStart;i<tNode.directiveEnd;i++){const directiveInstance=lView[i];isComponentInstance(directiveInstance)||results.push(directiveInstance)}return results}function getRootContext(viewOrComponent){const rootView=function getRootView(componentOrLView){ngDevMode&&root_effect_scheduler_assertDefined(componentOrLView,"component");let lView=root_effect_scheduler_isLView(componentOrLView)?componentOrLView:debug_node_readPatchedLView(componentOrLView);for(;lView&&!root_effect_scheduler_isRootView(lView);)lView=getLViewParent(lView);return ngDevMode&&assertLView(lView),lView}(viewOrComponent);return ngDevMode&&root_effect_scheduler_assertDefined(rootView[8],"Root view has no context. Perhaps it is disconnected?"),rootView[8]}function getFirstLContainer(lView){return getNearestLContainer(lView[12])}function getNextLContainer(container){return getNearestLContainer(container[4])}function getNearestLContainer(viewOrContainer){for(;null!==viewOrContainer&&!root_effect_scheduler_isLContainer(viewOrContainer);)viewOrContainer=viewOrContainer[4];return viewOrContainer}function getComponent(element){ngDevMode&&assertDomElement(element);const context=getLContext(element);if(null===context)return null;if(void 0===context.component){const lView=context.lView;if(null===lView)return null;context.component=function getComponentAtNodeIndex(nodeIndex,lView){const tNode=lView[1].data[nodeIndex];return root_effect_scheduler_isComponentHost(tNode)?lView[tNode.directiveStart+tNode.componentOffset]:null}(context.nodeIndex,lView)}return context.component}function getContext(element){assertDomElement(element);const context=getLContext(element),lView=context?context.lView:null;return null===lView?null:lView[8]}function getOwningComponent(elementOrDir){const context=getLContext(elementOrDir);let parent,lView=context?context.lView:null;if(null===lView)return null;for(;2===lView[1].type&&(parent=getLViewParent(lView));)lView=parent;return root_effect_scheduler_isRootView(lView)?null:lView[8]}function getRootComponents(elementOrDir){const lView=debug_node_readPatchedLView(elementOrDir);return null!==lView?[getRootContext(lView)]:[]}function getInjector(elementOrDir){const context=getLContext(elementOrDir),lView=context?context.lView:null;if(null===lView)return root_effect_scheduler_Injector.NULL;const tNode=lView[1].data[context.nodeIndex];return new NodeInjector(tNode,lView)}var Framework,AcxChangeDetectionStrategy,AcxViewEncapsulation;function getListeners(element){ngDevMode&&assertDomElement(element);const lContext=getLContext(element),lView=null===lContext?null:lContext.lView;if(null===lView)return[];const tView=lView[1],lCleanup=lView[7],tCleanup=tView.cleanup,listeners=[];if(tCleanup&&lCleanup)for(let i=0;i<tCleanup.length;){const firstParam=tCleanup[i++],secondParam=tCleanup[i++];if("string"==typeof firstParam){const name=firstParam,listenerElement=root_effect_scheduler_unwrapRNode(lView[secondParam]),callback=lCleanup[tCleanup[i++]],useCaptureOrIndx=tCleanup[i++],type="boolean"==typeof useCaptureOrIndx||useCaptureOrIndx>=0?"dom":"output",useCapture="boolean"==typeof useCaptureOrIndx&&useCaptureOrIndx;element==listenerElement&&listeners.push({element,name,callback,useCapture,type})}}return listeners.sort(sortListeners),listeners}function sortListeners(a,b){return a.name==b.name?0:a.name<b.name?-1:1}function assertDomElement(value){if("undefined"!=typeof Element&&!(value instanceof Element))throw new Error("Expecting instance of DOM Element")}function extractInputDebugMetadata(inputs){const res={};for(const key in inputs)if(inputs.hasOwnProperty(key)){const value=inputs[key];void 0!==value&&(res[key]=value[0])}return res}let debug_node_DOCUMENT;function debug_node_getDocument(){if(void 0!==debug_node_DOCUMENT)return debug_node_DOCUMENT;if("undefined"!=typeof document)return document;throw new root_effect_scheduler_RuntimeError(210,("undefined"==typeof ngDevMode||ngDevMode)&&"The document object is not available in this context. Make sure the DOCUMENT injection token is provided.")}!function(Framework){Framework.Angular="angular",Framework.ACX="acx",Framework.Wiz="wiz"}(Framework||(Framework={})),function(AcxChangeDetectionStrategy){AcxChangeDetectionStrategy[AcxChangeDetectionStrategy.Default=0]="Default",AcxChangeDetectionStrategy[AcxChangeDetectionStrategy.OnPush=1]="OnPush"}(AcxChangeDetectionStrategy||(AcxChangeDetectionStrategy={})),function(AcxViewEncapsulation){AcxViewEncapsulation[AcxViewEncapsulation.Emulated=0]="Emulated",AcxViewEncapsulation[AcxViewEncapsulation.None=1]="None"}(AcxViewEncapsulation||(AcxViewEncapsulation={}));const debug_node_APP_ID=new InjectionToken(ngDevMode?"AppId":"",{providedIn:"root",factory:()=>DEFAULT_APP_ID}),DEFAULT_APP_ID="ng",debug_node_PLATFORM_INITIALIZER=new InjectionToken(ngDevMode?"Platform Initializer":""),IMAGE_CONFIG_DEFAULTS=(new InjectionToken(ngDevMode?"Platform ID":"",{providedIn:"platform",factory:()=>"unknown"}),new InjectionToken(ngDevMode?"Application Packages Root URL":""),new InjectionToken(ngDevMode?"AnimationModuleType":""),new InjectionToken(ngDevMode?"CSP nonce":"",{providedIn:"root",factory:()=>debug_node_getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null}),{breakpoints:[16,32,48,64,96,128,256,384,640,750,828,1080,1200,1920,2048,3840],placeholderResolution:30,disableImageSizeWarning:!1,disableImageLazyLoadWarning:!1}),IMAGE_CONFIG=new InjectionToken(ngDevMode?"ImageConfig":"",{providedIn:"root",factory:()=>IMAGE_CONFIG_DEFAULTS});function initTransferState(){const transferState=new debug_node_TransferState;return"undefined"!=typeof ngServerMode&&ngServerMode||(transferState.store=retrieveTransferredState(debug_node_getDocument(),root_effect_scheduler_inject(debug_node_APP_ID))),transferState}class debug_node_TransferState{static ɵprov=ɵɵdefineInjectable({token:debug_node_TransferState,providedIn:"root",factory:initTransferState});store={};onSerializeCallbacks={};get(key,defaultValue){return void 0!==this.store[key]?this.store[key]:defaultValue}set(key,value){this.store[key]=value}remove(key){delete this.store[key]}hasKey(key){return this.store.hasOwnProperty(key)}get isEmpty(){return 0===Object.keys(this.store).length}onSerialize(key,callback){this.onSerializeCallbacks[key]=callback}toJson(){for(const key in this.onSerializeCallbacks)if(this.onSerializeCallbacks.hasOwnProperty(key))try{this.store[key]=this.onSerializeCallbacks[key]()}catch(e){console.warn("Exception in onSerialize callback: ",e)}return JSON.stringify(this.store).replace(/</g,"\\u003C")}}function retrieveTransferredState(doc,appId){const script=doc.getElementById(appId+"-state");if(script?.textContent)try{return JSON.parse(script.textContent)}catch(e){console.warn("Exception while restoring TransferState for app "+appId,e)}return{}}new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_HYDRATION_DOM_REUSE_ENABLED":"");const debug_node_PRESERVE_HOST_CONTENT=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"PRESERVE_HOST_CONTENT":"",{providedIn:"root",factory:()=>false}),debug_node_IS_INCREMENTAL_HYDRATION_ENABLED=(new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_I18N_HYDRATION_ENABLED":""),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_EVENT_REPLAY_ENABLED":""),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_INCREMENTAL_HYDRATION_ENABLED":"")),eventListenerOptions=(new InjectionToken(ngDevMode?"JSACTION_BLOCK_ELEMENT_MAP":"",{providedIn:"root",factory:()=>new Map}),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_ENABLED_BLOCKING_INITIAL_NAVIGATION":""),{passive:!0,capture:!0}),hoverTriggers=new WeakMap,interactionTriggers=new WeakMap,viewportTriggers=new WeakMap,interactionEventNames=["click","keydown"],hoverEventNames=["mouseenter","mouseover","focusin"];let intersectionObserver=null,observedViewportElements=0;class DeferEventEntry{callbacks=new Set;listener=()=>{for(const callback of this.callbacks)callback()}}function onInteraction(trigger,callback){let entry=interactionTriggers.get(trigger);if(!entry){entry=new DeferEventEntry,interactionTriggers.set(trigger,entry);for(const name of interactionEventNames)trigger.addEventListener(name,entry.listener,eventListenerOptions)}return entry.callbacks.add(callback),()=>{const{callbacks,listener}=entry;if(callbacks.delete(callback),0===callbacks.size){interactionTriggers.delete(trigger);for(const name of interactionEventNames)trigger.removeEventListener(name,listener,eventListenerOptions)}}}function onHover(trigger,callback){let entry=hoverTriggers.get(trigger);if(!entry){entry=new DeferEventEntry,hoverTriggers.set(trigger,entry);for(const name of hoverEventNames)trigger.addEventListener(name,entry.listener,eventListenerOptions)}return entry.callbacks.add(callback),()=>{const{callbacks,listener}=entry;if(callbacks.delete(callback),0===callbacks.size){for(const name of hoverEventNames)trigger.removeEventListener(name,listener,eventListenerOptions);hoverTriggers.delete(trigger)}}}new InjectionToken(ngDevMode?"EVENT_CONTRACT_DETAILS":"",{providedIn:"root",factory:()=>({})});new Map;let _stashEventListenerImpl=(lView,target,eventName,wrappedListener)=>{};const debug_node_DEHYDRATED_BLOCK_REGISTRY=new InjectionToken(ngDevMode?"DEHYDRATED_BLOCK_REGISTRY":"");function debug_node_isDetachedByI18n(tNode){return!(32&~tNode.flags)}function isInternalHydrationTransferStateKey(key){return"__nghData__"===key||"__nghDeferData__"===key}let _retrieveHydrationInfoImpl=()=>null;function retrieveHydrationInfo(rNode,injector,isRootView=!1){return _retrieveHydrationInfoImpl(rNode,injector,isRootView)}function debug_node_getLNodeForHydration(viewRef){let lView=viewRef._lView;return 2===lView[1].type?null:(root_effect_scheduler_isRootView(lView)&&(lView=lView[27]),lView)}var HydrationStatus;!function(HydrationStatus){HydrationStatus.Hydrated="hydrated",HydrationStatus.Skipped="skipped",HydrationStatus.Mismatched="mismatched"}(HydrationStatus||(HydrationStatus={}));const HYDRATION_INFO_KEY="__ngDebugHydrationInfo__";function patchHydrationInfo(node,info){node[HYDRATION_INFO_KEY]=info}function markRNodeAsHavingHydrationMismatch(node,expectedNodeDetails=null,actualNodeDetails=null){if(!ngDevMode)throw new Error("Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.");for(;node&&!getComponent(node);)node=node?.parentNode;node&&patchHydrationInfo(node,{status:HydrationStatus.Mismatched,expectedNodeDetails,actualNodeDetails})}function debug_node_isIncrementalHydrationEnabled(injector){return injector.get(debug_node_IS_INCREMENTAL_HYDRATION_ENABLED,!1,{optional:!0})}let incrementalHydrationEnabledWarned=!1;function assertSsrIdDefined(ssrUniqueId){root_effect_scheduler_assertDefined(ssrUniqueId,"Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present")}function refreshContentQueries(tView,lView){const contentQueries=tView.contentQueries;if(null!==contentQueries){const prevConsumer=setActiveConsumer(null);try{for(let i=0;i<contentQueries.length;i+=2){const queryStartIdx=contentQueries[i],directiveDefIdx=contentQueries[i+1];if(-1!==directiveDefIdx){const directiveDef=tView.data[directiveDefIdx];ngDevMode&&root_effect_scheduler_assertDefined(directiveDef,"DirectiveDef not found."),ngDevMode&&root_effect_scheduler_assertDefined(directiveDef.contentQueries,"contentQueries function should be defined"),setCurrentQueryIndex(queryStartIdx),directiveDef.contentQueries(2,lView[directiveDefIdx],directiveDefIdx)}}}finally{setActiveConsumer(prevConsumer)}}}function executeViewQueryFn(flags,viewQueryFn,component){ngDevMode&&root_effect_scheduler_assertDefined(viewQueryFn,"View queries function to execute must be defined."),setCurrentQueryIndex(0);const prevConsumer=setActiveConsumer(null);try{viewQueryFn(flags,component)}finally{setActiveConsumer(prevConsumer)}}function executeContentQueries(tView,tNode,lView){if(isContentQueryHost(tNode)){const prevConsumer=setActiveConsumer(null);try{const start=tNode.directiveStart,end=tNode.directiveEnd;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const def=tView.data[directiveIndex];if(def.contentQueries){const directiveInstance=lView[directiveIndex];ngDevMode&&root_effect_scheduler_assertDefined(directiveIndex,"Incorrect reference to a directive defining a content query"),def.contentQueries(1,directiveInstance,directiveIndex)}}}finally{setActiveConsumer(prevConsumer)}}}var ViewEncapsulation;let policy$1,policy;function getPolicy$1(){if(void 0===policy$1&&(policy$1=null,root_effect_scheduler_global.trustedTypes))try{policy$1=root_effect_scheduler_global.trustedTypes.createPolicy("angular",{createHTML:s=>s,createScript:s=>s,createScriptURL:s=>s})}catch{}return policy$1}function trustedHTMLFromString(html){return getPolicy$1()?.createHTML(html)||html}function getPolicy(){if(void 0===policy&&(policy=null,root_effect_scheduler_global.trustedTypes))try{policy=root_effect_scheduler_global.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:s=>s,createScript:s=>s,createScriptURL:s=>s})}catch{}return policy}function trustedHTMLFromStringBypass(html){return getPolicy()?.createHTML(html)||html}function trustedScriptFromStringBypass(script){return getPolicy()?.createScript(script)||script}function trustedScriptURLFromStringBypass(url){return getPolicy()?.createScriptURL(url)||url}!function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation||(ViewEncapsulation={}));class SafeValueImpl{changingThisBreaksApplicationSecurity;constructor(changingThisBreaksApplicationSecurity){this.changingThisBreaksApplicationSecurity=changingThisBreaksApplicationSecurity}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`}}function unwrapSafeValue(value){return value instanceof SafeValueImpl?value.changingThisBreaksApplicationSecurity:value}function allowSanitizationBypassAndThrow(value,type){const actualType=function getSanitizationBypassType(value){return value instanceof SafeValueImpl&&value.getTypeName()||null}(value);if(null!=actualType&&actualType!==type){if("ResourceURL"===actualType&&"URL"===type)return!0;throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`)}return actualType===type}function getInertBodyHelper(defaultDoc){const inertDocumentHelper=new InertDocumentHelper(defaultDoc);return function isDOMParserAvailable(){try{return!!(new window.DOMParser).parseFromString(trustedHTMLFromString(""),"text/html")}catch{return!1}}()?new DOMParserHelper(inertDocumentHelper):inertDocumentHelper}class DOMParserHelper{inertDocumentHelper;constructor(inertDocumentHelper){this.inertDocumentHelper=inertDocumentHelper}getInertBodyElement(html){html="<body><remove></remove>"+html;try{const body=(new window.DOMParser).parseFromString(trustedHTMLFromString(html),"text/html").body;return null===body?this.inertDocumentHelper.getInertBodyElement(html):(body.firstChild?.remove(),body)}catch{return null}}}class InertDocumentHelper{defaultDoc;inertDocument;constructor(defaultDoc){this.defaultDoc=defaultDoc,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert")}getInertBodyElement(html){const templateEl=this.inertDocument.createElement("template");return templateEl.innerHTML=trustedHTMLFromString(html),templateEl}}const SAFE_URL_PATTERN=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function _sanitizeUrl(url){return(url=String(url)).match(SAFE_URL_PATTERN)?url:(("undefined"==typeof ngDevMode||ngDevMode)&&console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`),"unsafe:"+url)}function tagSet(tags){const res={};for(const t of tags.split(","))res[t]=!0;return res}function merge(...sets){const res={};for(const s of sets)for(const v in s)s.hasOwnProperty(v)&&(res[v]=!0);return res}const VOID_ELEMENTS=tagSet("area,br,col,hr,img,wbr"),OPTIONAL_END_TAG_BLOCK_ELEMENTS=tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),OPTIONAL_END_TAG_INLINE_ELEMENTS=tagSet("rp,rt"),OPTIONAL_END_TAG_ELEMENTS=merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,OPTIONAL_END_TAG_BLOCK_ELEMENTS),BLOCK_ELEMENTS=merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS,tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),INLINE_ELEMENTS=merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),VALID_ELEMENTS=merge(VOID_ELEMENTS,BLOCK_ELEMENTS,INLINE_ELEMENTS,OPTIONAL_END_TAG_ELEMENTS),URI_ATTRS=tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),HTML_ATTRS=tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),ARIA_ATTRS=tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"),VALID_ATTRS=merge(URI_ATTRS,HTML_ATTRS,ARIA_ATTRS),SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS=tagSet("script,style,template");class SanitizingHtmlSerializer{sanitizedSomething=!1;buf=[];sanitizeChildren(el){let current=el.firstChild,traverseContent=!0,parentNodes=[];for(;current;)if(current.nodeType===Node.ELEMENT_NODE?traverseContent=this.startElement(current):current.nodeType===Node.TEXT_NODE?this.chars(current.nodeValue):this.sanitizedSomething=!0,traverseContent&&current.firstChild)parentNodes.push(current),current=getFirstChild(current);else for(;current;){current.nodeType===Node.ELEMENT_NODE&&this.endElement(current);let next=getNextSibling(current);if(next){current=next;break}current=parentNodes.pop()}return this.buf.join("")}startElement(element){const tagName=getNodeName(element).toLowerCase();if(!VALID_ELEMENTS.hasOwnProperty(tagName))return this.sanitizedSomething=!0,!SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);this.buf.push("<"),this.buf.push(tagName);const elAttrs=element.attributes;for(let i=0;i<elAttrs.length;i++){const elAttr=elAttrs.item(i),attrName=elAttr.name,lower=attrName.toLowerCase();if(!VALID_ATTRS.hasOwnProperty(lower)){this.sanitizedSomething=!0;continue}let value=elAttr.value;URI_ATTRS[lower]&&(value=_sanitizeUrl(value)),this.buf.push(" ",attrName,'="',encodeEntities(value),'"')}return this.buf.push(">"),!0}endElement(current){const tagName=getNodeName(current).toLowerCase();VALID_ELEMENTS.hasOwnProperty(tagName)&&!VOID_ELEMENTS.hasOwnProperty(tagName)&&(this.buf.push("</"),this.buf.push(tagName),this.buf.push(">"))}chars(chars){this.buf.push(encodeEntities(chars))}}function getNextSibling(node){const nextSibling=node.nextSibling;if(nextSibling&&node!==nextSibling.previousSibling)throw clobberedElementError(nextSibling);return nextSibling}function getFirstChild(node){const firstChild=node.firstChild;if(firstChild&&function isClobberedElement(parentNode,childNode){return(parentNode.compareDocumentPosition(childNode)&Node.DOCUMENT_POSITION_CONTAINED_BY)!==Node.DOCUMENT_POSITION_CONTAINED_BY}(node,firstChild))throw clobberedElementError(firstChild);return firstChild}function getNodeName(node){const nodeName=node.nodeName;return"string"==typeof nodeName?nodeName:"FORM"}function clobberedElementError(node){return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`)}const SURROGATE_PAIR_REGEXP=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,NON_ALPHANUMERIC_REGEXP=/([^\#-~ |!])/g;function encodeEntities(value){return value.replace(/&/g,"&amp;").replace(SURROGATE_PAIR_REGEXP,function(match){return"&#"+(1024*(match.charCodeAt(0)-55296)+(match.charCodeAt(1)-56320)+65536)+";"}).replace(NON_ALPHANUMERIC_REGEXP,function(match){return"&#"+match.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let inertBodyHelper;function getTemplateContent(el){return"content"in el&&function isTemplateElement(el){return el.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===el.nodeName}(el)?el.content:null}var SecurityContext;function ɵɵsanitizeHtml(unsafeHtml){const sanitizer=getSanitizer();return sanitizer?trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML,unsafeHtml)||""):allowSanitizationBypassAndThrow(unsafeHtml,"HTML")?trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml)):function _sanitizeHtml(defaultDoc,unsafeHtmlInput){let inertBodyElement=null;try{inertBodyHelper=inertBodyHelper||getInertBodyHelper(defaultDoc);let unsafeHtml=unsafeHtmlInput?String(unsafeHtmlInput):"";inertBodyElement=inertBodyHelper.getInertBodyElement(unsafeHtml);let mXSSAttempts=5,parsedHtml=unsafeHtml;do{if(0===mXSSAttempts)throw new Error("Failed to sanitize html because the input is unstable");mXSSAttempts--,unsafeHtml=parsedHtml,parsedHtml=inertBodyElement.innerHTML,inertBodyElement=inertBodyHelper.getInertBodyElement(unsafeHtml)}while(unsafeHtml!==parsedHtml);const sanitizer=new SanitizingHtmlSerializer,safeHtml=sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement)||inertBodyElement);return("undefined"==typeof ngDevMode||ngDevMode)&&sanitizer.sanitizedSomething&&console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`),trustedHTMLFromString(safeHtml)}finally{if(inertBodyElement){const parent=getTemplateContent(inertBodyElement)||inertBodyElement;for(;parent.firstChild;)parent.firstChild.remove()}}}(debug_node_getDocument(),root_effect_scheduler_renderStringify(unsafeHtml))}function ɵɵsanitizeStyle(unsafeStyle){const sanitizer=getSanitizer();return sanitizer?sanitizer.sanitize(SecurityContext.STYLE,unsafeStyle)||"":allowSanitizationBypassAndThrow(unsafeStyle,"Style")?unwrapSafeValue(unsafeStyle):root_effect_scheduler_renderStringify(unsafeStyle)}function ɵɵsanitizeUrl(unsafeUrl){const sanitizer=getSanitizer();return sanitizer?sanitizer.sanitize(SecurityContext.URL,unsafeUrl)||"":allowSanitizationBypassAndThrow(unsafeUrl,"URL")?unwrapSafeValue(unsafeUrl):_sanitizeUrl(root_effect_scheduler_renderStringify(unsafeUrl))}function ɵɵsanitizeResourceUrl(unsafeResourceUrl){const sanitizer=getSanitizer();if(sanitizer)return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL,unsafeResourceUrl)||"");if(allowSanitizationBypassAndThrow(unsafeResourceUrl,"ResourceURL"))return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));throw new root_effect_scheduler_RuntimeError(904,ngDevMode&&`unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`)}function ɵɵsanitizeScript(unsafeScript){const sanitizer=getSanitizer();if(sanitizer)return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT,unsafeScript)||"");if(allowSanitizationBypassAndThrow(unsafeScript,"Script"))return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));throw new root_effect_scheduler_RuntimeError(905,ngDevMode&&"unsafe value used in a script context")}function ɵɵtrustConstantHtml(html){if(ngDevMode&&(!Array.isArray(html)||!Array.isArray(html.raw)||1!==html.length))throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);return trustedHTMLFromString(html[0])}function ɵɵtrustConstantResourceUrl(url){if(ngDevMode&&(!Array.isArray(url)||!Array.isArray(url.raw)||1!==url.length))throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);return function trustedScriptURLFromString(url){return getPolicy$1()?.createScriptURL(url)||url}(url[0])}function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl,tag,prop){return function getUrlSanitizer(tag,prop){return"src"===prop&&("embed"===tag||"frame"===tag||"iframe"===tag||"media"===tag||"script"===tag)||"href"===prop&&("base"===tag||"link"===tag)?ɵɵsanitizeResourceUrl:ɵɵsanitizeUrl}(tag,prop)(unsafeUrl)}function getSanitizer(){const lView=root_effect_scheduler_getLView();return lView&&lView[10].sanitizer}!function(SecurityContext){SecurityContext[SecurityContext.NONE=0]="NONE",SecurityContext[SecurityContext.HTML=1]="HTML",SecurityContext[SecurityContext.STYLE=2]="STYLE",SecurityContext[SecurityContext.SCRIPT=3]="SCRIPT",SecurityContext[SecurityContext.URL=4]="URL",SecurityContext[SecurityContext.RESOURCE_URL=5]="RESOURCE_URL"}(SecurityContext||(SecurityContext={}));const COMMENT_DISALLOWED=/^>|^->|<!--|-->|--!>|<!-$/g,COMMENT_DELIMITER=/(<|>)/g;function escapeCommentText(value){return value.replace(COMMENT_DISALLOWED,text=>text.replace(COMMENT_DELIMITER,"​$1​"))}const NG_REFLECT_ATTRS_FLAG=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"NG_REFLECT_FLAG":"",{providedIn:"root",factory:()=>false});function normalizeDebugBindingName(name){return name=function camelCaseToDashCase(input){return input.replace(CAMEL_CASE_REGEXP,(...m)=>"-"+m[1].toLowerCase())}(name.replace(/[$@]/g,"_")),`ng-reflect-${name}`}const CAMEL_CASE_REGEXP=/([A-Z])/g;const CUSTOM_ELEMENTS_SCHEMA={name:"custom-elements"},NO_ERRORS_SCHEMA={name:"no-errors-schema"};let shouldThrowErrorOnUnknownElement=!1;let shouldThrowErrorOnUnknownProperty=!1;function validateElementIsKnown(lView,tNode){const tView=lView[1];if(null===tView.schemas)return;const tagName=tNode.value;if(!isDirectiveHost(tNode)&&null!==tagName){if(("undefined"!=typeof HTMLUnknownElement&&HTMLUnknownElement&&root_effect_scheduler_getNativeByTNode(tNode,lView)instanceof HTMLUnknownElement||"undefined"!=typeof customElements&&tagName.indexOf("-")>-1&&!customElements.get(tagName))&&!matchingSchemas(tView.schemas,tagName)){const isHostStandalone=isHostComponentStandalone(lView),schemas=`'${isHostStandalone?"@Component":"@NgModule"}.schemas'`;let message=`'${tagName}' is not a known element${getTemplateLocationDetails(lView)}:\n`;if(message+=`1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone?"included in the '@Component.imports' of this component":"a part of an @NgModule where this component is declared"}.\n`,tagName&&tagName.indexOf("-")>-1?message+=`2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`:message+=`2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`,shouldThrowErrorOnUnknownElement)throw new root_effect_scheduler_RuntimeError(304,message);console.error(root_effect_scheduler_formatRuntimeError(304,message))}}}function handleUnknownPropertyError(propName,tagName,nodeType,lView){tagName||4!==nodeType||(tagName="ng-template");const isHostStandalone=isHostComponentStandalone(lView);let message=`Can't bind to '${propName}' since it isn't a known property of '${tagName}'${getTemplateLocationDetails(lView)}.`;const schemas=`'${isHostStandalone?"@Component":"@NgModule"}.schemas'`,importLocation=isHostStandalone?"included in the '@Component.imports' of this component":"a part of an @NgModule where this component is declared";if(KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)){message+=`\nIf the '${propName}' is an Angular control flow directive, please make sure that either the '${KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName)}' directive or the 'CommonModule' is ${importLocation}.`}else message+=`\n1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`,tagName&&tagName.indexOf("-")>-1?(message+=`\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`,message+=`\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`):message+=`\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;reportUnknownPropertyError(message)}function reportUnknownPropertyError(message){if(shouldThrowErrorOnUnknownProperty)throw new root_effect_scheduler_RuntimeError(303,message);console.error(root_effect_scheduler_formatRuntimeError(303,message))}function getDeclarationComponentDef(lView){!ngDevMode&&throwError("Must never be called in production mode");const context=lView[15][8];return context&&context.constructor?root_effect_scheduler_getComponentDef(context.constructor):null}function isHostComponentStandalone(lView){!ngDevMode&&throwError("Must never be called in production mode");const componentDef=getDeclarationComponentDef(lView);return!!componentDef?.standalone}function getTemplateLocationDetails(lView){!ngDevMode&&throwError("Must never be called in production mode");const hostComponentDef=getDeclarationComponentDef(lView),componentClassName=hostComponentDef?.type?.name;return componentClassName?` (used in the '${componentClassName}' component template)`:""}const KNOWN_CONTROL_FLOW_DIRECTIVES=new Map([["ngIf","NgIf"],["ngFor","NgFor"],["ngSwitchCase","NgSwitchCase"],["ngSwitchDefault","NgSwitchDefault"]]);function matchingSchemas(schemas,tagName){if(null!==schemas)for(let i=0;i<schemas.length;i++){const schema=schemas[i];if(schema===NO_ERRORS_SCHEMA||schema===CUSTOM_ELEMENTS_SCHEMA&&tagName&&tagName.indexOf("-")>-1)return!0}return!1}function ɵɵresolveWindow(element){return element.ownerDocument.defaultView}function ɵɵresolveDocument(element){return element.ownerDocument}function ɵɵresolveBody(element){return element.ownerDocument.body}function maybeUnwrapFn(value){return value instanceof Function?value():value}function debug_node_assertComponentDef(type){if(!root_effect_scheduler_getComponentDef(type))throw new root_effect_scheduler_RuntimeError(906,`The ${root_effect_scheduler_stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`)}function throwMultipleComponentError(tNode,first,second){throw new root_effect_scheduler_RuntimeError(-300,`Multiple components match node with tagname ${tNode.value}: ${root_effect_scheduler_stringifyForError(first)} and ${root_effect_scheduler_stringifyForError(second)}`)}function formatValue(value){let strValue=String(value);try{(Array.isArray(value)||"[object Object]"===strValue)&&(strValue=JSON.stringify(value))}catch(error){}return strValue.length>200?strValue.substring(0,200)+"…":strValue}function constructDetailsForInterpolation(lView,rootIndex,expressionIndex,meta,changedValue){const[propName,prefix,...chunks]=meta.split("�");let oldValue=prefix,newValue=prefix;for(let i=0;i<chunks.length;i++){const slotIdx=rootIndex+i;oldValue+=`${lView[slotIdx]}${chunks[i]}`,newValue+=`${slotIdx===expressionIndex?changedValue:lView[slotIdx]}${chunks[i]}`}return{propName,oldValue,newValue}}function classIndexOf(className,classToSearch,startingIndex){ngDevMode&&root_effect_scheduler_assertNotEqual(classToSearch,"",'can not look for "" string.');let end=className.length;for(;;){const foundIndex=className.indexOf(classToSearch,startingIndex);if(-1===foundIndex)return foundIndex;if(0===foundIndex||className.charCodeAt(foundIndex-1)<=32){const length=classToSearch.length;if(foundIndex+length===end||className.charCodeAt(foundIndex+length)<=32)return foundIndex}startingIndex=foundIndex+1}}function isCssClassMatching(tNode,attrs,cssClassToMatch,isProjectionMode){ngDevMode&&root_effect_scheduler_assertEqual(cssClassToMatch,cssClassToMatch.toLowerCase(),"Class name expected to be lowercase.");let i=0;if(isProjectionMode){for(;i<attrs.length&&"string"==typeof attrs[i];i+=2)if("class"===attrs[i]&&-1!==classIndexOf(attrs[i+1].toLowerCase(),cssClassToMatch,0))return!0}else if(isInlineTemplate(tNode))return!1;if(i=attrs.indexOf(1,i),i>-1){let item;for(;++i<attrs.length&&"string"==typeof(item=attrs[i]);)if(item.toLowerCase()===cssClassToMatch)return!0}return!1}function isInlineTemplate(tNode){return 4===tNode.type&&"ng-template"!==tNode.value}function hasTagAndTypeMatch(tNode,currentSelector,isProjectionMode){return currentSelector===(4!==tNode.type||isProjectionMode?tNode.value:"ng-template")}function isNodeMatchingSelector(tNode,selector,isProjectionMode){ngDevMode&&root_effect_scheduler_assertDefined(selector[0],"Selector should have a tag name");let mode=4;const nodeAttrs=tNode.attrs,nameOnlyMarkerIdx=null!==nodeAttrs?function getNameOnlyMarkerIndex(nodeAttrs){for(let i=0;i<nodeAttrs.length;i++){if(isNameOnlyAttributeMarker(nodeAttrs[i]))return i}return nodeAttrs.length}(nodeAttrs):0;let skipToNextSelector=!1;for(let i=0;i<selector.length;i++){const current=selector[i];if("number"!=typeof current){if(!skipToNextSelector)if(4&mode){if(mode=2|1&mode,""!==current&&!hasTagAndTypeMatch(tNode,current,isProjectionMode)||""===current&&1===selector.length){if(isPositive(mode))return!1;skipToNextSelector=!0}}else if(8&mode){if(null===nodeAttrs||!isCssClassMatching(tNode,nodeAttrs,current,isProjectionMode)){if(isPositive(mode))return!1;skipToNextSelector=!0}}else{const selectorAttrValue=selector[++i],attrIndexInNode=findAttrIndexInNode(current,nodeAttrs,isInlineTemplate(tNode),isProjectionMode);if(-1===attrIndexInNode){if(isPositive(mode))return!1;skipToNextSelector=!0;continue}if(""!==selectorAttrValue){let nodeAttrValue;if(attrIndexInNode>nameOnlyMarkerIdx?nodeAttrValue="":(ngDevMode&&root_effect_scheduler_assertNotEqual(nodeAttrs[attrIndexInNode],0,"We do not match directives on namespaced attributes"),nodeAttrValue=nodeAttrs[attrIndexInNode+1].toLowerCase()),2&mode&&selectorAttrValue!==nodeAttrValue){if(isPositive(mode))return!1;skipToNextSelector=!0}}}}else{if(!skipToNextSelector&&!isPositive(mode)&&!isPositive(current))return!1;if(skipToNextSelector&&isPositive(current))continue;skipToNextSelector=!1,mode=current|1&mode}}return isPositive(mode)||skipToNextSelector}function isPositive(mode){return!(1&mode)}function findAttrIndexInNode(name,attrs,isInlineTemplate,isProjectionMode){if(null===attrs)return-1;let i=0;if(isProjectionMode||!isInlineTemplate){let bindingsMode=!1;for(;i<attrs.length;){const maybeAttrName=attrs[i];if(maybeAttrName===name)return i;if(3===maybeAttrName||6===maybeAttrName)bindingsMode=!0;else{if(1===maybeAttrName||2===maybeAttrName){let value=attrs[++i];for(;"string"==typeof value;)value=attrs[++i];continue}if(4===maybeAttrName)break;if(0===maybeAttrName){i+=4;continue}}i+=bindingsMode?1:2}return-1}return function matchTemplateAttribute(attrs,name){let i=attrs.indexOf(4);if(i>-1)for(i++;i<attrs.length;){const attr=attrs[i];if("number"==typeof attr)return-1;if(attr===name)return i;i++}return-1}(attrs,name)}function isNodeMatchingSelectorList(tNode,selector,isProjectionMode=!1){for(let i=0;i<selector.length;i++)if(isNodeMatchingSelector(tNode,selector[i],isProjectionMode))return!0;return!1}function isSelectorInSelectorList(selector,list){selectorListLoop:for(let i=0;i<list.length;i++){const currentSelectorInList=list[i];if(selector.length===currentSelectorInList.length){for(let j=0;j<selector.length;j++)if(selector[j]!==currentSelectorInList[j])continue selectorListLoop;return!0}}return!1}function maybeWrapInNotSelector(isNegativeMode,chunk){return isNegativeMode?":not("+chunk.trim()+")":chunk}function stringifyCSSSelector(selector){let result=selector[0],i=1,mode=2,currentChunk="",isNegativeMode=!1;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)if(2&mode){const attrValue=selector[++i];currentChunk+="["+valueOrMarker+(attrValue.length>0?'="'+attrValue+'"':"")+"]"}else 8&mode?currentChunk+="."+valueOrMarker:4&mode&&(currentChunk+=" "+valueOrMarker);else""===currentChunk||isPositive(valueOrMarker)||(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk),currentChunk=""),mode=valueOrMarker,isNegativeMode=isNegativeMode||!isPositive(mode);i++}return""!==currentChunk&&(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk)),result}function stringifyCSSSelectorList(selectorList){return selectorList.map(stringifyCSSSelector).join(",")}const NO_CHANGE="undefined"==typeof ngDevMode||ngDevMode?{__brand__:"NO_CHANGE"}:{};function createTextNode(renderer,value){return renderer.createText(value)}function updateTextNode(renderer,rNode,value){renderer.setValue(rNode,value)}function createCommentNode(renderer,value){return renderer.createComment(escapeCommentText(value))}function createElementNode(renderer,name,namespace){return renderer.createElement(name,namespace)}function nativeInsertBefore(renderer,parent,child,beforeNode,isMove){renderer.insertBefore(parent,child,beforeNode,isMove)}function nativeAppendChild(renderer,parent,child){ngDevMode&&root_effect_scheduler_assertDefined(parent,"parent node must be defined"),renderer.appendChild(parent,child)}function nativeAppendOrInsertBefore(renderer,parent,child,beforeNode,isMove){null!==beforeNode?nativeInsertBefore(renderer,parent,child,beforeNode,isMove):nativeAppendChild(renderer,parent,child)}function nativeRemoveNode(renderer,rNode,isHostElement,requireSynchronousElementRemoval){renderer.removeChild(null,rNode,isHostElement,requireSynchronousElementRemoval)}function setupStaticAttributes(renderer,element,tNode){const{mergedAttrs,classes,styles}=tNode;null!==mergedAttrs&&function setUpAttributes(renderer,native,attrs){let i=0;for(;i<attrs.length;){const value=attrs[i];if("number"==typeof value){if(0!==value)break;i++;const namespaceURI=attrs[i++],attrName=attrs[i++],attrVal=attrs[i++];renderer.setAttribute(native,attrName,attrVal,namespaceURI)}else{const attrName=value,attrVal=attrs[++i];isAnimationProp(attrName)?renderer.setProperty(native,attrName,attrVal):renderer.setAttribute(native,attrName,attrVal),i++}}return i}(renderer,element,mergedAttrs),null!==classes&&function writeDirectClass(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),""===newValue?renderer.removeAttribute(element,"class"):renderer.setAttribute(element,"class",newValue)}(renderer,element,classes),null!==styles&&function writeDirectStyle(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),renderer.setAttribute(element,"style",newValue)}(renderer,element,styles)}function createTView(type,declTNode,templateFn,decls,vars,directives,pipes,viewQuery,schemas,constsOrFactory,ssrId){const bindingStartIndex=27+decls,initialViewLength=bindingStartIndex+vars,blueprint=function createViewBlueprint(bindingStartIndex,initialViewLength){const blueprint=[];for(let i=0;i<initialViewLength;i++)blueprint.push(i<bindingStartIndex?null:NO_CHANGE);return blueprint}(bindingStartIndex,initialViewLength),consts="function"==typeof constsOrFactory?constsOrFactory():constsOrFactory,tView=blueprint[1]={type,blueprint,template:templateFn,queries:null,viewQuery,declTNode,data:blueprint.slice().fill(null,bindingStartIndex),bindingStartIndex,expandoStartIndex:initialViewLength,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof directives?directives():directives,pipeRegistry:"function"==typeof pipes?pipes():pipes,firstChild:null,schemas,consts,incompleteFirstPass:!1,ssrId};return ngDevMode&&Object.seal(tView),tView}function getOrCreateComponentTView(def){const tView=def.tView;if(null===tView||tView.incompleteFirstPass){const declTNode=null;return def.tView=createTView(1,declTNode,def.template,def.decls,def.vars,def.directiveDefs,def.pipeDefs,def.viewQuery,def.schemas,def.consts,def.id)}return tView}function createLView(parentLView,tView,context,flags,host,tHostNode,environment,renderer,injector,embeddedViewInjector,hydrationInfo){const lView=tView.blueprint.slice();return lView[0]=host,lView[2]=1228|flags,(null!==embeddedViewInjector||parentLView&&2048&parentLView[2])&&(lView[2]|=2048),resetPreOrderHookFlags(lView),ngDevMode&&tView.declTNode&&parentLView&&assertTNodeForLView(tView.declTNode,parentLView),lView[3]=lView[14]=parentLView,lView[8]=context,lView[10]=environment||parentLView&&parentLView[10],ngDevMode&&root_effect_scheduler_assertDefined(lView[10],"LViewEnvironment is required"),lView[11]=renderer||parentLView&&parentLView[11],ngDevMode&&root_effect_scheduler_assertDefined(lView[11],"Renderer is required"),lView[9]=injector||parentLView&&parentLView[9]||null,lView[5]=tHostNode,lView[19]=function getUniqueLViewId(){return uniqueIdCounter++}(),lView[6]=hydrationInfo,lView[20]=embeddedViewInjector,ngDevMode&&root_effect_scheduler_assertEqual(2!=tView.type||null!==parentLView,!0,"Embedded views must have parentLView"),lView[15]=2==tView.type?parentLView[15]:lView,lView}function getInitialLViewFlagsFromDef(def){let flags=16;return def.signals?flags=4096:def.onPush&&(flags=64),flags}function allocExpando(tView,lView,numSlotsToAlloc,initialValue){if(0===numSlotsToAlloc)return-1;ngDevMode&&(assertFirstCreatePass(tView),assertSame(tView,lView[1],"`LView` must be associated with `TView`!"),root_effect_scheduler_assertEqual(tView.data.length,lView.length,"Expecting LView to be same size as TView"),root_effect_scheduler_assertEqual(tView.data.length,tView.blueprint.length,"Expecting Blueprint to be same size as TView"),assertFirstUpdatePass(tView));const allocIdx=lView.length;for(let i=0;i<numSlotsToAlloc;i++)lView.push(initialValue),tView.blueprint.push(initialValue),tView.data.push(null);return allocIdx}function addToEndOfViewTree(lView,lViewOrLContainer){return lView[12]?lView[13][4]=lViewOrLContainer:lView[12]=lViewOrLContainer,lView[13]=lViewOrLContainer,lViewOrLContainer}function ɵɵadvance(delta=1){ngDevMode&&assertGreaterThan(delta,0,"Can only advance forward"),selectIndexInternal(getTView(),root_effect_scheduler_getLView(),getSelectedIndex()+delta,!!ngDevMode&&isInCheckNoChangesMode())}function selectIndexInternal(tView,lView,index,checkNoChangesMode){if(ngDevMode&&assertIndexInDeclRange(lView[1],index),!checkNoChangesMode){if(!(3&~lView[2])){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,index)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,index)}}setSelectedIndex(index)}var InputFlags,RendererStyleFlags2;function writeToDirectiveInput(def,instance,publicName,value){const prevConsumer=setActiveConsumer(null);try{if(ngDevMode){if(!def.inputs.hasOwnProperty(publicName))throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of "${publicName}"`);if(instance instanceof NodeInjectorFactory)throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`)}const[privateName,flags,transform]=def.inputs[publicName];let inputSignalNode=null;if(0!==(flags&InputFlags.SignalBased)){inputSignalNode=instance[privateName][SIGNAL]}null!==inputSignalNode&&void 0!==inputSignalNode.transformFn?value=inputSignalNode.transformFn(value):null!==transform&&(value=transform.call(instance,value)),null!==def.setInput?def.setInput(instance,inputSignalNode,value,publicName,privateName):applyValueToInputField(instance,inputSignalNode,privateName,value)}finally{setActiveConsumer(prevConsumer)}}let _icuContainerIterate;function icuContainerIterate(tIcuContainerNode,lView){return _icuContainerIterate(tIcuContainerNode,lView)}function parseCssTimeUnitsToMs(value){if(!value)return 0;const multiplier=value.toLowerCase().indexOf("ms")>-1?1:1e3;return parseFloat(value)*multiplier}function parseCssPropertyValue(computedStyle,name){return computedStyle.getPropertyValue(name).split(",").map(part=>part.trim())}function isShorterThanExistingAnimation(existing,longest){return void 0!==existing&&existing.duration>longest.duration}function longestExists(longest){return(null!=longest.animationName||null!=longest.propertyName)&&longest.duration>0}function determineLongestAnimationFromComputedStyles(el,animationsMap){const computedStyle=getComputedStyle(el),longestAnimation=function getLongestComputedAnimation(computedStyle){const rawNames=parseCssPropertyValue(computedStyle,"animation-name"),rawDelays=parseCssPropertyValue(computedStyle,"animation-delay"),rawDurations=parseCssPropertyValue(computedStyle,"animation-duration"),longest={animationName:"",propertyName:void 0,duration:0};for(let i=0;i<rawNames.length;i++){const duration=parseCssTimeUnitsToMs(rawDelays[i])+parseCssTimeUnitsToMs(rawDurations[i]);duration>longest.duration&&(longest.animationName=rawNames[i],longest.duration=duration)}return longest}(computedStyle),longestTransition=function getLongestComputedTransition(computedStyle){const transitionedProperties=parseCssPropertyValue(computedStyle,"transition-property"),rawDurations=parseCssPropertyValue(computedStyle,"transition-duration"),rawDelays=parseCssPropertyValue(computedStyle,"transition-delay"),longest={propertyName:"",duration:0,animationName:void 0};for(let i=0;i<transitionedProperties.length;i++){const duration=parseCssTimeUnitsToMs(rawDelays[i])+parseCssTimeUnitsToMs(rawDurations[i]);duration>longest.duration&&(longest.propertyName=transitionedProperties[i],longest.duration=duration)}return longest}(computedStyle),longest=longestAnimation.duration>longestTransition.duration?longestAnimation:longestTransition;isShorterThanExistingAnimation(animationsMap.get(el),longest)||longestExists(longest)&&animationsMap.set(el,longest)}function determineLongestAnimation(el,animationsMap,areAnimationSupported){if(!areAnimationSupported)return;const animations=el.getAnimations();return 0===animations.length?determineLongestAnimationFromComputedStyles(el,animationsMap):function determineLongestAnimationFromElementAnimations(el,animationsMap,animations){let longest={animationName:void 0,propertyName:void 0,duration:0};for(const animation of animations){const timing=animation.effect?.getTiming(),animDuration="number"==typeof timing?.duration?timing.duration:0;let propertyName,animationName,duration=(timing?.delay??0)+animDuration;animation.animationName?animationName=animation.animationName:propertyName=animation.transitionProperty,duration>=longest.duration&&(longest={animationName,propertyName,duration})}if(isShorterThanExistingAnimation(animationsMap.get(el),longest))return;longestExists(longest)&&animationsMap.set(el,longest)}(el,animationsMap,animations)}!function(InputFlags){InputFlags[InputFlags.None=0]="None",InputFlags[InputFlags.SignalBased=1]="SignalBased",InputFlags[InputFlags.HasDecoratorInputTransform=2]="HasDecoratorInputTransform"}(InputFlags||(InputFlags={})),function(RendererStyleFlags2){RendererStyleFlags2[RendererStyleFlags2.Important=1]="Important",RendererStyleFlags2[RendererStyleFlags2.DashCase=2]="DashCase"}(RendererStyleFlags2||(RendererStyleFlags2={}));const allLeavingAnimations=new Set;var TracingAction;!function(TracingAction){TracingAction[TracingAction.CHANGE_DETECTION=0]="CHANGE_DETECTION",TracingAction[TracingAction.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER"}(TracingAction||(TracingAction={}));const debug_node_TracingService=new InjectionToken(ngDevMode?"TracingService":""),markedFeatures=new Set;function debug_node_performanceMarkFeature(feature){markedFeatures.has(feature)||(markedFeatures.add(feature),performance?.mark?.("mark_feature_usage",{detail:{feature}}))}const SCHEDULE_IN_ROOT_ZONE_DEFAULT=!1;class EventEmitter_ extends Subject.B{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(isAsync=!1){super(),this.__isAsync=isAsync,isInInjectionContext()&&(this.destroyRef=root_effect_scheduler_inject(DestroyRef,{optional:!0})??void 0,this.pendingTasks=root_effect_scheduler_inject(PendingTasksInternal,{optional:!0})??void 0)}emit(value){const prevConsumer=setActiveConsumer(null);try{super.next(value)}finally{setActiveConsumer(prevConsumer)}}subscribe(observerOrNext,error,complete){let nextFn=observerOrNext,errorFn=error||(()=>null),completeFn=complete;if(observerOrNext&&"object"==typeof observerOrNext){const observer=observerOrNext;nextFn=observer.next?.bind(observer),errorFn=observer.error?.bind(observer),completeFn=observer.complete?.bind(observer)}this.__isAsync&&(errorFn=this.wrapInTimeout(errorFn),nextFn&&(nextFn=this.wrapInTimeout(nextFn)),completeFn&&(completeFn=this.wrapInTimeout(completeFn)));const sink=super.subscribe({next:nextFn,error:errorFn,complete:completeFn});return observerOrNext instanceof Subscription.yU&&observerOrNext.add(sink),sink}wrapInTimeout(fn){return value=>{const taskId=this.pendingTasks?.add();setTimeout(()=>{try{fn(value)}finally{void 0!==taskId&&this.pendingTasks?.remove(taskId)}})}}}const EventEmitter=EventEmitter_;function scheduleCallbackWithRafRace(callback){let timeoutId,animationFrameId;function cleanup(){callback=noop;try{void 0!==animationFrameId&&"function"==typeof cancelAnimationFrame&&cancelAnimationFrame(animationFrameId),void 0!==timeoutId&&clearTimeout(timeoutId)}catch{}}return timeoutId=setTimeout(()=>{callback(),cleanup()}),"function"==typeof requestAnimationFrame&&(animationFrameId=requestAnimationFrame(()=>{callback(),cleanup()})),()=>cleanup()}function scheduleCallbackWithMicrotask(callback){return queueMicrotask(()=>callback()),()=>{callback=noop}}class AsyncStackTaggingZoneSpec{createTask;constructor(namePrefix,consoleAsyncStackTaggingImpl=console){this.name="asyncStackTagging for "+namePrefix,this.createTask=consoleAsyncStackTaggingImpl?.createTask??(()=>null)}name;onScheduleTask(delegate,_current,target,task){return task.consoleTask=this.createTask(`Zone - ${task.source||task.type}`),delegate.scheduleTask(target,task)}onInvokeTask(delegate,_currentZone,targetZone,task,applyThis,applyArgs){let ret;return ret=task.consoleTask?task.consoleTask.run(()=>delegate.invokeTask(targetZone,task,applyThis,applyArgs)):delegate.invokeTask(targetZone,task,applyThis,applyArgs),ret}}const isAngularZoneProperty="isAngularZone",angularZoneInstanceIdProperty="isAngularZone_ID";let ngZoneInstanceId=0;class debug_node_NgZone{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new EventEmitter(!1);onMicrotaskEmpty=new EventEmitter(!1);onStable=new EventEmitter(!1);onError=new EventEmitter(!1);constructor(options){const{enableLongStackTrace=!1,shouldCoalesceEventChangeDetection=!1,shouldCoalesceRunChangeDetection=!1,scheduleInRootZone=SCHEDULE_IN_ROOT_ZONE_DEFAULT}=options;if("undefined"==typeof Zone)throw new root_effect_scheduler_RuntimeError(908,ngDevMode&&"In this configuration Angular requires Zone.js");Zone.assertZonePatched();const self=this;self._nesting=0,self._outer=self._inner=Zone.current,ngDevMode&&(self._inner=self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"))),Zone.TaskTrackingZoneSpec&&(self._inner=self._inner.fork(new Zone.TaskTrackingZoneSpec)),enableLongStackTrace&&Zone.longStackTraceZoneSpec&&(self._inner=self._inner.fork(Zone.longStackTraceZoneSpec)),self.shouldCoalesceEventChangeDetection=!shouldCoalesceRunChangeDetection&&shouldCoalesceEventChangeDetection,self.shouldCoalesceRunChangeDetection=shouldCoalesceRunChangeDetection,self.callbackScheduled=!1,self.scheduleInRootZone=scheduleInRootZone,function forkInnerZoneWithAngularBehavior(zone){const delayChangeDetectionForEventsDelegate=()=>{!function delayChangeDetectionForEvents(zone){if(zone.isCheckStableRunning||zone.callbackScheduled)return;function scheduleCheckStable(){scheduleCallbackWithRafRace(()=>{zone.callbackScheduled=!1,updateMicroTaskStatus(zone),zone.isCheckStableRunning=!0,checkStable(zone),zone.isCheckStableRunning=!1})}zone.callbackScheduled=!0,zone.scheduleInRootZone?Zone.root.run(()=>{scheduleCheckStable()}):zone._outer.run(()=>{scheduleCheckStable()});updateMicroTaskStatus(zone)}(zone)},instanceId=ngZoneInstanceId++;zone._inner=zone._inner.fork({name:"angular",properties:{[isAngularZoneProperty]:!0,[angularZoneInstanceIdProperty]:instanceId,["isAngularZone_ID"+instanceId]:!0},onInvokeTask:(delegate,current,target,task,applyThis,applyArgs)=>{if(function shouldBeIgnoredByZone(applyArgs){return hasApplyArgsData(applyArgs,"__ignore_ng_zone__")}(applyArgs))return delegate.invokeTask(target,task,applyThis,applyArgs);try{return onEnter(zone),delegate.invokeTask(target,task,applyThis,applyArgs)}finally{(zone.shouldCoalesceEventChangeDetection&&"eventTask"===task.type||zone.shouldCoalesceRunChangeDetection)&&delayChangeDetectionForEventsDelegate(),onLeave(zone)}},onInvoke:(delegate,current,target,callback,applyThis,applyArgs,source)=>{try{return onEnter(zone),delegate.invoke(target,callback,applyThis,applyArgs,source)}finally{!zone.shouldCoalesceRunChangeDetection||zone.callbackScheduled||function isSchedulerTick(applyArgs){return hasApplyArgsData(applyArgs,"__scheduler_tick__")}(applyArgs)||delayChangeDetectionForEventsDelegate(),onLeave(zone)}},onHasTask:(delegate,current,target,hasTaskState)=>{delegate.hasTask(target,hasTaskState),current===target&&("microTask"==hasTaskState.change?(zone._hasPendingMicrotasks=hasTaskState.microTask,updateMicroTaskStatus(zone),checkStable(zone)):"macroTask"==hasTaskState.change&&(zone.hasPendingMacrotasks=hasTaskState.macroTask))},onHandleError:(delegate,current,target,error)=>(delegate.handleError(target,error),zone.runOutsideAngular(()=>zone.onError.emit(error)),!1)})}(self)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!debug_node_NgZone.isInAngularZone())throw new root_effect_scheduler_RuntimeError(909,ngDevMode&&"Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(debug_node_NgZone.isInAngularZone())throw new root_effect_scheduler_RuntimeError(909,ngDevMode&&"Expected to not be in Angular Zone, but it is!")}run(fn,applyThis,applyArgs){return this._inner.run(fn,applyThis,applyArgs)}runTask(fn,applyThis,applyArgs,name){const zone=this._inner,task=zone.scheduleEventTask("NgZoneEvent: "+name,fn,EMPTY_PAYLOAD,noop,noop);try{return zone.runTask(task,applyThis,applyArgs)}finally{zone.cancelTask(task)}}runGuarded(fn,applyThis,applyArgs){return this._inner.runGuarded(fn,applyThis,applyArgs)}runOutsideAngular(fn){return this._outer.run(fn)}}const EMPTY_PAYLOAD={};function checkStable(zone){if(0==zone._nesting&&!zone.hasPendingMicrotasks&&!zone.isStable)try{zone._nesting++,zone.onMicrotaskEmpty.emit(null)}finally{if(zone._nesting--,!zone.hasPendingMicrotasks)try{zone.runOutsideAngular(()=>zone.onStable.emit(null))}finally{zone.isStable=!0}}}function updateMicroTaskStatus(zone){zone._hasPendingMicrotasks||(zone.shouldCoalesceEventChangeDetection||zone.shouldCoalesceRunChangeDetection)&&!0===zone.callbackScheduled?zone.hasPendingMicrotasks=!0:zone.hasPendingMicrotasks=!1}function onEnter(zone){zone._nesting++,zone.isStable&&(zone.isStable=!1,zone.onUnstable.emit(null))}function onLeave(zone){zone._nesting--,checkStable(zone)}class NoopNgZone{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new EventEmitter;onMicrotaskEmpty=new EventEmitter;onStable=new EventEmitter;onError=new EventEmitter;run(fn,applyThis,applyArgs){return fn.apply(applyThis,applyArgs)}runGuarded(fn,applyThis,applyArgs){return fn.apply(applyThis,applyArgs)}runOutsideAngular(fn){return fn()}runTask(fn,applyThis,applyArgs,name){return fn.apply(applyThis,applyArgs)}}function hasApplyArgsData(applyArgs,key){return!!Array.isArray(applyArgs)&&(1===applyArgs.length&&!0===applyArgs[0]?.data?.[key])}class debug_node_AfterRenderManager{impl=null;execute(){this.impl?.execute()}static ɵprov=ɵɵdefineInjectable({token:debug_node_AfterRenderManager,providedIn:"root",factory:()=>new debug_node_AfterRenderManager})}const AFTER_RENDER_PHASES=(()=>[0,1,2,3])();class debug_node_AfterRenderImpl{ngZone=root_effect_scheduler_inject(debug_node_NgZone);scheduler=root_effect_scheduler_inject(root_effect_scheduler_ChangeDetectionScheduler);errorHandler=root_effect_scheduler_inject(root_effect_scheduler_ErrorHandler,{optional:!0});sequences=new Set;deferredRegistrations=new Set;executing=!1;constructor(){root_effect_scheduler_inject(debug_node_TracingService,{optional:!0})}execute(){const hasSequencesToExecute=this.sequences.size>0;hasSequencesToExecute&&debug_node_profiler(16),this.executing=!0;for(const phase of AFTER_RENDER_PHASES)for(const sequence of this.sequences)if(!sequence.erroredOrDestroyed&&sequence.hooks[phase])try{sequence.pipelinedValue=this.ngZone.runOutsideAngular(()=>this.maybeTrace(()=>(0,sequence.hooks[phase])(sequence.pipelinedValue),sequence.snapshot))}catch(err){sequence.erroredOrDestroyed=!0,this.errorHandler?.handleError(err)}this.executing=!1;for(const sequence of this.sequences)sequence.afterRun(),sequence.once&&(this.sequences.delete(sequence),sequence.destroy());for(const sequence of this.deferredRegistrations)this.sequences.add(sequence);this.deferredRegistrations.size>0&&this.scheduler.notify(7),this.deferredRegistrations.clear(),hasSequencesToExecute&&debug_node_profiler(17)}register(sequence){const{view}=sequence;void 0!==view?((view[25]??=[]).push(sequence),markAncestorsForTraversal(view),view[2]|=8192):this.executing?this.deferredRegistrations.add(sequence):this.addSequence(sequence)}addSequence(sequence){this.sequences.add(sequence),this.scheduler.notify(7)}unregister(sequence){this.executing&&this.sequences.has(sequence)?(sequence.erroredOrDestroyed=!0,sequence.pipelinedValue=void 0,sequence.once=!0):(this.sequences.delete(sequence),this.deferredRegistrations.delete(sequence))}maybeTrace(fn,snapshot){return snapshot?snapshot.run(TracingAction.AFTER_NEXT_RENDER,fn):fn()}static ɵprov=ɵɵdefineInjectable({token:debug_node_AfterRenderImpl,providedIn:"root",factory:()=>new debug_node_AfterRenderImpl})}class AfterRenderSequence{impl;hooks;view;once;snapshot;erroredOrDestroyed=!1;pipelinedValue=void 0;unregisterOnDestroy;constructor(impl,hooks,view,once,destroyRef,snapshot=null){this.impl=impl,this.hooks=hooks,this.view=view,this.once=once,this.snapshot=snapshot,this.unregisterOnDestroy=destroyRef?.onDestroy(()=>this.destroy())}afterRun(){this.erroredOrDestroyed=!1,this.pipelinedValue=void 0,this.snapshot?.dispose(),this.snapshot=null}destroy(){this.impl.unregister(this),this.unregisterOnDestroy?.();const scheduled=this.view?.[25];scheduled&&(this.view[25]=scheduled.filter(s=>s!==this))}}function afterEveryRender(callbackOrSpec,options){ngDevMode&&root_effect_scheduler_assertNotInReactiveContext(afterEveryRender,"Call `afterEveryRender` outside of a reactive context. For example, schedule the render callback inside the component constructor`."),ngDevMode&&!options?.injector&&root_effect_scheduler_assertInInjectionContext(afterEveryRender);const injector=options?.injector??root_effect_scheduler_inject(root_effect_scheduler_Injector);return"undefined"!=typeof ngServerMode&&ngServerMode?debug_node_NOOP_AFTER_RENDER_REF:(debug_node_performanceMarkFeature("NgAfterRender"),afterEveryRenderImpl(callbackOrSpec,injector,options,!1))}function afterNextRender(callbackOrSpec,options){ngDevMode&&!options?.injector&&root_effect_scheduler_assertInInjectionContext(afterNextRender);const injector=options?.injector??root_effect_scheduler_inject(root_effect_scheduler_Injector);return"undefined"!=typeof ngServerMode&&ngServerMode?debug_node_NOOP_AFTER_RENDER_REF:(debug_node_performanceMarkFeature("NgAfterNextRender"),afterEveryRenderImpl(callbackOrSpec,injector,options,!0))}function afterEveryRenderImpl(callbackOrSpec,injector,options,once){const manager=injector.get(debug_node_AfterRenderManager);manager.impl??=injector.get(debug_node_AfterRenderImpl);const tracing=injector.get(debug_node_TracingService,null,{optional:!0}),destroyRef=!0!==options?.manualCleanup?injector.get(DestroyRef):null,viewContext=injector.get(root_effect_scheduler_ViewContext,null,{optional:!0}),sequence=new AfterRenderSequence(manager.impl,function getHooks(callbackOrSpec){return callbackOrSpec instanceof Function?[void 0,void 0,callbackOrSpec,void 0]:[callbackOrSpec.earlyRead,callbackOrSpec.write,callbackOrSpec.mixedReadWrite,callbackOrSpec.read]}(callbackOrSpec),viewContext?.view,once,destroyRef,tracing?.snapshot(null));return manager.impl.register(sequence),sequence}const debug_node_NOOP_AFTER_RENDER_REF={destroy(){}},ANIMATION_QUEUE=new InjectionToken("undefined"!=typeof ngDevMode&&ngDevMode?"AnimationQueue":"",{providedIn:"root",factory:()=>({queue:new Set,isScheduled:!1,scheduler:null})});function addToAnimationQueue(injector,animationFns,animationData){const animationQueue=injector.get(ANIMATION_QUEUE);if(Array.isArray(animationFns))for(const animateFn of animationFns)animationQueue.queue.add(animateFn),animationData?.detachedLeaveAnimationFns?.push(animateFn);else animationQueue.queue.add(animationFns),animationData?.detachedLeaveAnimationFns?.push(animationFns);animationQueue.scheduler&&animationQueue.scheduler(injector)}function scheduleAnimationQueue(injector){const animationQueue=injector.get(ANIMATION_QUEUE);animationQueue.isScheduled||(afterNextRender(()=>{animationQueue.isScheduled=!1;for(let animateFn of animationQueue.queue)animateFn();animationQueue.queue.clear()},{injector}),animationQueue.isScheduled=!0)}function initializeAnimationQueueScheduler(injector){const animationQueue=injector.get(ANIMATION_QUEUE);animationQueue.scheduler=scheduleAnimationQueue,animationQueue.scheduler(injector)}function queueEnterAnimations(injector,enterAnimations){for(const[_,nodeAnimations]of enterAnimations)addToAnimationQueue(injector,nodeAnimations.animateFns)}function maybeQueueEnterAnimation(parentLView,parent,tNode,injector){const enterAnimations=parentLView?.[26]?.enter;null!==parent&&enterAnimations&&enterAnimations.has(tNode.index)&&queueEnterAnimations(injector,enterAnimations)}function applyToElementOrContainer(action,renderer,injector,parent,lNodeToHandle,tNode,beforeNode,parentLView){if(null!=lNodeToHandle){let lContainer,isComponent=!1;root_effect_scheduler_isLContainer(lNodeToHandle)?lContainer=lNodeToHandle:root_effect_scheduler_isLView(lNodeToHandle)&&(isComponent=!0,ngDevMode&&root_effect_scheduler_assertDefined(lNodeToHandle[0],"HOST must be defined for a component LView"),lNodeToHandle=lNodeToHandle[0]);const rNode=root_effect_scheduler_unwrapRNode(lNodeToHandle);0===action&&null!==parent?(maybeQueueEnterAnimation(parentLView,parent,tNode,injector),null==beforeNode?nativeAppendChild(renderer,parent,rNode):nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0)):1===action&&null!==parent?(maybeQueueEnterAnimation(parentLView,parent,tNode,injector),nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0)):2===action?runLeaveAnimationsWithCallback(parentLView,tNode,injector,nodeHasLeaveAnimations=>{nativeRemoveNode(renderer,rNode,isComponent,nodeHasLeaveAnimations)}):3===action&&runLeaveAnimationsWithCallback(parentLView,tNode,injector,()=>{renderer.destroyNode(rNode)}),null!=lContainer&&function applyContainer(renderer,action,injector,lContainer,tNode,parentRElement,beforeNode){ngDevMode&&assertLContainer(lContainer);const anchor=lContainer[7],native=root_effect_scheduler_unwrapRNode(lContainer);anchor!==native&&applyToElementOrContainer(action,renderer,injector,parentRElement,anchor,tNode,beforeNode);for(let i=10;i<lContainer.length;i++){const lView=lContainer[i];applyView(lView[1],lView,renderer,action,parentRElement,anchor)}}(renderer,action,injector,lContainer,tNode,parent,beforeNode)}}function removeViewFromDOM(tView,lView){detachViewFromDOM(tView,lView),lView[0]=null,lView[5]=null}function detachViewFromDOM(tView,lView){lView[10].changeDetectionScheduler?.notify(9),applyView(tView,lView,lView[11],2,null,null)}function detachMovedView(declarationContainer,lView){ngDevMode&&assertLContainer(declarationContainer),ngDevMode&&root_effect_scheduler_assertDefined(declarationContainer[9],"A projected view should belong to a non-empty projected views collection");const movedViews=declarationContainer[9],declarationViewIndex=movedViews.indexOf(lView);movedViews.splice(declarationViewIndex,1)}function destroyLView(tView,lView){if(isDestroyed(lView))return;const renderer=lView[11];renderer.destroyNode&&applyView(tView,lView,renderer,3,null,null),function destroyViewTree(rootView){let lViewOrLContainer=rootView[12];if(!lViewOrLContainer)return cleanUpView(rootView[1],rootView);for(;lViewOrLContainer;){let next=null;if(root_effect_scheduler_isLView(lViewOrLContainer))next=lViewOrLContainer[12];else{ngDevMode&&assertLContainer(lViewOrLContainer);const firstView=lViewOrLContainer[10];firstView&&(next=firstView)}if(!next){for(;lViewOrLContainer&&!lViewOrLContainer[4]&&lViewOrLContainer!==rootView;)root_effect_scheduler_isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[1],lViewOrLContainer),lViewOrLContainer=lViewOrLContainer[3];null===lViewOrLContainer&&(lViewOrLContainer=rootView),root_effect_scheduler_isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[1],lViewOrLContainer),next=lViewOrLContainer&&lViewOrLContainer[4]}lViewOrLContainer=next}}(lView)}function cleanUpView(tView,lView){if(isDestroyed(lView))return;const prevConsumer=setActiveConsumer(null);try{lView[2]&=-129,lView[2]|=256,lView[24]&&consumerDestroy(lView[24]),executeOnDestroys(tView,lView),processCleanups(tView,lView),1===lView[1].type&&lView[11].destroy();const declarationContainer=lView[16];if(null!==declarationContainer&&root_effect_scheduler_isLContainer(lView[3])){declarationContainer!==lView[3]&&detachMovedView(declarationContainer,lView);const lQueries=lView[18];null!==lQueries&&lQueries.detachView(tView)}unregisterLView(lView)}finally{setActiveConsumer(prevConsumer)}}function runLeaveAnimationsWithCallback(lView,tNode,injector,callback){const animations=lView?.[26];if(null==animations||null==animations.leave||!animations.leave.has(tNode.index))return callback(!1);lView&&allLeavingAnimations.add(lView),addToAnimationQueue(injector,()=>{if(animations.leave&&animations.leave.has(tNode.index)){const leaveAnimations=animations.leave.get(tNode.index),runningAnimations=[];if(leaveAnimations){for(let index=0;index<leaveAnimations.animateFns.length;index++){const animationFn=leaveAnimations.animateFns[index],{promise}=animationFn();runningAnimations.push(promise)}animations.detachedLeaveAnimationFns=void 0}animations.running=Promise.allSettled(runningAnimations),function runAfterLeaveAnimations(lView,callback){const runningAnimations=lView[26]?.running;if(runningAnimations)return void runningAnimations.then(()=>{lView[26].running=void 0,allLeavingAnimations.delete(lView),callback(!0)});callback(!1)}(lView,callback)}else lView&&allLeavingAnimations.delete(lView),callback(!1)},animations)}function processCleanups(tView,lView){ngDevMode&&assertNotReactive(processCleanups.name);const tCleanup=tView.cleanup,lCleanup=lView[7];if(null!==tCleanup)for(let i=0;i<tCleanup.length-1;i+=2)if("string"==typeof tCleanup[i]){const targetIdx=tCleanup[i+3];ngDevMode&&root_effect_scheduler_assertNumber(targetIdx,"cleanup target must be a number"),targetIdx>=0?lCleanup[targetIdx]():lCleanup[-targetIdx].unsubscribe(),i+=2}else{const context=lCleanup[tCleanup[i+1]];tCleanup[i].call(context)}null!==lCleanup&&(lView[7]=null);const destroyHooks=lView[21];if(null!==destroyHooks){lView[21]=null;for(let i=0;i<destroyHooks.length;i++){const destroyHooksFn=destroyHooks[i];ngDevMode&&assertFunction(destroyHooksFn,"Expecting destroy hook to be a function."),destroyHooksFn()}}const effects=lView[23];if(null!==effects){lView[23]=null;for(const effect of effects)effect.destroy()}}function executeOnDestroys(tView,lView){let destroyHooks;if(ngDevMode&&assertNotReactive(executeOnDestroys.name),null!=tView&&null!=(destroyHooks=tView.destroyHooks))for(let i=0;i<destroyHooks.length;i+=2){const context=lView[destroyHooks[i]];if(!(context instanceof NodeInjectorFactory)){const toCall=destroyHooks[i+1];if(Array.isArray(toCall))for(let j=0;j<toCall.length;j+=2){const callContext=context[toCall[j]],hook=toCall[j+1];debug_node_profiler(4,callContext,hook);try{hook.call(callContext)}finally{debug_node_profiler(5,callContext,hook)}}else{debug_node_profiler(4,context,toCall);try{toCall.call(context)}finally{debug_node_profiler(5,context,toCall)}}}}}function getParentRElement(tView,tNode,lView){return getClosestRElement(tView,tNode.parent,lView)}function getClosestRElement(tView,tNode,lView){let parentTNode=tNode;for(;null!==parentTNode&&168&parentTNode.type;)parentTNode=(tNode=parentTNode).parent;if(null===parentTNode)return lView[0];if(ngDevMode&&assertTNodeType(parentTNode,7),root_effect_scheduler_isComponentHost(parentTNode)){ngDevMode&&assertTNodeForLView(parentTNode,lView);const{encapsulation}=tView.data[parentTNode.directiveStart+parentTNode.componentOffset];if(encapsulation===ViewEncapsulation.None||encapsulation===ViewEncapsulation.Emulated)return null}return root_effect_scheduler_getNativeByTNode(parentTNode,lView)}function getInsertInFrontOfRNode(parentTNode,currentTNode,lView){return _getInsertInFrontOfRNodeWithI18n(parentTNode,currentTNode,lView)}function getInsertInFrontOfRNodeWithNoI18n(parentTNode,currentTNode,lView){return 40&parentTNode.type?root_effect_scheduler_getNativeByTNode(parentTNode,lView):null}let _processI18nInsertBefore,_getInsertInFrontOfRNodeWithI18n=getInsertInFrontOfRNodeWithNoI18n;function setI18nHandling(getInsertInFrontOfRNodeWithI18n,processI18nInsertBefore){_getInsertInFrontOfRNodeWithI18n=getInsertInFrontOfRNodeWithI18n,_processI18nInsertBefore=processI18nInsertBefore}function appendChild(tView,lView,childRNode,childTNode){const parentRNode=getParentRElement(tView,childTNode,lView),renderer=lView[11],anchorNode=getInsertInFrontOfRNode(childTNode.parent||lView[5],childTNode,lView);if(null!=parentRNode)if(Array.isArray(childRNode))for(let i=0;i<childRNode.length;i++)nativeAppendOrInsertBefore(renderer,parentRNode,childRNode[i],anchorNode,!1);else nativeAppendOrInsertBefore(renderer,parentRNode,childRNode,anchorNode,!1);void 0!==_processI18nInsertBefore&&_processI18nInsertBefore(renderer,childTNode,lView,childRNode,parentRNode)}function getFirstNativeNode(lView,tNode){if(null!==tNode){ngDevMode&&assertTNodeType(tNode,191);const tNodeType=tNode.type;if(3&tNodeType)return root_effect_scheduler_getNativeByTNode(tNode,lView);if(4&tNodeType)return getBeforeNodeForView(-1,lView[tNode.index]);if(8&tNodeType){const elIcuContainerChild=tNode.child;if(null!==elIcuContainerChild)return getFirstNativeNode(lView,elIcuContainerChild);{const rNodeOrLContainer=lView[tNode.index];return root_effect_scheduler_isLContainer(rNodeOrLContainer)?getBeforeNodeForView(-1,rNodeOrLContainer):root_effect_scheduler_unwrapRNode(rNodeOrLContainer)}}if(128&tNodeType)return getFirstNativeNode(lView,tNode.next);if(32&tNodeType){return icuContainerIterate(tNode,lView)()||root_effect_scheduler_unwrapRNode(lView[tNode.index])}{const projectionNodes=getProjectionNodes(lView,tNode);if(null!==projectionNodes){if(Array.isArray(projectionNodes))return projectionNodes[0];const parentView=getLViewParent(lView[15]);return ngDevMode&&assertParentView(parentView),getFirstNativeNode(parentView,projectionNodes)}return getFirstNativeNode(lView,tNode.next)}}return null}function getProjectionNodes(lView,tNode){if(null!==tNode){const componentHost=lView[15][5],slotIdx=tNode.projection;return ngDevMode&&function assertProjectionSlots(lView,errMessage){root_effect_scheduler_assertDefined(lView[15],"Component views should exist."),root_effect_scheduler_assertDefined(lView[15][5].projection,"Components with projection nodes (<ng-content>) must have projection slots defined.")}(lView),componentHost.projection[slotIdx]}return null}function getBeforeNodeForView(viewIndexInContainer,lContainer){const nextViewIndex=10+viewIndexInContainer+1;if(nextViewIndex<lContainer.length){const lView=lContainer[nextViewIndex],firstTNodeOfView=lView[1].firstChild;if(null!==firstTNodeOfView)return getFirstNativeNode(lView,firstTNodeOfView)}return lContainer[7]}function applyNodes(renderer,action,tNode,lView,parentRElement,beforeNode,isProjection){for(;null!=tNode;){ngDevMode&&assertTNodeForLView(tNode,lView);const injector=lView[9];if(128===tNode.type){tNode=tNode.next;continue}ngDevMode&&assertTNodeType(tNode,63);const rawSlotValue=lView[tNode.index],tNodeType=tNode.type;if(isProjection&&0===action&&(rawSlotValue&&attachPatchData(root_effect_scheduler_unwrapRNode(rawSlotValue),lView),tNode.flags|=2),!debug_node_isDetachedByI18n(tNode))if(8&tNodeType)applyNodes(renderer,action,tNode.child,lView,parentRElement,beforeNode,!1),applyToElementOrContainer(action,renderer,injector,parentRElement,rawSlotValue,tNode,beforeNode,lView);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)applyToElementOrContainer(action,renderer,injector,parentRElement,rNode,tNode,beforeNode,lView);applyToElementOrContainer(action,renderer,injector,parentRElement,rawSlotValue,tNode,beforeNode,lView)}else 16&tNodeType?applyProjectionRecursive(renderer,action,lView,tNode,parentRElement,beforeNode):(ngDevMode&&assertTNodeType(tNode,7),applyToElementOrContainer(action,renderer,injector,parentRElement,rawSlotValue,tNode,beforeNode,lView));tNode=isProjection?tNode.projectionNext:tNode.next}}function applyView(tView,lView,renderer,action,parentRElement,beforeNode){applyNodes(renderer,action,tView.firstChild,lView,parentRElement,beforeNode,!1)}function applyProjectionRecursive(renderer,action,lView,tProjectionNode,parentRElement,beforeNode){const componentLView=lView[15],componentNode=componentLView[5];ngDevMode&&root_effect_scheduler_assertEqual(typeof tProjectionNode.projection,"number","expecting projection index");const nodeToProjectOrRNodes=componentNode.projection[tProjectionNode.projection];if(Array.isArray(nodeToProjectOrRNodes))for(let i=0;i<nodeToProjectOrRNodes.length;i++){const rNode=nodeToProjectOrRNodes[i];applyToElementOrContainer(action,renderer,lView[9],parentRElement,rNode,tProjectionNode,beforeNode,lView)}else{let nodeToProject=nodeToProjectOrRNodes;const projectedComponentLView=componentLView[3];hasInSkipHydrationBlockFlag(tProjectionNode)&&(nodeToProject.flags|=128),applyNodes(renderer,action,nodeToProject,projectedComponentLView,parentRElement,beforeNode,!0)}}function executeTemplate(tView,lView,templateFn,rf,context){const prevSelectedIndex=getSelectedIndex(),isUpdatePhase=2&rf;try{setSelectedIndex(-1),isUpdatePhase&&lView.length>27&&selectIndexInternal(tView,lView,27,!!ngDevMode&&isInCheckNoChangesMode());debug_node_profiler(isUpdatePhase?2:0,context,templateFn),templateFn(rf,context)}finally{setSelectedIndex(prevSelectedIndex);debug_node_profiler(isUpdatePhase?3:1,context,templateFn)}}function createDirectivesInstances(tView,lView,tNode){!function instantiateAllDirectives(tView,lView,tNode){const start=tNode.directiveStart,end=tNode.directiveEnd;root_effect_scheduler_isComponentHost(tNode)&&(ngDevMode&&assertTNodeType(tNode,3),function createComponentLView(lView,hostTNode,def){const native=root_effect_scheduler_getNativeByTNode(hostTNode,lView),tView=getOrCreateComponentTView(def),rendererFactory=lView[10].rendererFactory,componentView=addToEndOfViewTree(lView,createLView(lView,tView,null,getInitialLViewFlagsFromDef(def),native,hostTNode,null,rendererFactory.createRenderer(native,def),null,null,null));return lView[hostTNode.index]=componentView}(lView,tNode,tView.data[start+tNode.componentOffset]));tView.firstCreatePass||getOrCreateNodeInjectorForNode(tNode,lView);const initialInputs=tNode.initialInputs;for(let i=start;i<end;i++){const def=tView.data[i],directive=getNodeInjectable(lView,tView,i,tNode);if(attachPatchData(directive,lView),null!==initialInputs&&setInputsFromAttrs(lView,i-start,directive,def,tNode,initialInputs),isComponentDef(def)){root_effect_scheduler_getComponentLViewByIndex(tNode.index,lView)[8]=getNodeInjectable(lView,tView,i,tNode)}}}(tView,lView,tNode),64&~tNode.flags||function invokeDirectivesHostBindings(tView,lView,tNode){const start=tNode.directiveStart,end=tNode.directiveEnd,elementIndex=tNode.index,currentDirectiveIndex=function getCurrentDirectiveIndex(){return instructionState.lFrame.currentDirectiveIndex}();try{setSelectedIndex(elementIndex);for(let dirIndex=start;dirIndex<end;dirIndex++){const def=tView.data[dirIndex],directive=lView[dirIndex];setCurrentDirectiveIndex(dirIndex),null===def.hostBindings&&0===def.hostVars&&null===def.hostAttrs||invokeHostBindingsInCreationMode(def,directive)}}finally{setSelectedIndex(-1),setCurrentDirectiveIndex(currentDirectiveIndex)}}(tView,lView,tNode)}function saveResolvedLocalsInData(viewData,tNode,localRefExtractor=root_effect_scheduler_getNativeByTNode){const localNames=tNode.localNames;if(null!==localNames){let localIndex=tNode.index+1;for(let i=0;i<localNames.length;i+=2){const index=localNames[i+1],value=-1===index?localRefExtractor(tNode,viewData):viewData[index];viewData[localIndex++]=value}}}function locateHostElement(renderer,elementOrSelector,encapsulation,injector){const preserveContent=injector.get(debug_node_PRESERVE_HOST_CONTENT,false)||encapsulation===ViewEncapsulation.ShadowDom,rootElement=renderer.selectRootElement(elementOrSelector,preserveContent);return function applyRootElementTransform(rootElement){_applyRootElementTransformImpl(rootElement)}(rootElement),rootElement}let _applyRootElementTransformImpl=()=>null;function setPropertyAndInputs(tNode,lView,propName,value,renderer,sanitizer){ngDevMode&&assertNotSame(value,NO_CHANGE,"Incoming value should never be NO_CHANGE.");const tView=lView[1];if(setAllInputsForProperty(tNode,tView,lView,propName,value))return root_effect_scheduler_isComponentHost(tNode)&&markDirtyIfOnPush(lView,tNode.index),void(ngDevMode&&setNgReflectProperties(lView,tView,tNode,propName,value));3&tNode.type&&(propName=function mapPropName(name){return"class"===name?"className":"for"===name?"htmlFor":"formaction"===name?"formAction":"innerHtml"===name?"innerHTML":"readonly"===name?"readOnly":"tabindex"===name?"tabIndex":name}(propName)),setDomProperty(tNode,lView,propName,value,renderer,sanitizer)}function setDomProperty(tNode,lView,propName,value,renderer,sanitizer){if(3&tNode.type){const element=root_effect_scheduler_getNativeByTNode(tNode,lView);ngDevMode&&(!function validateAgainstEventProperties(name){if(name.toLowerCase().startsWith("on")){const errorMessage=`Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...\nIf '${name}' is a directive input, make sure the directive is imported by the current module.`;throw new root_effect_scheduler_RuntimeError(306,errorMessage)}}(propName),function isPropertyValid(element,propName,tagName,schemas){return!(null!==schemas&&!(matchingSchemas(schemas,tagName)||propName in element||isAnimationProp(propName))&&"undefined"!=typeof Node&&null!==Node&&element instanceof Node)}(element,propName,tNode.value,lView[1].schemas)||handleUnknownPropertyError(propName,tNode.value,tNode.type,lView)),value=null!=sanitizer?sanitizer(value,tNode.value||"",propName):value,renderer.setProperty(element,propName,value)}else 12&tNode.type&&ngDevMode&&!matchingSchemas(lView[1].schemas,tNode.value)&&handleUnknownPropertyError(propName,tNode.value,tNode.type,lView)}function markDirtyIfOnPush(lView,viewIndex){ngDevMode&&assertLView(lView);const childComponentLView=root_effect_scheduler_getComponentLViewByIndex(viewIndex,lView);16&childComponentLView[2]||(childComponentLView[2]|=64)}function setNgReflectProperty(lView,tNode,attrName,value){if(!lView[10].ngReflect)return;const element=root_effect_scheduler_getNativeByTNode(tNode,lView),renderer=lView[11];attrName=normalizeDebugBindingName(attrName);const debugValue=function normalizeDebugBindingValue(value){try{return null!=value?value.toString().slice(0,30):value}catch(e){return"[ERROR] Exception while trying to serialize the value"}}(value);if(3&tNode.type)null==value?renderer.removeAttribute(element,attrName):renderer.setAttribute(element,attrName,debugValue);else{const textContent=escapeCommentText(`bindings=${JSON.stringify({[attrName]:debugValue},null,2)}`);renderer.setValue(element,textContent)}}function setNgReflectProperties(lView,tView,tNode,publicName,value){if(!(lView[10].ngReflect&&7&tNode.type))return;const inputConfig=tNode.inputs?.[publicName],hostInputConfig=tNode.hostDirectiveInputs?.[publicName];if(hostInputConfig)for(let i=0;i<hostInputConfig.length;i+=2){const index=hostInputConfig[i],publicName=hostInputConfig[i+1];setNgReflectProperty(lView,tNode,tView.data[index].inputs[publicName][0],value)}if(inputConfig)for(const index of inputConfig){setNgReflectProperty(lView,tNode,tView.data[index].inputs[publicName][0],value)}}function invokeHostBindingsInCreationMode(def,directive){null!==def.hostBindings&&def.hostBindings(1,directive)}function findDirectiveDefMatches(tView,tNode){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&assertTNodeType(tNode,15);const registry=tView.directiveRegistry;let matches=null;if(registry)for(let i=0;i<registry.length;i++){const def=registry[i];isNodeMatchingSelectorList(tNode,def.selectors,!1)&&(matches??=[],isComponentDef(def)?(ngDevMode&&(assertTNodeType(tNode,2,`"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`),matches.length&&isComponentDef(matches[0])&&throwMultipleComponentError(tNode,matches.find(isComponentDef).type,def.type)),matches.unshift(def)):matches.push(def))}return matches}function elementAttributeInternal(tNode,lView,name,value,sanitizer,namespace){ngDevMode&&(assertNotSame(value,NO_CHANGE,"Incoming value should never be NO_CHANGE."),function validateAgainstEventAttributes(name){if(name.toLowerCase().startsWith("on")){const errorMessage=`Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;throw new root_effect_scheduler_RuntimeError(306,errorMessage)}}(name),assertTNodeType(tNode,2,`Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`));const element=root_effect_scheduler_getNativeByTNode(tNode,lView);setElementAttribute(lView[11],element,namespace,tNode.value,name,value,sanitizer)}function setElementAttribute(renderer,element,namespace,tagName,name,value,sanitizer){if(null==value)renderer.removeAttribute(element,name,namespace);else{const strValue=null==sanitizer?root_effect_scheduler_renderStringify(value):sanitizer(value,tagName||"",name);renderer.setAttribute(element,name,strValue,namespace)}}function setInputsFromAttrs(lView,directiveIndex,instance,def,tNode,initialInputData){const initialInputs=initialInputData[directiveIndex];if(null!==initialInputs)for(let i=0;i<initialInputs.length;i+=2){const lookupName=initialInputs[i],value=initialInputs[i+1];writeToDirectiveInput(def,instance,lookupName,value),ngDevMode&&setNgReflectProperty(lView,tNode,def.inputs[lookupName][0],value)}}function elementLikeStartShared(tNode,lView,index,name,locateOrCreateNativeNode){const adjustedIndex=27+index,tView=lView[1],native=locateOrCreateNativeNode(tView,lView,tNode,name,index);lView[adjustedIndex]=native,setCurrentTNode(tNode,!0);const isElement=2===tNode.type;return isElement?(setupStaticAttributes(lView[11],native,tNode),(0===function getElementDepthCount(){return instructionState.lFrame.elementDepthCount}()||isDirectiveHost(tNode))&&attachPatchData(native,lView),function increaseElementDepthCount(){instructionState.lFrame.elementDepthCount++}()):attachPatchData(native,lView),!wasLastNodeCreated()||isElement&&debug_node_isDetachedByI18n(tNode)||appendChild(tView,lView,native,tNode),tNode}function elementLikeEndShared(tNode){let currentTNode=tNode;return isCurrentTNodeParent()?setCurrentTNodeAsNotParent():(ngDevMode&&function assertHasParent(tNode){root_effect_scheduler_assertDefined(tNode,"currentTNode should exist!"),root_effect_scheduler_assertDefined(tNode.parent,"currentTNode should have a parent")}(root_effect_scheduler_getCurrentTNode()),currentTNode=currentTNode.parent,setCurrentTNode(currentTNode,!1)),currentTNode}function storePropertyBindingMetadata(tData,tNode,propertyName,bindingIndex,...interpolationParts){if(null===tData[bindingIndex]&&!tNode.inputs?.[propertyName]&&!tNode.hostDirectiveInputs?.[propertyName]){(tNode.propertyBindings||(tNode.propertyBindings=[])).push(bindingIndex);let bindingMetadata=propertyName;interpolationParts.length>0&&(bindingMetadata+="�"+interpolationParts.join("�")),tData[bindingIndex]=bindingMetadata}}function loadComponentRenderer(currentDef,tNode,lView){return(null===currentDef||isComponentDef(currentDef))&&(lView=function root_effect_scheduler_unwrapLView(value){for(;Array.isArray(value);){if("object"==typeof value[1])return value;value=value[0]}return null}(lView[tNode.index])),lView[11]}function handleUncaughtError(lView,error){const injector=lView[9];if(!injector)return;let errorHandler;try{errorHandler=injector.get(INTERNAL_APPLICATION_ERROR_HANDLER,null)}catch{errorHandler=null}errorHandler?.(error)}function setAllInputsForProperty(tNode,tView,lView,publicName,value){const inputs=tNode.inputs?.[publicName],hostDirectiveInputs=tNode.hostDirectiveInputs?.[publicName];let hasMatch=!1;if(hostDirectiveInputs)for(let i=0;i<hostDirectiveInputs.length;i+=2){const index=hostDirectiveInputs[i];ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,index);const publicName=hostDirectiveInputs[i+1];writeToDirectiveInput(tView.data[index],lView[index],publicName,value),hasMatch=!0}if(inputs)for(const index of inputs){ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,index);const instance=lView[index];writeToDirectiveInput(tView.data[index],instance,publicName,value),hasMatch=!0}return hasMatch}function renderComponent(hostLView,componentHostIdx){ngDevMode&&root_effect_scheduler_assertEqual(isCreationMode(hostLView),!0,"Should be run in creation mode");const componentView=root_effect_scheduler_getComponentLViewByIndex(componentHostIdx,hostLView),componentTView=componentView[1];!function syncViewWithBlueprint(tView,lView){for(let i=lView.length;i<tView.blueprint.length;i++)lView.push(tView.blueprint[i])}(componentTView,componentView);const hostRNode=componentView[0];null!==hostRNode&&null===componentView[6]&&(componentView[6]=retrieveHydrationInfo(hostRNode,componentView[9])),debug_node_profiler(18),renderView(componentTView,componentView,componentView[8]),debug_node_profiler(19,componentView[8])}function renderView(tView,lView,context){ngDevMode&&root_effect_scheduler_assertEqual(isCreationMode(lView),!0,"Should be run in creation mode"),ngDevMode&&assertNotReactive(renderView.name),enterView(lView);try{const viewQuery=tView.viewQuery;null!==viewQuery&&executeViewQueryFn(1,viewQuery,context);const templateFn=tView.template;null!==templateFn&&executeTemplate(tView,lView,templateFn,1,context),tView.firstCreatePass&&(tView.firstCreatePass=!1),lView[18]?.finishViewCreation(tView),tView.staticContentQueries&&refreshContentQueries(tView,lView),tView.staticViewQueries&&executeViewQueryFn(2,tView.viewQuery,context);const components=tView.components;null!==components&&function renderChildComponents(hostLView,components){for(let i=0;i<components.length;i++)renderComponent(hostLView,components[i])}(lView,components)}catch(error){throw tView.firstCreatePass&&(tView.incompleteFirstPass=!0,tView.firstCreatePass=!1),error}finally{lView[2]&=-5,leaveView()}}function createAndRenderEmbeddedLView(declarationLView,templateTNode,context,options){const prevConsumer=setActiveConsumer(null);try{const embeddedTView=templateTNode.tView;ngDevMode&&root_effect_scheduler_assertDefined(embeddedTView,"TView must be defined for a template node."),ngDevMode&&assertTNodeForLView(templateTNode,declarationLView);const isSignalView=4096&declarationLView[2],embeddedLView=createLView(declarationLView,embeddedTView,context,isSignalView?4096:16,null,templateTNode,null,null,options?.injector??null,options?.embeddedViewInjector??null,options?.dehydratedView??null),declarationLContainer=declarationLView[templateTNode.index];ngDevMode&&assertLContainer(declarationLContainer),embeddedLView[16]=declarationLContainer;const declarationViewLQueries=declarationLView[18];return null!==declarationViewLQueries&&(embeddedLView[18]=declarationViewLQueries.createEmbeddedView(embeddedTView)),renderView(embeddedTView,embeddedLView,context),embeddedLView}finally{setActiveConsumer(prevConsumer)}}function shouldAddViewToDom(tNode,dehydratedView){return!dehydratedView||null===dehydratedView.firstChild||hasInSkipHydrationBlockFlag(tNode)}const debug_node_UseExhaustiveCheckNoChanges=new InjectionToken(ngDevMode?"exhaustive checkNoChanges":"");function debug_node_collectNativeNodes(tView,lView,tNode,result,isProjection=!1){for(;null!==tNode;){if(128===tNode.type){tNode=isProjection?tNode.projectionNext:tNode.next;continue}ngDevMode&&assertTNodeType(tNode,63);const lNode=lView[tNode.index];null!==lNode&&result.push(root_effect_scheduler_unwrapRNode(lNode)),root_effect_scheduler_isLContainer(lNode)&&debug_node_collectNativeNodesInLContainer(lNode,result);const tNodeType=tNode.type;if(8&tNodeType)debug_node_collectNativeNodes(tView,lView,tNode.child,result);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)result.push(rNode)}else if(16&tNodeType){const nodesInSlot=getProjectionNodes(lView,tNode);if(Array.isArray(nodesInSlot))result.push(...nodesInSlot);else{const parentView=getLViewParent(lView[15]);ngDevMode&&assertParentView(parentView),debug_node_collectNativeNodes(parentView[1],parentView,nodesInSlot,result,!0)}}tNode=isProjection?tNode.projectionNext:tNode.next}return result}function debug_node_collectNativeNodesInLContainer(lContainer,result){for(let i=10;i<lContainer.length;i++){const lViewInAContainer=lContainer[i],lViewFirstChildTNode=lViewInAContainer[1].firstChild;null!==lViewFirstChildTNode&&debug_node_collectNativeNodes(lViewInAContainer[1],lViewInAContainer,lViewFirstChildTNode,result)}lContainer[7]!==lContainer[0]&&result.push(lContainer[7])}function addAfterRenderSequencesForView(lView){if(null!==lView[25]){for(const sequence of lView[25])sequence.impl.addSequence(sequence);lView[25].length=0}}let freeConsumers=[];function getOrBorrowReactiveLViewConsumer(lView){return lView[24]??function borrowReactiveLViewConsumer(lView){const consumer=freeConsumers.pop()??Object.create(REACTIVE_LVIEW_CONSUMER_NODE);return consumer.lView=lView,consumer}(lView)}const REACTIVE_LVIEW_CONSUMER_NODE={...REACTIVE_NODE,consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:node=>{markAncestorsForTraversal(node.lView)},consumerOnSignalRead(){this.lView[24]=this}};const TEMPORARY_CONSUMER_NODE={...REACTIVE_NODE,consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:node=>{let parent=getLViewParent(node.lView);for(;parent&&!viewShouldHaveReactiveConsumer(parent[1]);)parent=getLViewParent(parent);parent&&root_effect_scheduler_markViewForRefresh(parent)},consumerOnSignalRead(){this.lView[24]=this}};function viewShouldHaveReactiveConsumer(tView){return 2!==tView.type}function runEffectsInView(view){if(null===view[23])return;let tryFlushEffects=!0;for(;tryFlushEffects;){let foundDirtyEffect=!1;for(const effect of view[23])effect.dirty&&(foundDirtyEffect=!0,null===effect.zone||Zone.current===effect.zone?effect.run():effect.zone.run(()=>effect.run()));tryFlushEffects=foundDirtyEffect&&!!(8192&view[2])}}function detectChangesInternal(lView,mode=0){const rendererFactory=lView[10].rendererFactory,checkNoChangesMode=!!ngDevMode&&isInCheckNoChangesMode();checkNoChangesMode||rendererFactory.begin?.();try{!function detectChangesInViewWhileDirty(lView,mode){const lastIsRefreshingViewsValue=isRefreshingViews();try{if(setIsRefreshingViews(!0),detectChangesInView(lView,mode),ngDevMode&&isExhaustiveCheckNoChanges())return;let retries=0;for(;root_effect_scheduler_requiresRefreshOrTraversal(lView);){if(100===retries)throw new root_effect_scheduler_RuntimeError(103,ngDevMode&&"Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");retries++,detectChangesInView(lView,1)}}finally{setIsRefreshingViews(lastIsRefreshingViewsValue)}}(lView,mode)}finally{checkNoChangesMode||rendererFactory.end?.()}}function refreshView(tView,lView,templateFn,context){if(ngDevMode&&root_effect_scheduler_assertEqual(isCreationMode(lView),!1,"Should be run in update mode"),isDestroyed(lView))return;const flags=lView[2],isInCheckNoChangesPass=ngDevMode&&isInCheckNoChangesMode(),isInExhaustiveCheckNoChangesPass=ngDevMode&&isExhaustiveCheckNoChanges();enterView(lView);let returnConsumerToPool=!0,prevConsumer=null,currentConsumer=null;isInCheckNoChangesPass||(viewShouldHaveReactiveConsumer(tView)?(currentConsumer=getOrBorrowReactiveLViewConsumer(lView),prevConsumer=consumerBeforeComputation(currentConsumer)):null===getActiveConsumer()?(returnConsumerToPool=!1,currentConsumer=function getOrCreateTemporaryConsumer(lView){const consumer=lView[24]??Object.create(TEMPORARY_CONSUMER_NODE);return consumer.lView=lView,consumer}(lView),prevConsumer=consumerBeforeComputation(currentConsumer)):lView[24]&&(consumerDestroy(lView[24]),lView[24]=null));try{resetPreOrderHookFlags(lView),setBindingIndex(tView.bindingStartIndex),null!==templateFn&&executeTemplate(tView,lView,templateFn,2,context);const hooksInitPhaseCompleted=!(3&~flags);if(!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,null)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,null),incrementInitPhaseFlags(lView,0)}if(isInExhaustiveCheckNoChangesPass||function markTransplantedViewsForRefresh(lView){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer)){if(!(2&lContainer[2]))continue;const movedViews=lContainer[9];ngDevMode&&root_effect_scheduler_assertDefined(movedViews,"Transplanted View flags set but missing MOVED_VIEWS");for(let i=0;i<movedViews.length;i++){root_effect_scheduler_markViewForRefresh(movedViews[i])}}}(lView),runEffectsInView(lView),detectChangesInEmbeddedViews(lView,0),null!==tView.contentQueries&&refreshContentQueries(tView,lView),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const contentCheckHooks=tView.contentCheckHooks;null!==contentCheckHooks&&executeCheckHooks(lView,contentCheckHooks)}else{const contentHooks=tView.contentHooks;null!==contentHooks&&executeInitAndCheckHooks(lView,contentHooks,1),incrementInitPhaseFlags(lView,1)}!function processHostBindingOpCodes(tView,lView){const hostBindingOpCodes=tView.hostBindingOpCodes;if(null===hostBindingOpCodes)return;try{for(let i=0;i<hostBindingOpCodes.length;i++){const opCode=hostBindingOpCodes[i];if(opCode<0)setSelectedIndex(~opCode);else{const directiveIdx=opCode,bindingRootIndx=hostBindingOpCodes[++i],hostBindingFn=hostBindingOpCodes[++i];setBindingRootForHostBindings(bindingRootIndx,directiveIdx);const context=lView[directiveIdx];debug_node_profiler(24,context),hostBindingFn(2,context),debug_node_profiler(25,context)}}}finally{setSelectedIndex(-1)}}(tView,lView);const components=tView.components;null!==components&&detectChangesInChildComponents(lView,components,0);const viewQuery=tView.viewQuery;if(null!==viewQuery&&executeViewQueryFn(2,viewQuery,context),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const viewCheckHooks=tView.viewCheckHooks;null!==viewCheckHooks&&executeCheckHooks(lView,viewCheckHooks)}else{const viewHooks=tView.viewHooks;null!==viewHooks&&executeInitAndCheckHooks(lView,viewHooks,2),incrementInitPhaseFlags(lView,2)}if(!0===tView.firstUpdatePass&&(tView.firstUpdatePass=!1),lView[22]){for(const notifyEffect of lView[22])notifyEffect();lView[22]=null}isInCheckNoChangesPass||(addAfterRenderSequencesForView(lView),lView[2]&=-73)}catch(e){throw isInCheckNoChangesPass||markAncestorsForTraversal(lView),e}finally{null!==currentConsumer&&(consumerAfterComputation(currentConsumer,prevConsumer),returnConsumerToPool&&function maybeReturnReactiveLViewConsumer(consumer){consumer.lView[24]!==consumer&&(consumer.lView=null,freeConsumers.push(consumer))}(currentConsumer)),leaveView()}}function detectChangesInEmbeddedViews(lView,mode){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer))for(let i=10;i<lContainer.length;i++){detectChangesInViewIfAttached(lContainer[i],mode)}}function detectChangesInComponent(hostLView,componentHostIdx,mode){ngDevMode&&root_effect_scheduler_assertEqual(isCreationMode(hostLView),!1,"Should be run in update mode"),debug_node_profiler(18);const componentView=root_effect_scheduler_getComponentLViewByIndex(componentHostIdx,hostLView);detectChangesInViewIfAttached(componentView,mode),debug_node_profiler(19,componentView[8])}function detectChangesInViewIfAttached(lView,mode){viewAttachedToChangeDetector(lView)&&detectChangesInView(lView,mode)}function detectChangesInView(lView,mode){const isInCheckNoChangesPass=ngDevMode&&isInCheckNoChangesMode(),tView=lView[1],flags=lView[2],consumer=lView[24];let shouldRefreshView=!!(0===mode&&16&flags);if(shouldRefreshView||=!(!(64&flags&&0===mode)||isInCheckNoChangesPass),shouldRefreshView||=!!(1024&flags),shouldRefreshView||=!(!consumer?.dirty||!consumerPollProducersForChange(consumer)),shouldRefreshView||=!(!ngDevMode||!isExhaustiveCheckNoChanges()),consumer&&(consumer.dirty=!1),lView[2]&=-9217,shouldRefreshView)refreshView(tView,lView,tView.template,lView[8]);else if(8192&flags){const prevConsumer=setActiveConsumer(null);try{isInCheckNoChangesPass||runEffectsInView(lView),detectChangesInEmbeddedViews(lView,1);const components=tView.components;null!==components&&detectChangesInChildComponents(lView,components,1),isInCheckNoChangesPass||addAfterRenderSequencesForView(lView)}finally{setActiveConsumer(prevConsumer)}}}function detectChangesInChildComponents(hostLView,components,mode){for(let i=0;i<components.length;i++)detectChangesInComponent(hostLView,components[i],mode)}function markViewDirty(lView,source){const dirtyBitsToUse=isRefreshingViews()?64:1088;for(lView[10].changeDetectionScheduler?.notify(source);lView;){lView[2]|=dirtyBitsToUse;const parent=getLViewParent(lView);if(root_effect_scheduler_isRootView(lView)&&!parent)return lView;lView=parent}return null}function createLContainer(hostNative,currentView,native,tNode){ngDevMode&&assertLView(currentView);const lContainer=[hostNative,!0,0,currentView,null,tNode,null,native,null,null];return ngDevMode&&root_effect_scheduler_assertEqual(lContainer.length,10,"Should allocate correct number of slots for LContainer header."),lContainer}function getLViewFromLContainer(lContainer,index){const adjustedIndex=10+index;if(adjustedIndex<lContainer.length){const lView=lContainer[adjustedIndex];return ngDevMode&&assertLView(lView),lView}}function addLViewToLContainer(lContainer,lView,index,addToDOM=!0){const tView=lView[1];if(function insertView(tView,lView,lContainer,index){ngDevMode&&assertLView(lView),ngDevMode&&assertLContainer(lContainer);const indexInContainer=10+index,containerLength=lContainer.length;index>0&&(lContainer[indexInContainer-1][4]=lView);index<containerLength-10?(lView[4]=lContainer[indexInContainer],addToArray(lContainer,10+index,lView)):(lContainer.push(lView),lView[4]=null);lView[3]=lContainer;const declarationLContainer=lView[16];null!==declarationLContainer&&lContainer!==declarationLContainer&&trackMovedView(declarationLContainer,lView);const lQueries=lView[18];null!==lQueries&&lQueries.insertView(tView);updateAncestorTraversalFlagsOnAttach(lView),lView[2]|=128}(tView,lView,lContainer,index),addToDOM){const beforeNode=getBeforeNodeForView(index,lContainer),renderer=lView[11],parentRNode=renderer.parentNode(lContainer[7]);null!==parentRNode&&function addViewToDOM(tView,parentTNode,renderer,lView,parentNativeNode,beforeNode){lView[0]=parentNativeNode,lView[5]=parentTNode,applyView(tView,lView,renderer,1,parentNativeNode,beforeNode)}(tView,lContainer[5],renderer,lView,parentRNode,beforeNode)}const hydrationInfo=lView[6];null!==hydrationInfo&&null!==hydrationInfo.firstChild&&(hydrationInfo.firstChild=null)}function removeLViewFromLContainer(lContainer,index){const lView=detachView(lContainer,index);return void 0!==lView&&destroyLView(lView[1],lView),lView}function detachView(lContainer,removeIndex){if(lContainer.length<=10)return;const indexInContainer=10+removeIndex,viewToDetach=lContainer[indexInContainer];if(viewToDetach){const declarationLContainer=viewToDetach[16];null!==declarationLContainer&&declarationLContainer!==lContainer&&detachMovedView(declarationLContainer,viewToDetach),removeIndex>0&&(lContainer[indexInContainer-1][4]=viewToDetach[4]);const removedLView=removeFromArray(lContainer,10+removeIndex);removeViewFromDOM(viewToDetach[1],viewToDetach);const lQueries=removedLView[18];null!==lQueries&&lQueries.detachView(removedLView[1]),viewToDetach[3]=null,viewToDetach[4]=null,viewToDetach[2]&=-129}return viewToDetach}function trackMovedView(declarationContainer,lView){ngDevMode&&root_effect_scheduler_assertDefined(lView,"LView required"),ngDevMode&&assertLContainer(declarationContainer);const movedViews=declarationContainer[9],parent=lView[3];if(ngDevMode&&root_effect_scheduler_assertDefined(parent,"missing parent"),root_effect_scheduler_isLView(parent))declarationContainer[2]|=2;else{const insertedComponentLView=parent[3][15];ngDevMode&&root_effect_scheduler_assertDefined(insertedComponentLView,"Missing insertedComponentLView");const declaredComponentLView=lView[15];ngDevMode&&root_effect_scheduler_assertDefined(declaredComponentLView,"Missing declaredComponentLView"),declaredComponentLView!==insertedComponentLView&&(declarationContainer[2]|=2)}null===movedViews?declarationContainer[9]=[lView]:movedViews.push(lView)}class ViewRef{_lView;_cdRefInjectingView;_appRef=null;_attachedToViewContainer=!1;exhaustive;get rootNodes(){const lView=this._lView,tView=lView[1];return debug_node_collectNativeNodes(tView,lView,tView.firstChild,[])}constructor(_lView,_cdRefInjectingView){this._lView=_lView,this._cdRefInjectingView=_cdRefInjectingView}get context(){return this._lView[8]}set context(value){ngDevMode&&console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated."),this._lView[8]=value}get destroyed(){return isDestroyed(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const parent=this._lView[3];if(root_effect_scheduler_isLContainer(parent)){const viewRefs=parent[8],index=viewRefs?viewRefs.indexOf(this):-1;index>-1&&(ngDevMode&&root_effect_scheduler_assertEqual(index,parent.indexOf(this._lView)-10,"An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array."),detachView(parent,index),removeFromArray(viewRefs,index))}this._attachedToViewContainer=!1}destroyLView(this._lView[1],this._lView)}onDestroy(callback){storeLViewOnDestroy(this._lView,callback)}markForCheck(){markViewDirty(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[2]&=-129}reattach(){updateAncestorTraversalFlagsOnAttach(this._lView),this._lView[2]|=128}detectChanges(){this._lView[2]|=1024,detectChangesInternal(this._lView)}checkNoChanges(){if(ngDevMode){try{this.exhaustive??=this._lView[9].get(debug_node_UseExhaustiveCheckNoChanges,false)}catch{this.exhaustive=false}!function debug_node_checkNoChangesInternal(lView,exhaustive){setIsInCheckNoChangesMode(exhaustive?CheckNoChangesMode.Exhaustive:CheckNoChangesMode.OnlyDirtyViews);try{detectChangesInternal(lView)}finally{setIsInCheckNoChangesMode(CheckNoChangesMode.Off)}}(this._lView,this.exhaustive)}}attachToViewContainerRef(){if(this._appRef)throw new root_effect_scheduler_RuntimeError(902,ngDevMode&&"This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;const isRoot=root_effect_scheduler_isRootView(this._lView),declarationContainer=this._lView[16];null===declarationContainer||isRoot||detachMovedView(declarationContainer,this._lView),detachViewFromDOM(this._lView[1],this._lView)}attachToAppRef(appRef){if(this._attachedToViewContainer)throw new root_effect_scheduler_RuntimeError(902,ngDevMode&&"This view is already attached to a ViewContainer!");this._appRef=appRef;const isRoot=root_effect_scheduler_isRootView(this._lView),declarationContainer=this._lView[16];null===declarationContainer||isRoot||trackMovedView(declarationContainer,this._lView),updateAncestorTraversalFlagsOnAttach(this._lView)}}class TemplateRef{_declarationLView;_declarationTContainer;elementRef;static __NG_ELEMENT_ID__=injectTemplateRef;constructor(_declarationLView,_declarationTContainer,elementRef){this._declarationLView=_declarationLView,this._declarationTContainer=_declarationTContainer,this.elementRef=elementRef}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(context,injector){return this.createEmbeddedViewImpl(context,injector)}createEmbeddedViewImpl(context,injector,dehydratedView){const embeddedLView=createAndRenderEmbeddedLView(this._declarationLView,this._declarationTContainer,context,{embeddedViewInjector:injector,dehydratedView});return new ViewRef(embeddedLView)}}function injectTemplateRef(){return createTemplateRef(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView())}function createTemplateRef(hostTNode,hostLView){return 4&hostTNode.type?(ngDevMode&&root_effect_scheduler_assertDefined(hostTNode.tView,"TView must be allocated"),new TemplateRef(hostLView,hostTNode,createElementRef(hostTNode,hostLView))):null}function validateSiblingNodeExists(node){if(debug_node_validateNodeExists(node),!node.nextSibling){const header="During hydration Angular expected more sibling nodes to be present.\n\n",actual=`Actual DOM is:\n\n${describeDomFromNode(node)}\n\n`,message=header+actual+getHydrationErrorFooter();throw markRNodeAsHavingHydrationMismatch(node,"",actual),new root_effect_scheduler_RuntimeError(-501,message)}}function debug_node_validateNodeExists(node,lView=null,tNode=null){if(!node){const header="During hydration, Angular expected an element to be present at this location.\n\n";let expected="",footer="";throw null!==lView&&null!==tNode&&(expected=describeExpectedDom(lView,tNode,!1),footer=getHydrationErrorFooter(),markRNodeAsHavingHydrationMismatch(root_effect_scheduler_unwrapRNode(lView[0]),expected,"")),new root_effect_scheduler_RuntimeError(-502,`${header}${expected}\n\n${footer}`)}}const internalAttrs=new Set(["ngh","ng-version","ng-server-context"]);function describeTNode(tNode,innerContent="…"){switch(tNode.type){case 1:return`#text${tNode.value?`(${tNode.value})`:""}`;case 2:const attrs=function stringifyTNodeAttrs(tNode){const results=[];if(tNode.attrs)for(let i=0;i<tNode.attrs.length;){const attrName=tNode.attrs[i++];if("number"==typeof attrName)break;const attrValue=tNode.attrs[i++];results.push(`${attrName}="${shorten(attrValue)}"`)}return results.join(" ")}(tNode),tag=tNode.value.toLowerCase();return`<${tag}${attrs?" "+attrs:""}>${innerContent}</${tag}>`;case 8:return"\x3c!-- ng-container --\x3e";case 4:return"\x3c!-- container --\x3e";default:return`#node(${function getFriendlyStringFromTNodeType(tNodeType){switch(tNodeType){case 4:return"view container";case 2:return"element";case 8:return"ng-container";case 32:return"icu";case 64:return"i18n";case 16:return"projection";case 1:return"text";case 128:return"@let";default:return"<unknown>"}}(tNode.type)})`}}function describeRNode(rNode,innerContent="…"){const node=rNode;switch(node.nodeType){case Node.ELEMENT_NODE:const tag=node.tagName.toLowerCase(),attrs=function stringifyRNodeAttrs(rNode){const results=[];for(let i=0;i<rNode.attributes.length;i++){const attr=rNode.attributes[i];internalAttrs.has(attr.name)||results.push(`${attr.name}="${shorten(attr.value)}"`)}return results.join(" ")}(node);return`<${tag}${attrs?" "+attrs:""}>${innerContent}</${tag}>`;case Node.TEXT_NODE:const content=node.textContent?shorten(node.textContent):"";return"#text"+(content?`(${content})`:"");case Node.COMMENT_NODE:return`\x3c!-- ${shorten(node.textContent??"")} --\x3e`;default:return`#node(${node.nodeType})`}}function describeExpectedDom(lView,tNode,isViewContainerAnchor){let content="";tNode.prev?(content+="  …\n",content+="  "+describeTNode(tNode.prev)+"\n"):tNode.type&&12&tNode.type&&(content+="  …\n"),isViewContainerAnchor?(content+="  "+describeTNode(tNode)+"\n",content+="  \x3c!-- container --\x3e  <-- AT THIS LOCATION\n"):content+="  "+describeTNode(tNode)+"  <-- AT THIS LOCATION\n",content+="  …\n";const parentRNode=tNode.type?getParentRElement(lView[1],tNode,lView):null;return parentRNode&&(content=describeRNode(parentRNode,"\n"+content)),content}function describeDomFromNode(node){let content="";const currentNode=node;return currentNode.previousSibling&&(content+="  …\n",content+="  "+describeRNode(currentNode.previousSibling)+"\n"),content+="  "+describeRNode(currentNode)+"  <-- AT THIS LOCATION\n",node.nextSibling&&(content+="  …\n"),node.parentNode&&(content=describeRNode(currentNode.parentNode,"\n"+content)),content}function getHydrationErrorFooter(componentClassName){return`To fix this problem:\n  * check ${componentClassName?`the "${componentClassName}"`:"corresponding"} component for hydration-related issues\n  * check to see if your template has valid HTML structure\n  * or skip hydration by adding the \`ngSkipHydration\` attribute to its host node in a template\n\n`}function shorten(input,maxLength=50){return input?(input=function stripNewlines(input){return input.replace(/\s+/gm,"")}(input)).length>maxLength?`${input.substring(0,maxLength-1)}…`:input:""}function getInsertInFrontOfRNodeWithI18n(parentTNode,currentTNode,lView){const tNodeInsertBeforeIndex=currentTNode.insertBeforeIndex,insertBeforeIndex=Array.isArray(tNodeInsertBeforeIndex)?tNodeInsertBeforeIndex[0]:tNodeInsertBeforeIndex;return null===insertBeforeIndex?getInsertInFrontOfRNodeWithNoI18n(parentTNode,0,lView):(ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,insertBeforeIndex),root_effect_scheduler_unwrapRNode(lView[insertBeforeIndex]))}function processI18nInsertBefore(renderer,childTNode,lView,childRNode,parentRElement){const tNodeInsertBeforeIndex=childTNode.insertBeforeIndex;if(Array.isArray(tNodeInsertBeforeIndex)){ngDevMode&&assertDomNode(childRNode);let i18nParent=childRNode,anchorRNode=null;if(3&childTNode.type||(anchorRNode=i18nParent,i18nParent=parentRElement),null!==i18nParent&&-1===childTNode.componentOffset)for(let i=1;i<tNodeInsertBeforeIndex.length;i++){nativeInsertBefore(renderer,i18nParent,lView[tNodeInsertBeforeIndex[i]],anchorRNode,!1)}}}function getOrCreateTNode(tView,index,type,name,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,27,"TNodes can't be in the LView header."),ngDevMode&&function assertPureTNodeType(type){2!==type&&1!==type&&4!==type&&8!==type&&32!==type&&16!==type&&64!==type&&128!==type&&throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`)}(type);let tNode=tView.data[index];if(null===tNode)tNode=createTNodeAtIndex(tView,index,type,name,attrs),function isInI18nBlock(){return instructionState.lFrame.inI18n}()&&(tNode.flags|=32);else if(64&tNode.type){tNode.type=type,tNode.value=name,tNode.attrs=attrs;const parent=getCurrentParentTNode();tNode.injectorIndex=null===parent?-1:parent.injectorIndex,ngDevMode&&assertTNodeForTView(tNode,tView),ngDevMode&&root_effect_scheduler_assertEqual(index,tNode.index,"Expecting same index")}return setCurrentTNode(tNode,!0),tNode}function createTNodeAtIndex(tView,index,type,name,attrs){const currentTNode=getCurrentTNodePlaceholderOk(),isParent=isCurrentTNodeParent(),parent=isParent?currentTNode:currentTNode&&currentTNode.parent,tNode=tView.data[index]=function createTNode(tView,tParent,type,index,value,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,27,"TNodes can't be in the LView header."),ngDevMode&&assertNotSame(attrs,void 0,"'undefined' is not valid value for 'attrs'"),ngDevMode&&tParent&&assertTNodeForTView(tParent,tView);let injectorIndex=tParent?tParent.injectorIndex:-1,flags=0;root_effect_scheduler_isInSkipHydrationBlock()&&(flags|=128);const tNode={type,index,insertBeforeIndex:null,injectorIndex,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags,providerIndexes:0,value,attrs,mergedAttrs:null,localNames:null,initialInputs:null,inputs:null,hostDirectiveInputs:null,outputs:null,hostDirectiveOutputs:null,directiveToIndex:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:tParent,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0};ngDevMode&&Object.seal(tNode);return tNode}(tView,parent,type,index,name,attrs);return function linkTNodeInTView(tView,tNode,currentTNode,isParent){null===tView.firstChild&&(tView.firstChild=tNode);null!==currentTNode&&(isParent?null==currentTNode.child&&null!==tNode.parent&&(currentTNode.child=tNode):null===currentTNode.next&&(currentTNode.next=tNode,tNode.prev=currentTNode))}(tView,tNode,currentTNode,isParent),tNode}function addTNodeAndUpdateInsertBeforeIndex(previousTNodes,newTNode){if(ngDevMode&&root_effect_scheduler_assertEqual(newTNode.insertBeforeIndex,null,"We expect that insertBeforeIndex is not set"),previousTNodes.push(newTNode),previousTNodes.length>1)for(let i=previousTNodes.length-2;i>=0;i--){const existingTNode=previousTNodes[i];isI18nText(existingTNode)||isNewTNodeCreatedBefore(existingTNode,newTNode)&&null===getInsertBeforeIndex(existingTNode)&&setInsertBeforeIndex(existingTNode,newTNode.index)}}function isI18nText(tNode){return!(64&tNode.type)}function isNewTNodeCreatedBefore(existingTNode,newTNode){return isI18nText(newTNode)||existingTNode.index>newTNode.index}function getInsertBeforeIndex(tNode){const index=tNode.insertBeforeIndex;return Array.isArray(index)?index[0]:index}function setInsertBeforeIndex(tNode,value){const index=tNode.insertBeforeIndex;Array.isArray(index)?index[0]=value:(setI18nHandling(getInsertInFrontOfRNodeWithI18n,processI18nInsertBefore),tNode.insertBeforeIndex=value)}function getTIcu(tView,index){const value=tView.data[index];if(null===value||"string"==typeof value)return null;!ngDevMode||value.hasOwnProperty("tView")||value.hasOwnProperty("currentCaseLViewIndex")||throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: "+value);const tIcu=value.hasOwnProperty("currentCaseLViewIndex")?value:value.value;return ngDevMode&&root_effect_scheduler_assertTIcu(tIcu),tIcu}function createTNodePlaceholder(tView,previousTNodes,index){const tNode=createTNodeAtIndex(tView,index,64,null,null);return addTNodeAndUpdateInsertBeforeIndex(previousTNodes,tNode),tNode}function getCurrentICUCaseIndex(tIcu,lView){const currentCase=lView[tIcu.currentCaseLViewIndex];return null===currentCase?currentCase:currentCase<0?~currentCase:currentCase}function getParentFromIcuCreateOpCode(mergedCode){return mergedCode>>>17}function getRefFromIcuCreateOpCode(mergedCode){return(131070&mergedCode)>>>1}function getInstructionFromIcuCreateOpCode(mergedCode){return 1&mergedCode}function isRootTemplateMessage(subTemplateIndex){return-1===subTemplateIndex}function enterIcu(state,tIcu,lView){state.index=0;const currentCase=getCurrentICUCaseIndex(tIcu,lView);null!==currentCase?(ngDevMode&&assertNumberInRange(currentCase,0,tIcu.cases.length-1),state.removes=tIcu.remove[currentCase]):state.removes=EMPTY_ARRAY}function icuContainerIteratorNext(state){if(state.index<state.removes.length){const removeOpCode=state.removes[state.index++];if(ngDevMode&&root_effect_scheduler_assertNumber(removeOpCode,"Expecting OpCode number"),removeOpCode>0){const rNode=state.lView[removeOpCode];return ngDevMode&&assertDomNode(rNode),rNode}{state.stack.push(state.index,state.removes);const tIcuIndex=~removeOpCode,tIcu=state.lView[1].data[tIcuIndex];return ngDevMode&&root_effect_scheduler_assertTIcu(tIcu),enterIcu(state,tIcu,state.lView),icuContainerIteratorNext(state)}}return 0===state.stack.length?(state.lView=void 0,null):(state.removes=state.stack.pop(),state.index=state.stack.pop(),icuContainerIteratorNext(state))}function loadIcuContainerVisitor(){const _state={stack:[],index:-1};return function icuContainerIteratorStart(tIcuContainerNode,lView){for(_state.lView=lView;_state.stack.length;)_state.stack.pop();return ngDevMode&&assertTNodeForLView(tIcuContainerNode,lView),enterIcu(_state,tIcuContainerNode.value,lView),icuContainerIteratorNext.bind(null,_state)}}let _prepareI18nBlockForHydrationImpl=()=>{};let _claimDehydratedIcuCaseImpl=()=>{};function cleanupDehydratedIcuData(renderer,i18nNodes,dehydratedIcuData){for(const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]){const rNode=i18nNodes.get(node.index-27);rNode&&nativeRemoveNode(renderer,rNode,!1)}}function removeDehydratedViews(lContainer){const views=lContainer[6]??[],renderer=lContainer[3][11],retainedViews=[];for(const view of views)void 0!==view.data.di?retainedViews.push(view):(removeDehydratedView(view,renderer),ngDevMode&&ngDevMode.dehydratedViewsRemoved++);lContainer[6]=retainedViews}function removeDehydratedViewList(deferBlock){const{lContainer}=deferBlock,dehydratedViews=lContainer[6];if(null===dehydratedViews)return;const renderer=lContainer[3][11];for(const view of dehydratedViews)removeDehydratedView(view,renderer),ngDevMode&&ngDevMode.dehydratedViewsRemoved++}function removeDehydratedView(dehydratedView,renderer){let nodesRemoved=0,currentRNode=dehydratedView.firstChild;if(currentRNode){const numNodes=dehydratedView.data.r;for(;nodesRemoved<numNodes;){ngDevMode&&validateSiblingNodeExists(currentRNode);const nextSibling=currentRNode.nextSibling;nativeRemoveNode(renderer,currentRNode,!1),currentRNode=nextSibling,nodesRemoved++}}}function cleanupLContainer(lContainer){removeDehydratedViews(lContainer);const hostLView=lContainer[0];root_effect_scheduler_isLView(hostLView)&&cleanupLView(hostLView);for(let i=10;i<lContainer.length;i++)cleanupLView(lContainer[i])}function cleanupLView(lView){!function cleanupI18nHydrationData(lView){const hydrationInfo=lView[6];if(hydrationInfo){const{i18nNodes,dehydratedIcuData:dehydratedIcuDataMap}=hydrationInfo;if(i18nNodes&&dehydratedIcuDataMap){const renderer=lView[11];for(const dehydratedIcuData of dehydratedIcuDataMap.values())cleanupDehydratedIcuData(renderer,i18nNodes,dehydratedIcuData)}hydrationInfo.i18nNodes=void 0,hydrationInfo.dehydratedIcuData=void 0}}(lView);const tView=lView[1];for(let i=27;i<tView.bindingStartIndex;i++)if(root_effect_scheduler_isLContainer(lView[i])){cleanupLContainer(lView[i])}else root_effect_scheduler_isLView(lView[i])&&cleanupLView(lView[i])}function cleanupHydratedDeferBlocks(deferBlock,hydratedBlocks,registry,appRef){null!==deferBlock&&(registry.cleanup(hydratedBlocks),cleanupLContainer(deferBlock.lContainer),function debug_node_cleanupDehydratedViews(appRef){const viewRefs=appRef._views;for(const viewRef of viewRefs){const lNode=debug_node_getLNodeForHydration(viewRef);null!==lNode&&null!==lNode[0]&&(root_effect_scheduler_isLView(lNode)?cleanupLView(lNode):cleanupLContainer(lNode),ngDevMode&&ngDevMode.dehydratedViewsCleanupRuns++)}}(appRef))}let _findMatchingDehydratedViewImpl=()=>null,_findAndReconcileMatchingDehydratedViewsImpl=()=>null;function findMatchingDehydratedView(lContainer,template){return _findMatchingDehydratedViewImpl(lContainer,template)}function findAndReconcileMatchingDehydratedViews(lContainer,templateTNode,hostLView){return _findAndReconcileMatchingDehydratedViewsImpl(lContainer,templateTNode,hostLView)}let ComponentRef$1=class ComponentRef{},ComponentFactory$1=class ComponentFactory{};class _NullComponentFactoryResolver{resolveComponentFactory(component){throw new root_effect_scheduler_RuntimeError(917,"undefined"!=typeof ngDevMode&&ngDevMode&&`No component factory found for ${stringify(component)}.`)}}let ComponentFactoryResolver$1=class ComponentFactoryResolver{static NULL=new _NullComponentFactoryResolver};class RendererFactory2{}class Renderer2{destroyNode=null;static __NG_ELEMENT_ID__=()=>function injectRenderer2(){const lView=root_effect_scheduler_getLView(),nodeAtIndex=root_effect_scheduler_getComponentLViewByIndex(root_effect_scheduler_getCurrentTNode().index,lView);return(root_effect_scheduler_isLView(nodeAtIndex)?nodeAtIndex:lView)[11]}()}class Sanitizer{static ɵprov=ɵɵdefineInjectable({token:Sanitizer,providedIn:"root",factory:()=>null})}function isModuleWithProviders(value){return void 0!==value.ngModule}function isNgModule(value){return!!getNgModuleDef(value)}function isPipe(value){return!!getPipeDef(value)}function isDirective(value){return!!getDirectiveDef(value)}function isComponent(value){return!!root_effect_scheduler_getComponentDef(value)}function verifyStandaloneImport(depType,importingType){if(isForwardRef(depType)&&!(depType=resolveForwardRef(depType)))throw new Error(`Expected forwardRef function, imported from "${root_effect_scheduler_stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${root_effect_scheduler_stringifyForError(depType)||depType}".`);if(null==getNgModuleDef(depType)){const def=root_effect_scheduler_getComponentDef(depType)||getDirectiveDef(depType)||getPipeDef(depType);if(null==def)throw isModuleWithProviders(depType)?new Error(`A module with providers was imported from "${root_effect_scheduler_stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`):new Error(`The "${root_effect_scheduler_stringifyForError(depType)}" type, imported from "${root_effect_scheduler_stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);if(!def.standalone)throw new Error(`The "${root_effect_scheduler_stringifyForError(depType)}" ${function getDependencyTypeForError(type){return root_effect_scheduler_getComponentDef(type)?"component":getDirectiveDef(type)?"directive":getPipeDef(type)?"pipe":"type"}(depType)}, imported from "${root_effect_scheduler_stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`)}}function addSet(sourceSet,targetSet){for(const m of sourceSet)targetSet.add(m)}const depsTracker=new class DepsTracker{ownerNgModule=new Map;ngModulesWithSomeUnresolvedDecls=new Set;ngModulesScopeCache=new Map;standaloneComponentsScopeCache=new Map;resolveNgModulesDecls(){if(0!==this.ngModulesWithSomeUnresolvedDecls.size){for(const moduleType of this.ngModulesWithSomeUnresolvedDecls){const def=getNgModuleDef(moduleType);if(def?.declarations)for(const decl of maybeUnwrapFn(def.declarations))isComponent(decl)&&this.ownerNgModule.set(decl,moduleType)}this.ngModulesWithSomeUnresolvedDecls.clear()}}getComponentDependencies(type,rawImports){this.resolveNgModulesDecls();const def=root_effect_scheduler_getComponentDef(type);if(null===def)throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);if(def.standalone){const scope=this.getStandaloneComponentScope(type,rawImports);return scope.compilation.isPoisoned?{dependencies:[]}:{dependencies:[...scope.compilation.directives,...scope.compilation.pipes,...scope.compilation.ngModules]}}{if(!this.ownerNgModule.has(type))return{dependencies:[]};const scope=this.getNgModuleScope(this.ownerNgModule.get(type));return scope.compilation.isPoisoned?{dependencies:[]}:{dependencies:[...scope.compilation.directives,...scope.compilation.pipes]}}}registerNgModule(type,scopeInfo){if(!isNgModule(type))throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);this.ngModulesWithSomeUnresolvedDecls.add(type)}clearScopeCacheFor(type){this.ngModulesScopeCache.delete(type),this.standaloneComponentsScopeCache.delete(type)}getNgModuleScope(type){if(this.ngModulesScopeCache.has(type))return this.ngModulesScopeCache.get(type);const scope=this.computeNgModuleScope(type);return this.ngModulesScopeCache.set(type,scope),scope}computeNgModuleScope(type){const def=getNgModuleDefOrThrow(type),scope={exported:{directives:new Set,pipes:new Set},compilation:{directives:new Set,pipes:new Set}};for(const imported of maybeUnwrapFn(def.imports))if(isNgModule(imported)){const importedScope=this.getNgModuleScope(imported);addSet(importedScope.exported.directives,scope.compilation.directives),addSet(importedScope.exported.pipes,scope.compilation.pipes)}else{if(!isStandalone(imported)){scope.compilation.isPoisoned=!0;break}if(isDirective(imported)||isComponent(imported))scope.compilation.directives.add(imported);else{if(!isPipe(imported))throw new root_effect_scheduler_RuntimeError(980,"The standalone imported type is neither a component nor a directive nor a pipe");scope.compilation.pipes.add(imported)}}if(!scope.compilation.isPoisoned)for(const decl of maybeUnwrapFn(def.declarations)){if(isNgModule(decl)||isStandalone(decl)){scope.compilation.isPoisoned=!0;break}isPipe(decl)?scope.compilation.pipes.add(decl):scope.compilation.directives.add(decl)}for(const exported of maybeUnwrapFn(def.exports))if(isNgModule(exported)){const exportedScope=this.getNgModuleScope(exported);addSet(exportedScope.exported.directives,scope.exported.directives),addSet(exportedScope.exported.pipes,scope.exported.pipes),addSet(exportedScope.exported.directives,scope.compilation.directives),addSet(exportedScope.exported.pipes,scope.compilation.pipes)}else isPipe(exported)?scope.exported.pipes.add(exported):scope.exported.directives.add(exported);return scope}getStandaloneComponentScope(type,rawImports){if(this.standaloneComponentsScopeCache.has(type))return this.standaloneComponentsScopeCache.get(type);const ans=this.computeStandaloneComponentScope(type,rawImports);return this.standaloneComponentsScopeCache.set(type,ans),ans}computeStandaloneComponentScope(type,rawImports){const ans={compilation:{directives:new Set([type]),pipes:new Set,ngModules:new Set}};for(const rawImport of flatten(rawImports??[])){const imported=resolveForwardRef(rawImport);try{verifyStandaloneImport(imported,type)}catch(e){return ans.compilation.isPoisoned=!0,ans}if(isNgModule(imported)){ans.compilation.ngModules.add(imported);const importedScope=this.getNgModuleScope(imported);if(importedScope.exported.isPoisoned)return ans.compilation.isPoisoned=!0,ans;addSet(importedScope.exported.directives,ans.compilation.directives),addSet(importedScope.exported.pipes,ans.compilation.pipes)}else if(isPipe(imported))ans.compilation.pipes.add(imported);else{if(!isDirective(imported)&&!isComponent(imported))return ans.compilation.isPoisoned=!0,ans;ans.compilation.directives.add(imported)}}return ans}isOrphanComponent(cmp){const def=root_effect_scheduler_getComponentDef(cmp);return!(!def||def.standalone)&&(this.resolveNgModulesDecls(),!this.ownerNgModule.has(cmp))}},NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR={};class ChainedInjector{injector;parentInjector;constructor(injector,parentInjector){this.injector=injector,this.parentInjector=parentInjector}get(token,notFoundValue,options){const value=this.injector.get(token,NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,options);return value!==NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR||notFoundValue===NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR?value:this.parentInjector.get(token,notFoundValue,options)}}function computeStaticStyling(tNode,attrs,writeToHost){ngDevMode&&assertFirstCreatePass(getTView(),"Expecting to be called in first template pass only");let styles=writeToHost?tNode.styles:null,classes=writeToHost?tNode.classes:null,mode=0;if(null!==attrs)for(let i=0;i<attrs.length;i++){const value=attrs[i];if("number"==typeof value)mode=value;else if(1==mode)classes=concatStringsWithSpace(classes,value);else if(2==mode){styles=concatStringsWithSpace(styles,value+": "+attrs[++i]+";")}}writeToHost?tNode.styles=styles:tNode.stylesWithoutHost=styles,writeToHost?tNode.classes=classes:tNode.classesWithoutHost=classes}function ɵɵdirectiveInject(token,flags=0){const lView=root_effect_scheduler_getLView();if(null===lView)return ngDevMode&&function assertInjectImplementationNotEqual(fn){ngDevMode&&root_effect_scheduler_assertNotEqual(_injectImplementation,fn,"Calling ɵɵinject would cause infinite recursion")}(ɵɵdirectiveInject),ɵɵinject(token,flags);const value=getOrCreateInjectable(root_effect_scheduler_getCurrentTNode(),lView,resolveForwardRef(token),flags);return ngDevMode&&emitInjectEvent(token,value,flags),value}function ɵɵinvalidFactory(){const msg=ngDevMode?"This constructor was not compatible with Dependency Injection.":"invalid";throw new Error(msg)}function resolveDirectives(tView,lView,tNode,localRefs,directiveMatcher){ngDevMode&&assertFirstCreatePass(tView);const exportsMap=null===localRefs?null:{"":-1},matchedDirectiveDefs=directiveMatcher(tView,tNode);if(null!==matchedDirectiveDefs){let directiveDefs=matchedDirectiveDefs,hostDirectiveDefs=null,hostDirectiveRanges=null;for(const def of matchedDirectiveDefs)if(null!==def.resolveHostDirectives){[directiveDefs,hostDirectiveDefs,hostDirectiveRanges]=def.resolveHostDirectives(matchedDirectiveDefs);break}ngDevMode&&function assertNoDuplicateDirectives(directives){if(directives.length<2)return;const seenDirectives=new Set;for(const current of directives){if(seenDirectives.has(current))throw new root_effect_scheduler_RuntimeError(309,`Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);seenDirectives.add(current)}}(directiveDefs),function initializeDirectives(tView,lView,tNode,directives,exportsMap,hostDirectiveDefs,hostDirectiveRanges){ngDevMode&&assertFirstCreatePass(tView);const directivesLength=directives.length;let hasSeenComponent=!1;for(let i=0;i<directivesLength;i++){const def=directives[i];!hasSeenComponent&&isComponentDef(def)&&(hasSeenComponent=!0,markAsComponentHost(tView,tNode,i)),diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,def.type)}!function initTNodeFlags(tNode,index,numberOfDirectives){ngDevMode&&root_effect_scheduler_assertNotEqual(numberOfDirectives,tNode.directiveEnd-tNode.directiveStart,"Reached the max number of directives"),tNode.flags|=1,tNode.directiveStart=index,tNode.directiveEnd=index+numberOfDirectives,tNode.providerIndexes=index}(tNode,tView.data.length,directivesLength);for(let i=0;i<directivesLength;i++){const def=directives[i];def.providersResolver&&def.providersResolver(def)}let preOrderHooksFound=!1,preOrderCheckHooksFound=!1,directiveIdx=allocExpando(tView,lView,directivesLength,null);ngDevMode&&assertSame(directiveIdx,tNode.directiveStart,"TNode.directiveStart should point to just allocated space"),directivesLength>0&&(tNode.directiveToIndex=new Map);for(let i=0;i<directivesLength;i++){const def=directives[i];if(tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs),configureViewWithDirective(tView,tNode,lView,directiveIdx,def),saveNameToExportMap(directiveIdx,def,exportsMap),null!==hostDirectiveRanges&&hostDirectiveRanges.has(def)){const[start,end]=hostDirectiveRanges.get(def);tNode.directiveToIndex.set(def.type,[directiveIdx,start+tNode.directiveStart,end+tNode.directiveStart])}else null!==hostDirectiveDefs&&hostDirectiveDefs.has(def)||tNode.directiveToIndex.set(def.type,directiveIdx);null!==def.contentQueries&&(tNode.flags|=4),null===def.hostBindings&&null===def.hostAttrs&&0===def.hostVars||(tNode.flags|=64);const lifeCycleHooks=def.type.prototype;!preOrderHooksFound&&(lifeCycleHooks.ngOnChanges||lifeCycleHooks.ngOnInit||lifeCycleHooks.ngDoCheck)&&((tView.preOrderHooks??=[]).push(tNode.index),preOrderHooksFound=!0),preOrderCheckHooksFound||!lifeCycleHooks.ngOnChanges&&!lifeCycleHooks.ngDoCheck||((tView.preOrderCheckHooks??=[]).push(tNode.index),preOrderCheckHooksFound=!0),directiveIdx++}!function initializeInputAndOutputAliases(tView,tNode,hostDirectiveDefs){ngDevMode&&assertFirstCreatePass(tView);for(let index=tNode.directiveStart;index<tNode.directiveEnd;index++){const directiveDef=tView.data[index];if(null!==hostDirectiveDefs&&hostDirectiveDefs.has(directiveDef)){const hostDirectiveDef=hostDirectiveDefs.get(directiveDef);setupHostDirectiveInputsOrOutputs(0,tNode,hostDirectiveDef,index),setupHostDirectiveInputsOrOutputs(1,tNode,hostDirectiveDef,index),setupInitialInputs(tNode,index,!0)}else setupSelectorMatchedInputsOrOutputs(0,tNode,directiveDef,index),setupSelectorMatchedInputsOrOutputs(1,tNode,directiveDef,index),setupInitialInputs(tNode,index,!1)}}(tView,tNode,hostDirectiveDefs)}(tView,lView,tNode,directiveDefs,exportsMap,hostDirectiveDefs,hostDirectiveRanges)}null!==exportsMap&&null!==localRefs&&function cacheMatchingLocalNames(tNode,localRefs,exportsMap){const localNames=tNode.localNames=[];for(let i=0;i<localRefs.length;i+=2){const index=exportsMap[localRefs[i+1]];if(null==index)throw new root_effect_scheduler_RuntimeError(-301,ngDevMode&&`Export of name '${localRefs[i+1]}' not found!`);localNames.push(localRefs[i],index)}}(tNode,localRefs,exportsMap)}function markAsComponentHost(tView,hostTNode,componentOffset){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&assertGreaterThan(componentOffset,-1,"componentOffset must be great than -1"),hostTNode.componentOffset=componentOffset,(tView.components??=[]).push(hostTNode.index)}function setupSelectorMatchedInputsOrOutputs(mode,tNode,def,directiveIndex){const aliasMap=0===mode?def.inputs:def.outputs;for(const publicName in aliasMap)if(aliasMap.hasOwnProperty(publicName)){let bindings;bindings=0===mode?tNode.inputs??={}:tNode.outputs??={},bindings[publicName]??=[],bindings[publicName].push(directiveIndex),setShadowStylingInputFlags(tNode,publicName)}}function setupHostDirectiveInputsOrOutputs(mode,tNode,config,directiveIndex){const aliasMap=0===mode?config.inputs:config.outputs;for(const initialName in aliasMap)if(aliasMap.hasOwnProperty(initialName)){const publicName=aliasMap[initialName];let bindings;bindings=0===mode?tNode.hostDirectiveInputs??={}:tNode.hostDirectiveOutputs??={},bindings[publicName]??=[],bindings[publicName].push(directiveIndex,initialName),setShadowStylingInputFlags(tNode,publicName)}}function setShadowStylingInputFlags(tNode,publicName){"class"===publicName?tNode.flags|=8:"style"===publicName&&(tNode.flags|=16)}function setupInitialInputs(tNode,directiveIndex,isHostDirective){const{attrs,inputs,hostDirectiveInputs}=tNode;if(null===attrs||!isHostDirective&&null===inputs||isHostDirective&&null===hostDirectiveInputs||isInlineTemplate(tNode))return tNode.initialInputs??=[],void tNode.initialInputs.push(null);let inputsToStore=null,i=0;for(;i<attrs.length;){const attrName=attrs[i];if(0!==attrName)if(5!==attrName){if("number"==typeof attrName)break;if(!isHostDirective&&inputs.hasOwnProperty(attrName)){const inputConfig=inputs[attrName];for(const index of inputConfig)if(index===directiveIndex){inputsToStore??=[],inputsToStore.push(attrName,attrs[i+1]);break}}else if(isHostDirective&&hostDirectiveInputs.hasOwnProperty(attrName)){const config=hostDirectiveInputs[attrName];for(let j=0;j<config.length;j+=2)if(config[j]===directiveIndex){inputsToStore??=[],inputsToStore.push(config[j+1],attrs[i+1]);break}}i+=2}else i+=2;else i+=4}tNode.initialInputs??=[],tNode.initialInputs.push(inputsToStore)}function configureViewWithDirective(tView,tNode,lView,directiveIndex,def){ngDevMode&&assertGreaterThanOrEqual(directiveIndex,27,"Must be in Expando section"),tView.data[directiveIndex]=def;const directiveFactory=def.factory||(def.factory=getFactoryDef(def.type,!0)),nodeInjectorFactory=new NodeInjectorFactory(directiveFactory,isComponentDef(def),ɵɵdirectiveInject,ngDevMode?def.type.name:null);tView.blueprint[directiveIndex]=nodeInjectorFactory,lView[directiveIndex]=nodeInjectorFactory,function registerHostBindingOpCodes(tView,tNode,directiveIdx,directiveVarsIdx,def){ngDevMode&&assertFirstCreatePass(tView);const hostBindings=def.hostBindings;if(hostBindings){let hostBindingOpCodes=tView.hostBindingOpCodes;null===hostBindingOpCodes&&(hostBindingOpCodes=tView.hostBindingOpCodes=[]);const elementIndx=~tNode.index;(function lastSelectedElementIdx(hostBindingOpCodes){let i=hostBindingOpCodes.length;for(;i>0;){const value=hostBindingOpCodes[--i];if("number"==typeof value&&value<0)return value}return 0})(hostBindingOpCodes)!=elementIndx&&hostBindingOpCodes.push(elementIndx),hostBindingOpCodes.push(directiveIdx,directiveVarsIdx,hostBindings)}}(tView,tNode,directiveIndex,allocExpando(tView,lView,def.hostVars,NO_CHANGE),def)}function saveNameToExportMap(directiveIdx,def,exportsMap){if(exportsMap){if(def.exportAs)for(let i=0;i<def.exportAs.length;i++)exportsMap[def.exportAs[i]]=directiveIdx;isComponentDef(def)&&(exportsMap[""]=directiveIdx)}}function directiveHostFirstCreatePass(index,lView,type,name,directiveMatcher,bindingsEnabled,attrsIndex,localRefsIndex){const tView=lView[1];ngDevMode&&assertFirstCreatePass(tView);const tViewConsts=tView.consts,tNode=getOrCreateTNode(tView,index,type,name,getConstant(tViewConsts,attrsIndex));return bindingsEnabled&&resolveDirectives(tView,lView,tNode,getConstant(tViewConsts,localRefsIndex),directiveMatcher),tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,tNode.attrs),null!==tNode.attrs&&computeStaticStyling(tNode,tNode.attrs,!1),null!==tNode.mergedAttrs&&computeStaticStyling(tNode,tNode.mergedAttrs,!0),null!==tView.queries&&tView.queries.elementStart(tView,tNode),tNode}function directiveHostEndFirstCreatePass(tView,tNode){ngDevMode&&assertFirstCreatePass(tView),registerPostOrderHooks(tView,tNode),isContentQueryHost(tNode)&&tView.queries.elementEnd(tNode)}function domOnlyFirstCreatePass(index,tView,type,name,attrsIndex,localRefsIndex){ngDevMode&&assertFirstCreatePass(tView);const tViewConsts=tView.consts,tNode=getOrCreateTNode(tView,index,type,name,getConstant(tViewConsts,attrsIndex));if(tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,tNode.attrs),null!=localRefsIndex){const refs=getConstant(tViewConsts,localRefsIndex);tNode.localNames=[];for(let i=0;i<refs.length;i+=2)tNode.localNames.push(refs[i],-1)}return null!==tNode.attrs&&computeStaticStyling(tNode,tNode.attrs,!1),null!==tNode.mergedAttrs&&computeStaticStyling(tNode,tNode.mergedAttrs,!0),null!==tView.queries&&tView.queries.elementStart(tView,tNode),tNode}function isListLikeIterable(obj){return!!isJsObject(obj)&&(Array.isArray(obj)||!(obj instanceof Map)&&Symbol.iterator in obj)}function isJsObject(o){return null!==o&&("function"==typeof o||"object"==typeof o)}function devModeEqual(a,b){const isListLikeIterableA=isListLikeIterable(a),isListLikeIterableB=isListLikeIterable(b);if(isListLikeIterableA&&isListLikeIterableB)return function areIterablesEqual(a,b,comparator){const iterator1=a[Symbol.iterator](),iterator2=b[Symbol.iterator]();for(;;){const item1=iterator1.next(),item2=iterator2.next();if(item1.done&&item2.done)return!0;if(item1.done||item2.done)return!1;if(!comparator(item1.value,item2.value))return!1}}(a,b,devModeEqual);return!(isListLikeIterableA||!(a&&("object"==typeof a||"function"==typeof a))||isListLikeIterableB||!(b&&("object"==typeof b||"function"==typeof b)))||Object.is(a,b)}function updateBinding(lView,bindingIndex,value){return lView[bindingIndex]=value}function getBinding(lView,bindingIndex){return ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,bindingIndex),ngDevMode&&assertNotSame(lView[bindingIndex],NO_CHANGE,"Stored value should never be NO_CHANGE."),lView[bindingIndex]}function bindingUpdated(lView,bindingIndex,value){if(ngDevMode&&assertLessThan(bindingIndex,lView.length,"Slot should have been initialized to NO_CHANGE"),value===NO_CHANGE)return!1;const oldValue=lView[bindingIndex];if(Object.is(oldValue,value))return!1;if(ngDevMode&&isInCheckNoChangesMode()){const oldValueToCompare=oldValue!==NO_CHANGE?oldValue:void 0;if(!devModeEqual(oldValueToCompare,value)){const details=function getExpressionChangedErrorDetails(lView,bindingIndex,oldValue,newValue){const tData=lView[1].data,metadata=tData[bindingIndex];if("string"==typeof metadata)return metadata.indexOf("�")>-1?constructDetailsForInterpolation(lView,bindingIndex,bindingIndex,metadata,newValue):{propName:metadata,oldValue,newValue};if(null===metadata){let idx=bindingIndex-1;for(;"string"!=typeof tData[idx]&&null===tData[idx+1];)idx--;const meta=tData[idx];if("string"==typeof meta){const matches=meta.match(new RegExp("�","g"));if(matches&&matches.length-1>bindingIndex-idx)return constructDetailsForInterpolation(lView,idx,bindingIndex,meta,newValue)}}return{propName:void 0,oldValue,newValue}}(lView,bindingIndex,oldValueToCompare,value);!function throwErrorIfNoChangesMode(creationMode,oldValue,currValue,propName,lView){const hostComponentDef=getDeclarationComponentDef(lView),componentClassName=hostComponentDef?.type?.name;let msg=`ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${propName?` for '${propName}'`:""}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName?` Expression location: ${componentClassName} component`:""}`;throw creationMode&&(msg+=" It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?"),new root_effect_scheduler_RuntimeError(-100,msg)}(oldValue===NO_CHANGE,details.oldValue,details.newValue,details.propName,lView)}return!1}return lView[bindingIndex]=value,!0}function bindingUpdated2(lView,bindingIndex,exp1,exp2){const different=bindingUpdated(lView,bindingIndex,exp1);return bindingUpdated(lView,bindingIndex+1,exp2)||different}function bindingUpdated3(lView,bindingIndex,exp1,exp2,exp3){const different=bindingUpdated2(lView,bindingIndex,exp1,exp2);return bindingUpdated(lView,bindingIndex+2,exp3)||different}function bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4){const different=bindingUpdated2(lView,bindingIndex,exp1,exp2);return bindingUpdated2(lView,bindingIndex+2,exp3,exp4)||different}function wrapListener(tNode,lView,listenerFn){return function wrapListenerIn_markDirtyAndPreventDefault(event){markViewDirty(root_effect_scheduler_isComponentHost(tNode)?root_effect_scheduler_getComponentLViewByIndex(tNode.index,lView):lView,5);const context=lView[8];let result=executeListenerWithErrorHandling(lView,context,listenerFn,event),nextListenerFn=wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;for(;nextListenerFn;)result=executeListenerWithErrorHandling(lView,context,nextListenerFn,event)&&result,nextListenerFn=nextListenerFn.__ngNextListenerFn__;return result}}function executeListenerWithErrorHandling(lView,context,listenerFn,e){const prevConsumer=setActiveConsumer(null);try{return debug_node_profiler(6,context,listenerFn),!1!==listenerFn(e)}catch(error){return handleUncaughtError(lView,error),!1}finally{debug_node_profiler(7,context,listenerFn),setActiveConsumer(prevConsumer)}}function listenToDomEvent(tNode,tView,lView,eventTargetResolver,renderer,eventName,originalListener,wrappedListener){ngDevMode&&assertNotSame(wrappedListener,originalListener,"Expected wrapped and original listeners to be different.");const isTNodeDirectiveHost=isDirectiveHost(tNode);let hasCoalesced=!1,existingListener=null;if(!eventTargetResolver&&isTNodeDirectiveHost&&(existingListener=function findExistingListener(tView,lView,eventName,tNodeIndex){const tCleanup=tView.cleanup;if(null!=tCleanup)for(let i=0;i<tCleanup.length-1;i+=2){const cleanupEventName=tCleanup[i];if(cleanupEventName===eventName&&tCleanup[i+1]===tNodeIndex){const lCleanup=lView[7],listenerIdxInLCleanup=tCleanup[i+2];return lCleanup&&lCleanup.length>listenerIdxInLCleanup?lCleanup[listenerIdxInLCleanup]:null}"string"==typeof cleanupEventName&&(i+=2)}return null}(tView,lView,eventName,tNode.index)),null!==existingListener){(existingListener.__ngLastListenerFn__||existingListener).__ngNextListenerFn__=originalListener,existingListener.__ngLastListenerFn__=originalListener,hasCoalesced=!0}else{const native=root_effect_scheduler_getNativeByTNode(tNode,lView),target=eventTargetResolver?eventTargetResolver(native):native;!function stashEventListenerImpl(lView,target,eventName,wrappedListener){_stashEventListenerImpl(lView,target,eventName,wrappedListener)}(lView,target,eventName,wrappedListener);const cleanupFn=renderer.listen(target,eventName,wrappedListener);if(!function isAnimationEventType(eventName){return eventName.startsWith("animation")||eventName.startsWith("transition")}(eventName)){storeListenerCleanup(eventTargetResolver?_lView=>eventTargetResolver(root_effect_scheduler_unwrapRNode(_lView[tNode.index])):tNode.index,tView,lView,eventName,wrappedListener,cleanupFn,!1)}}return hasCoalesced}function storeListenerCleanup(indexOrTargetGetter,tView,lView,eventName,listenerFn,cleanup,isOutput){const tCleanup=tView.firstCreatePass?getOrCreateTViewCleanup(tView):null,lCleanup=getOrCreateLViewCleanup(lView),index=lCleanup.length;lCleanup.push(listenerFn,cleanup),tCleanup&&tCleanup.push(eventName,indexOrTargetGetter,index,(index+1)*(isOutput?-1:1))}function listenToOutput(tNode,lView,directiveIndex,lookupName,eventName,listenerFn){ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,directiveIndex);const instance=lView[directiveIndex],tView=lView[1],propertyName=tView.data[directiveIndex].outputs[lookupName],output=instance[propertyName];if(ngDevMode&&!function isOutputSubscribable(value){return null!=value&&"function"==typeof value.subscribe}(output))throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);const subscription=output.subscribe(listenerFn);storeListenerCleanup(tNode.index,tView,lView,eventName,listenerFn,subscription,!0)}const BINDING=Symbol("BINDING");class ComponentFactoryResolver extends ComponentFactoryResolver$1{ngModule;constructor(ngModule){super(),this.ngModule=ngModule}resolveComponentFactory(component){ngDevMode&&function assertComponentType(actual,msg="Type passed in is not ComponentType, it does not have 'ɵcmp' property."){root_effect_scheduler_getComponentDef(actual)||throwError(msg)}(component);const componentDef=root_effect_scheduler_getComponentDef(component);return new debug_node_ComponentFactory(componentDef,this.ngModule)}}function verifyNotAnOrphanComponent(componentDef){if(("undefined"==typeof ngJitMode||ngJitMode)&&componentDef.debugInfo?.forbidOrphanRendering&&depsTracker.isOrphanComponent(componentDef.type))throw new root_effect_scheduler_RuntimeError(981,`Orphan component found! Trying to render the component ${function debugStringifyTypeForError(type){let componentDef=type[NG_COMP_DEF]||null;return null!==componentDef&&componentDef.debugInfo?function stringifyTypeFromDebugInfo(debugInfo){return debugInfo.filePath&&debugInfo.lineNumber?`${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`:debugInfo.className}(componentDef.debugInfo):root_effect_scheduler_stringifyForError(type)}(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`)}class debug_node_ComponentFactory extends ComponentFactory$1{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;cachedInputs=null;cachedOutputs=null;get inputs(){return this.cachedInputs??=function toInputRefArray(map){return Object.keys(map).map(name=>{const[propName,flags,transform]=map[name],inputData={propName,templateName:name,isSignal:0!==(flags&InputFlags.SignalBased)};return transform&&(inputData.transform=transform),inputData})}(this.componentDef.inputs),this.cachedInputs}get outputs(){return this.cachedOutputs??=function toOutputRefArray(map){return Object.keys(map).map(name=>({propName:map[name],templateName:name}))}(this.componentDef.outputs),this.cachedOutputs}constructor(componentDef,ngModule){super(),this.componentDef=componentDef,this.ngModule=ngModule,this.componentType=componentDef.type,this.selector=stringifyCSSSelectorList(componentDef.selectors),this.ngContentSelectors=componentDef.ngContentSelectors??[],this.isBoundToModule=!!ngModule}create(injector,projectableNodes,rootSelectorOrNode,environmentInjector,directives,componentBindings){debug_node_profiler(22);const prevConsumer=setActiveConsumer(null);try{const cmpDef=this.componentDef;ngDevMode&&verifyNotAnOrphanComponent(cmpDef);const rootTView=function createRootTView(rootSelectorOrNode,componentDef,componentBindings,directives){const tAttributes=rootSelectorOrNode?["ng-version","20.3.11"]:function extractAttrsAndClassesFromSelector(selector){const attrs=[],classes=[];let i=1,mode=2;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)2===mode?""!==valueOrMarker&&attrs.push(valueOrMarker,selector[++i]):8===mode&&classes.push(valueOrMarker);else{if(!isPositive(mode))break;mode=valueOrMarker}i++}return classes.length&&attrs.push(1,...classes),attrs}(componentDef.selectors[0]);let creationBindings=null,updateBindings=null,varsToAllocate=0;if(componentBindings)for(const binding of componentBindings)varsToAllocate+=binding[BINDING].requiredVars,binding.create&&(binding.targetIdx=0,(creationBindings??=[]).push(binding)),binding.update&&(binding.targetIdx=0,(updateBindings??=[]).push(binding));if(directives)for(let i=0;i<directives.length;i++){const directive=directives[i];if("function"!=typeof directive)for(const binding of directive.bindings){varsToAllocate+=binding[BINDING].requiredVars;const targetDirectiveIdx=i+1;binding.create&&(binding.targetIdx=targetDirectiveIdx,(creationBindings??=[]).push(binding)),binding.update&&(binding.targetIdx=targetDirectiveIdx,(updateBindings??=[]).push(binding))}}const directivesToApply=[componentDef];if(directives)for(const directive of directives){const directiveType="function"==typeof directive?directive:directive.type,directiveDef=ngDevMode?getDirectiveDefOrThrow(directiveType):getDirectiveDef(directiveType);if(ngDevMode&&!directiveDef.standalone)throw new root_effect_scheduler_RuntimeError(907,`The ${root_effect_scheduler_stringifyForError(directiveType)} directive must be standalone in order to be applied to a dynamically-created component.`);directivesToApply.push(directiveDef)}const rootTView=createTView(0,null,function getRootTViewTemplate(creationBindings,updateBindings){if(!creationBindings&&!updateBindings)return null;return flags=>{if(1&flags&&creationBindings)for(const binding of creationBindings)binding.create();if(2&flags&&updateBindings)for(const binding of updateBindings)binding.update()}}(creationBindings,updateBindings),1,varsToAllocate,directivesToApply,null,null,null,[tAttributes],null);return rootTView}(rootSelectorOrNode,cmpDef,componentBindings,directives),rootViewInjector=function createRootViewInjector(componentDef,environmentInjector,injector){let realEnvironmentInjector=environmentInjector instanceof EnvironmentInjector?environmentInjector:environmentInjector?.injector;return realEnvironmentInjector&&null!==componentDef.getStandaloneInjector&&(realEnvironmentInjector=componentDef.getStandaloneInjector(realEnvironmentInjector)||realEnvironmentInjector),realEnvironmentInjector?new ChainedInjector(injector,realEnvironmentInjector):injector}(cmpDef,environmentInjector||this.ngModule,injector),environment=function createRootLViewEnvironment(rootLViewInjector){const rendererFactory=rootLViewInjector.get(RendererFactory2,null);if(null===rendererFactory)throw new root_effect_scheduler_RuntimeError(407,ngDevMode&&"Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");const sanitizer=rootLViewInjector.get(Sanitizer,null),changeDetectionScheduler=rootLViewInjector.get(root_effect_scheduler_ChangeDetectionScheduler,null);let ngReflect=!1;return("undefined"==typeof ngDevMode||ngDevMode)&&(ngReflect=rootLViewInjector.get(NG_REFLECT_ATTRS_FLAG,!1)),{rendererFactory,sanitizer,changeDetectionScheduler,ngReflect}}(rootViewInjector),hostRenderer=environment.rendererFactory.createRenderer(null,cmpDef),hostElement=rootSelectorOrNode?locateHostElement(hostRenderer,rootSelectorOrNode,cmpDef.encapsulation,rootViewInjector):function createHostElement(componentDef,renderer){const tagName=function inferTagNameFromDefinition(componentDef){return(componentDef.selectors[0][0]||"div").toLowerCase()}(componentDef);return createElementNode(renderer,tagName,"svg"===tagName?"svg":"math"===tagName?"math":null)}(cmpDef,hostRenderer),hasInputBindings=componentBindings?.some(isInputBinding)||directives?.some(d=>"function"!=typeof d&&d.bindings.some(isInputBinding)),rootLView=createLView(null,rootTView,null,512|getInitialLViewFlagsFromDef(cmpDef),null,null,environment,hostRenderer,rootViewInjector,null,retrieveHydrationInfo(hostElement,rootViewInjector,!0));rootLView[27]=hostElement,enterView(rootLView);let componentView=null;try{const hostTNode=directiveHostFirstCreatePass(27,rootLView,2,"#host",()=>rootTView.directiveRegistry,!0,0);setupStaticAttributes(hostRenderer,hostElement,hostTNode),attachPatchData(hostElement,rootLView),createDirectivesInstances(rootTView,rootLView,hostTNode),executeContentQueries(rootTView,hostTNode,rootLView),directiveHostEndFirstCreatePass(rootTView,hostTNode),void 0!==projectableNodes&&function projectNodes(tNode,ngContentSelectors,projectableNodes){const projection=tNode.projection=[];for(let i=0;i<ngContentSelectors.length;i++){const nodesforSlot=projectableNodes[i];projection.push(null!=nodesforSlot&&nodesforSlot.length?Array.from(nodesforSlot):null)}}(hostTNode,this.ngContentSelectors,projectableNodes),componentView=root_effect_scheduler_getComponentLViewByIndex(hostTNode.index,rootLView),rootLView[8]=componentView[8],renderView(rootTView,rootLView,null)}catch(e){throw null!==componentView&&unregisterLView(componentView),unregisterLView(rootLView),e}finally{debug_node_profiler(23),leaveView()}return new ComponentRef(this.componentType,rootLView,!!hasInputBindings)}finally{setActiveConsumer(prevConsumer)}}}function isInputBinding(binding){const kind=binding[BINDING].kind;return"input"===kind||"twoWay"===kind}class ComponentRef extends ComponentRef$1{_rootLView;_hasInputBindings;instance;hostView;changeDetectorRef;componentType;location;previousInputValues=null;_tNode;constructor(componentType,_rootLView,_hasInputBindings){super(),this._rootLView=_rootLView,this._hasInputBindings=_hasInputBindings,this._tNode=root_effect_scheduler_getTNode(_rootLView[1],27),this.location=createElementRef(this._tNode,_rootLView),this.instance=root_effect_scheduler_getComponentLViewByIndex(this._tNode.index,_rootLView)[8],this.hostView=this.changeDetectorRef=new ViewRef(_rootLView,void 0),this.componentType=componentType}setInput(name,value){if(this._hasInputBindings&&ngDevMode)throw new root_effect_scheduler_RuntimeError(317,"Cannot call `setInput` on a component that is using the `inputBinding` or `twoWayBinding` functions.");const tNode=this._tNode;if(this.previousInputValues??=new Map,this.previousInputValues.has(name)&&Object.is(this.previousInputValues.get(name),value))return;const lView=this._rootLView,hasSetInput=setAllInputsForProperty(tNode,lView[1],lView,name,value);this.previousInputValues.set(name,value);if(markViewDirty(root_effect_scheduler_getComponentLViewByIndex(tNode.index,lView),1),ngDevMode&&!hasSetInput){let message=`Can't set value of the '${name}' input on the '${root_effect_scheduler_stringifyForError(this.componentType)}' component. `;message+=`Make sure that the '${name}' property is declared as an input using the input() or model() function or the @Input() decorator.`,reportUnknownPropertyError(message)}}get injector(){return new NodeInjector(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(callback){this.hostView.onDestroy(callback)}}class ViewContainerRef{static __NG_ELEMENT_ID__=injectViewContainerRef}function injectViewContainerRef(){return createContainerRef(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView())}const VE_ViewContainerRef=ViewContainerRef,R3ViewContainerRef=class ViewContainerRef extends VE_ViewContainerRef{_lContainer;_hostTNode;_hostLView;constructor(_lContainer,_hostTNode,_hostLView){super(),this._lContainer=_lContainer,this._hostTNode=_hostTNode,this._hostLView=_hostLView}get element(){return createElementRef(this._hostTNode,this._hostLView)}get injector(){return new NodeInjector(this._hostTNode,this._hostLView)}get parentInjector(){const parentLocation=getParentInjectorLocation(this._hostTNode,this._hostLView);if(hasParentInjector(parentLocation)){const parentView=getParentInjectorView(parentLocation,this._hostLView),injectorIndex=getParentInjectorIndex(parentLocation);ngDevMode&&assertNodeInjector(parentView,injectorIndex);const parentTNode=parentView[1].data[injectorIndex+8];return new NodeInjector(parentTNode,parentView)}return new NodeInjector(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(index){const viewRefs=getViewRefs(this._lContainer);return null!==viewRefs&&viewRefs[index]||null}get length(){return this._lContainer.length-10}createEmbeddedView(templateRef,context,indexOrOptions){let index,injector;"number"==typeof indexOrOptions?index=indexOrOptions:null!=indexOrOptions&&(index=indexOrOptions.index,injector=indexOrOptions.injector);const dehydratedView=findMatchingDehydratedView(this._lContainer,templateRef.ssrId),viewRef=templateRef.createEmbeddedViewImpl(context||{},injector,dehydratedView);return this.insertImpl(viewRef,index,shouldAddViewToDom(this._hostTNode,dehydratedView)),viewRef}createComponent(componentFactoryOrType,indexOrOptions,injector,projectableNodes,environmentInjector,directives,bindings){const isComponentFactory=componentFactoryOrType&&!isType(componentFactoryOrType);let index;if(isComponentFactory)ngDevMode&&root_effect_scheduler_assertEqual("object"!=typeof indexOrOptions,!0,"It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)"),index=indexOrOptions;else{ngDevMode&&(root_effect_scheduler_assertDefined(root_effect_scheduler_getComponentDef(componentFactoryOrType),"Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator."),root_effect_scheduler_assertEqual("number"!=typeof indexOrOptions,!0,"It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead."));const options=indexOrOptions||{};ngDevMode&&options.environmentInjector&&options.ngModuleRef&&throwError("Cannot pass both environmentInjector and ngModuleRef options to createComponent()."),index=options.index,injector=options.injector,projectableNodes=options.projectableNodes,environmentInjector=options.environmentInjector||options.ngModuleRef,directives=options.directives,bindings=options.bindings}const componentFactory=isComponentFactory?componentFactoryOrType:new debug_node_ComponentFactory(root_effect_scheduler_getComponentDef(componentFactoryOrType)),contextInjector=injector||this.parentInjector;if(!environmentInjector&&null==componentFactory.ngModule){const result=(isComponentFactory?contextInjector:this.parentInjector).get(EnvironmentInjector,null);result&&(environmentInjector=result)}const componentDef=root_effect_scheduler_getComponentDef(componentFactory.componentType??{}),dehydratedView=findMatchingDehydratedView(this._lContainer,componentDef?.id??null),rNode=dehydratedView?.firstChild??null,componentRef=componentFactory.create(contextInjector,projectableNodes,rNode,environmentInjector,directives,bindings);return this.insertImpl(componentRef.hostView,index,shouldAddViewToDom(this._hostTNode,dehydratedView)),componentRef}insert(viewRef,index){return this.insertImpl(viewRef,index,!0)}insertImpl(viewRef,index,addToDOM){const lView=viewRef._lView;if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(function viewAttachedToContainer(view){return root_effect_scheduler_isLContainer(view[3])}(lView)){const prevIdx=this.indexOf(viewRef);if(-1!==prevIdx)this.detach(prevIdx);else{const prevLContainer=lView[3];ngDevMode&&root_effect_scheduler_assertEqual(root_effect_scheduler_isLContainer(prevLContainer),!0,"An attached view should have its PARENT point to a container.");const prevVCRef=new R3ViewContainerRef(prevLContainer,prevLContainer[5],prevLContainer[3]);prevVCRef.detach(prevVCRef.indexOf(viewRef))}}const adjustedIdx=this._adjustIndex(index),lContainer=this._lContainer;return addLViewToLContainer(lContainer,lView,adjustedIdx,addToDOM),viewRef.attachToViewContainerRef(),addToArray(getOrCreateViewRefs(lContainer),adjustedIdx,viewRef),viewRef}move(viewRef,newIndex){if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(viewRef,newIndex)}indexOf(viewRef){const viewRefsArr=getViewRefs(this._lContainer);return null!==viewRefsArr?viewRefsArr.indexOf(viewRef):-1}remove(index){const adjustedIdx=this._adjustIndex(index,-1),detachedView=detachView(this._lContainer,adjustedIdx);detachedView&&(removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx),destroyLView(detachedView[1],detachedView))}detach(index){const adjustedIdx=this._adjustIndex(index,-1),view=detachView(this._lContainer,adjustedIdx);return view&&null!=removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx)?new ViewRef(view):null}_adjustIndex(index,shift=0){return null==index?this.length+shift:(ngDevMode&&(assertGreaterThan(index,-1,`ViewRef index must be positive, got ${index}`),assertLessThan(index,this.length+1+shift,"index")),index)}};function getViewRefs(lContainer){return lContainer[8]}function getOrCreateViewRefs(lContainer){return lContainer[8]||(lContainer[8]=[])}function createContainerRef(hostTNode,hostLView){let lContainer;ngDevMode&&assertTNodeType(hostTNode,15);const slotValue=hostLView[hostTNode.index];return root_effect_scheduler_isLContainer(slotValue)?lContainer=slotValue:(lContainer=createLContainer(slotValue,hostLView,null,hostTNode),hostLView[hostTNode.index]=lContainer,addToEndOfViewTree(hostLView,lContainer)),_locateOrCreateAnchorNode(lContainer,hostLView,hostTNode,slotValue),new R3ViewContainerRef(lContainer,hostTNode,hostLView)}let _locateOrCreateAnchorNode=createAnchorNode,_populateDehydratedViewsInLContainer=()=>!1;function populateDehydratedViewsInLContainer(lContainer,tNode,hostLView){return _populateDehydratedViewsInLContainer(lContainer,tNode,hostLView)}function createAnchorNode(lContainer,hostLView,hostTNode,slotValue){if(lContainer[7])return;let commentNode;commentNode=8&hostTNode.type?root_effect_scheduler_unwrapRNode(slotValue):function insertAnchorNode(hostLView,hostTNode){const renderer=hostLView[11],commentNode=renderer.createComment(ngDevMode?"container":""),hostNative=root_effect_scheduler_getNativeByTNode(hostTNode,hostLView),parentOfHostNative=renderer.parentNode(hostNative);return nativeInsertBefore(renderer,parentOfHostNative,commentNode,renderer.nextSibling(hostNative),!1),commentNode}(hostLView,hostTNode),lContainer[7]=commentNode}class LQuery_{queryList;matches=null;constructor(queryList){this.queryList=queryList}clone(){return new LQuery_(this.queryList)}setDirty(){this.queryList.setDirty()}}class LQueries_{queries;constructor(queries=[]){this.queries=queries}createEmbeddedView(tView){const tQueries=tView.queries;if(null!==tQueries){const noOfInheritedQueries=null!==tView.contentQueries?tView.contentQueries[0]:tQueries.length,viewLQueries=[];for(let i=0;i<noOfInheritedQueries;i++){const tQuery=tQueries.getByIndex(i),parentLQuery=this.queries[tQuery.indexInDeclarationView];viewLQueries.push(parentLQuery.clone())}return new LQueries_(viewLQueries)}return null}insertView(tView){this.dirtyQueriesWithMatches(tView)}detachView(tView){this.dirtyQueriesWithMatches(tView)}finishViewCreation(tView){this.dirtyQueriesWithMatches(tView)}dirtyQueriesWithMatches(tView){for(let i=0;i<this.queries.length;i++)null!==getTQuery(tView,i).matches&&this.queries[i].setDirty()}}class TQueryMetadata_{flags;read;predicate;constructor(predicate,flags,read=null){this.flags=flags,this.read=read,this.predicate="string"==typeof predicate?function splitQueryMultiSelectors(locator){return locator.split(",").map(s=>s.trim())}(predicate):predicate}}class TQueries_{queries;constructor(queries=[]){this.queries=queries}elementStart(tView,tNode){ngDevMode&&assertFirstCreatePass(tView,"Queries should collect results on the first template pass only");for(let i=0;i<this.queries.length;i++)this.queries[i].elementStart(tView,tNode)}elementEnd(tNode){for(let i=0;i<this.queries.length;i++)this.queries[i].elementEnd(tNode)}embeddedTView(tNode){let queriesForTemplateRef=null;for(let i=0;i<this.length;i++){const childQueryIndex=null!==queriesForTemplateRef?queriesForTemplateRef.length:0,tqueryClone=this.getByIndex(i).embeddedTView(tNode,childQueryIndex);tqueryClone&&(tqueryClone.indexInDeclarationView=i,null!==queriesForTemplateRef?queriesForTemplateRef.push(tqueryClone):queriesForTemplateRef=[tqueryClone])}return null!==queriesForTemplateRef?new TQueries_(queriesForTemplateRef):null}template(tView,tNode){ngDevMode&&assertFirstCreatePass(tView,"Queries should collect results on the first template pass only");for(let i=0;i<this.queries.length;i++)this.queries[i].template(tView,tNode)}getByIndex(index){return ngDevMode&&root_effect_scheduler_assertIndexInRange(this.queries,index),this.queries[index]}get length(){return this.queries.length}track(tquery){this.queries.push(tquery)}}class TQuery_{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(metadata,nodeIndex=-1){this.metadata=metadata,this._declarationNodeIndex=nodeIndex}elementStart(tView,tNode){this.isApplyingToNode(tNode)&&this.matchTNode(tView,tNode)}elementEnd(tNode){this._declarationNodeIndex===tNode.index&&(this._appliesToNextNode=!1)}template(tView,tNode){this.elementStart(tView,tNode)}embeddedTView(tNode,childQueryIndex){return this.isApplyingToNode(tNode)?(this.crossesNgTemplate=!0,this.addMatch(-tNode.index,childQueryIndex),new TQuery_(this.metadata)):null}isApplyingToNode(tNode){if(this._appliesToNextNode&&1&~this.metadata.flags){const declarationNodeIdx=this._declarationNodeIndex;let parent=tNode.parent;for(;null!==parent&&8&parent.type&&parent.index!==declarationNodeIdx;)parent=parent.parent;return declarationNodeIdx===(null!==parent?parent.index:-1)}return this._appliesToNextNode}matchTNode(tView,tNode){const predicate=this.metadata.predicate;if(Array.isArray(predicate))for(let i=0;i<predicate.length;i++){const name=predicate[i];this.matchTNodeWithReadOption(tView,tNode,getIdxOfMatchingSelector(tNode,name)),this.matchTNodeWithReadOption(tView,tNode,locateDirectiveOrProvider(tNode,tView,name,!1,!1))}else predicate===TemplateRef?4&tNode.type&&this.matchTNodeWithReadOption(tView,tNode,-1):this.matchTNodeWithReadOption(tView,tNode,locateDirectiveOrProvider(tNode,tView,predicate,!1,!1))}matchTNodeWithReadOption(tView,tNode,nodeMatchIdx){if(null!==nodeMatchIdx){const read=this.metadata.read;if(null!==read)if(read===ElementRef||read===ViewContainerRef||read===TemplateRef&&4&tNode.type)this.addMatch(tNode.index,-2);else{const directiveOrProviderIdx=locateDirectiveOrProvider(tNode,tView,read,!1,!1);null!==directiveOrProviderIdx&&this.addMatch(tNode.index,directiveOrProviderIdx)}else this.addMatch(tNode.index,nodeMatchIdx)}}addMatch(tNodeIdx,matchIdx){null===this.matches?this.matches=[tNodeIdx,matchIdx]:this.matches.push(tNodeIdx,matchIdx)}}function getIdxOfMatchingSelector(tNode,selector){const localNames=tNode.localNames;if(null!==localNames)for(let i=0;i<localNames.length;i+=2)if(localNames[i]===selector)return localNames[i+1];return null}function createResultForNode(lView,tNode,matchingIdx,read){return-1===matchingIdx?function createResultByTNodeType(tNode,currentView){return 11&tNode.type?createElementRef(tNode,currentView):4&tNode.type?createTemplateRef(tNode,currentView):null}(tNode,lView):-2===matchingIdx?function createSpecialToken(lView,tNode,read){if(read===ElementRef)return createElementRef(tNode,lView);if(read===TemplateRef)return createTemplateRef(tNode,lView);if(read===ViewContainerRef)return ngDevMode&&assertTNodeType(tNode,15),createContainerRef(tNode,lView);ngDevMode&&throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`)}(lView,tNode,read):getNodeInjectable(lView,lView[1],matchingIdx,tNode)}function materializeViewResults(tView,lView,tQuery,queryIndex){const lQuery=lView[18].queries[queryIndex];if(null===lQuery.matches){const tViewData=tView.data,tQueryMatches=tQuery.matches,result=[];for(let i=0;null!==tQueryMatches&&i<tQueryMatches.length;i+=2){const matchedNodeIdx=tQueryMatches[i];if(matchedNodeIdx<0)result.push(null);else{ngDevMode&&root_effect_scheduler_assertIndexInRange(tViewData,matchedNodeIdx);const tNode=tViewData[matchedNodeIdx];result.push(createResultForNode(lView,tNode,tQueryMatches[i+1],tQuery.metadata.read))}}lQuery.matches=result}return lQuery.matches}function collectQueryResults(tView,lView,queryIndex,result){const tQuery=tView.queries.getByIndex(queryIndex),tQueryMatches=tQuery.matches;if(null!==tQueryMatches){const lViewResults=materializeViewResults(tView,lView,tQuery,queryIndex);for(let i=0;i<tQueryMatches.length;i+=2){const tNodeIdx=tQueryMatches[i];if(tNodeIdx>0)result.push(lViewResults[i/2]);else{const childQueryIndex=tQueryMatches[i+1],declarationLContainer=lView[-tNodeIdx];ngDevMode&&assertLContainer(declarationLContainer);for(let i=10;i<declarationLContainer.length;i++){const embeddedLView=declarationLContainer[i];embeddedLView[16]===embeddedLView[3]&&collectQueryResults(embeddedLView[1],embeddedLView,childQueryIndex,result)}if(null!==declarationLContainer[9]){const embeddedLViews=declarationLContainer[9];for(let i=0;i<embeddedLViews.length;i++){const embeddedLView=embeddedLViews[i];collectQueryResults(embeddedLView[1],embeddedLView,childQueryIndex,result)}}}}}return result}function loadQueryInternal(lView,queryIndex){return ngDevMode&&root_effect_scheduler_assertDefined(lView[18],"LQueries should be defined when trying to load a query"),ngDevMode&&root_effect_scheduler_assertIndexInRange(lView[18].queries,queryIndex),lView[18].queries[queryIndex].queryList}function createLQuery(tView,lView,flags){const queryList=new QueryList(!(4&~flags));!function storeCleanupWithContext(tView,lView,context,cleanupFn){const lCleanup=getOrCreateLViewCleanup(lView);ngDevMode&&root_effect_scheduler_assertDefined(context,"Cleanup context is mandatory when registering framework-level destroy hooks"),lCleanup.push(context),tView.firstCreatePass?getOrCreateTViewCleanup(tView).push(cleanupFn,lCleanup.length-1):ngDevMode&&Object.freeze(getOrCreateTViewCleanup(tView))}(tView,lView,queryList,queryList.destroy);return(lView[18]??=new LQueries_).queries.push(new LQuery_(queryList))-1}function createViewQuery(predicate,flags,read){ngDevMode&&root_effect_scheduler_assertNumber(flags,"Expecting flags");const tView=getTView();return tView.firstCreatePass&&(createTQuery(tView,new TQueryMetadata_(predicate,flags,read),-1),2&~flags||(tView.staticViewQueries=!0)),createLQuery(tView,root_effect_scheduler_getLView(),flags)}function createContentQuery(directiveIndex,predicate,flags,read){ngDevMode&&root_effect_scheduler_assertNumber(flags,"Expecting flags");const tView=getTView();if(tView.firstCreatePass){const tNode=root_effect_scheduler_getCurrentTNode();createTQuery(tView,new TQueryMetadata_(predicate,flags,read),tNode.index),function saveContentQueryAndDirectiveIndex(tView,directiveIndex){const tViewContentQueries=tView.contentQueries||(tView.contentQueries=[]),lastSavedDirectiveIndex=tViewContentQueries.length?tViewContentQueries[tViewContentQueries.length-1]:-1;directiveIndex!==lastSavedDirectiveIndex&&tViewContentQueries.push(tView.queries.length-1,directiveIndex)}(tView,directiveIndex),2&~flags||(tView.staticContentQueries=!0)}return createLQuery(tView,root_effect_scheduler_getLView(),flags)}function createTQuery(tView,metadata,nodeIndex){null===tView.queries&&(tView.queries=new TQueries_),tView.queries.track(new TQuery_(metadata,nodeIndex))}function getTQuery(tView,index){return ngDevMode&&root_effect_scheduler_assertDefined(tView.queries,"TQueries must be defined to retrieve a TQuery"),tView.queries.getByIndex(index)}function getQueryResults(lView,queryIndex){const tView=lView[1],tQuery=getTQuery(tView,queryIndex);return tQuery.crossesNgTemplate?collectQueryResults(tView,lView,queryIndex,[]):materializeViewResults(tView,lView,tQuery,queryIndex)}function createQuerySignalFn(firstOnly,required,opts){let node;const signalFn=createComputed(()=>{node._dirtyCounter();const value=function refreshSignalQuery(node,firstOnly){const lView=node._lView,queryIndex=node._queryIndex;if(void 0===lView||void 0===queryIndex||4&lView[2])return firstOnly?void 0:EMPTY_ARRAY;const queryList=loadQueryInternal(lView,queryIndex),results=getQueryResults(lView,queryIndex);if(queryList.reset(results,unwrapElementRef),firstOnly)return queryList.first;return queryList._changesDetected||void 0===node._flatValue?node._flatValue=queryList.toArray():node._flatValue}(node,firstOnly);if(required&&void 0===value)throw new root_effect_scheduler_RuntimeError(-951,ngDevMode&&"Child query result is required but no value is available.");return value});return node=signalFn[SIGNAL],node._dirtyCounter=root_effect_scheduler_signal(0),node._flatValue=void 0,ngDevMode&&(signalFn.toString=()=>"[Query Signal]",node.debugName=opts?.debugName),signalFn}function createSingleResultOptionalQuerySignalFn(opts){return createQuerySignalFn(!0,!1,opts)}function createSingleResultRequiredQuerySignalFn(opts){return createQuerySignalFn(!0,!0,opts)}function bindQueryToSignal(target,queryIndex){const node=target[SIGNAL];node._lView=root_effect_scheduler_getLView(),node._queryIndex=queryIndex,node._queryList=loadQueryInternal(node._lView,queryIndex),node._queryList.onDirty(()=>node._dirtyCounter.update(v=>v+1))}function resolveComponentResources(resourceResolver){const componentResolved=[],urlMap=new Map;function cachedResourceResolve(url){let promise=urlMap.get(url);if(!promise){const resp=resourceResolver(url);urlMap.set(url,promise=resp.then(res=>function unwrapResponse(url,response){if("string"==typeof response)return response;if(void 0!==response.status&&200!==response.status)return Promise.reject(new root_effect_scheduler_RuntimeError(918,ngDevMode&&`Could not load resource: ${url}. Response status: ${response.status}`));return response.text()}(url,res)))}return promise}return componentResourceResolutionQueue.forEach((component,type)=>{const promises=[];component.templateUrl&&promises.push(cachedResourceResolve(component.templateUrl).then(template=>{component.template=template}));const styles="string"==typeof component.styles?[component.styles]:component.styles||[];if(component.styles=styles,component.styleUrl&&component.styleUrls?.length)throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");if(component.styleUrls?.length){const styleOffset=component.styles.length,styleUrls=component.styleUrls;component.styleUrls.forEach((styleUrl,index)=>{styles.push(""),promises.push(cachedResourceResolve(styleUrl).then(style=>{styles[styleOffset+index]=style,styleUrls.splice(styleUrls.indexOf(styleUrl),1),0==styleUrls.length&&(component.styleUrls=void 0)}))})}else component.styleUrl&&promises.push(cachedResourceResolve(component.styleUrl).then(style=>{styles.push(style),component.styleUrl=void 0}));const fullyResolved=Promise.all(promises).then(()=>function componentDefResolved(type){componentDefPendingResolution.delete(type)}(type));componentResolved.push(fullyResolved)}),function clearResolutionOfComponentResourcesQueue(){const old=componentResourceResolutionQueue;return componentResourceResolutionQueue=new Map,old}(),Promise.all(componentResolved).then(()=>{})}let componentResourceResolutionQueue=new Map;const componentDefPendingResolution=new Set;function componentNeedsResolution(component){return!!(component.templateUrl&&!component.hasOwnProperty("template")||component.styleUrls&&component.styleUrls.length||component.styleUrl)}const modules=new Map;let checkForDuplicateNgModules=!0;function registerNgModuleType(ngModuleType,id){!function assertSameOrNotExisting(id,type,incoming){if(type&&type!==incoming&&checkForDuplicateNgModules)throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`)}(id,modules.get(id)||null,ngModuleType),modules.set(id,ngModuleType)}function ɵɵvalidateIframeAttribute(attrValue,tagName,attrName){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getSelectedTNode(),element=root_effect_scheduler_getNativeByTNode(tNode,lView);if(2===tNode.type&&"iframe"===tagName.toLowerCase()){const iframe=element;iframe.src="",iframe.srcdoc=trustedHTMLFromString(""),nativeRemoveNode(lView[11],iframe);const errorMessage=ngDevMode&&`Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. \nTo fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;throw new root_effect_scheduler_RuntimeError(-910,errorMessage)}return attrValue}let NgModuleRef$1=class NgModuleRef{},NgModuleFactory$1=class NgModuleFactory{};class NgModuleRef extends NgModuleRef$1{ngModuleType;_parent;_bootstrapComponents=[];_r3Injector;instance;destroyCbs=[];componentFactoryResolver=new ComponentFactoryResolver(this);constructor(ngModuleType,_parent,additionalProviders,runInjectorInitializers=!0){super(),this.ngModuleType=ngModuleType,this._parent=_parent;const ngModuleDef=getNgModuleDef(ngModuleType);ngDevMode&&root_effect_scheduler_assertDefined(ngModuleDef,`NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`),this._bootstrapComponents=maybeUnwrapFn(ngModuleDef.bootstrap),this._r3Injector=createInjectorWithoutInjectorInstances(ngModuleType,_parent,[{provide:NgModuleRef$1,useValue:this},{provide:ComponentFactoryResolver$1,useValue:this.componentFactoryResolver},...additionalProviders],stringify(ngModuleType),new Set(["environment"])),runInjectorInitializers&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){ngDevMode&&root_effect_scheduler_assertDefined(this.destroyCbs,"NgModule already destroyed");const injector=this._r3Injector;!injector.destroyed&&injector.destroy(),this.destroyCbs.forEach(fn=>fn()),this.destroyCbs=null}onDestroy(callback){ngDevMode&&root_effect_scheduler_assertDefined(this.destroyCbs,"NgModule already destroyed"),this.destroyCbs.push(callback)}}class debug_node_NgModuleFactory extends NgModuleFactory$1{moduleType;constructor(moduleType){super(),this.moduleType=moduleType}create(parentInjector){return new NgModuleRef(this.moduleType,parentInjector,[])}}class debug_node_EnvironmentNgModuleRefAdapter extends NgModuleRef$1{injector;componentFactoryResolver=new ComponentFactoryResolver(this);instance=null;constructor(config){super();const injector=new R3Injector([...config.providers,{provide:NgModuleRef$1,useValue:this},{provide:ComponentFactoryResolver$1,useValue:this.componentFactoryResolver}],config.parent||root_effect_scheduler_getNullInjector(),config.debugName,new Set(["environment"]));this.injector=injector,config.runEnvironmentInitializers&&injector.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(callback){this.injector.onDestroy(callback)}}function createEnvironmentInjector(providers,parent,debugName=null){return new debug_node_EnvironmentNgModuleRefAdapter({providers,parent,debugName,runEnvironmentInitializers:!0}).injector}class StandaloneService{_injector;cachedInjectors=new Map;constructor(_injector){this._injector=_injector}getOrCreateStandaloneInjector(componentDef){if(!componentDef.standalone)return null;if(!this.cachedInjectors.has(componentDef)){const providers=internalImportProvidersFrom(!1,componentDef.type),standaloneInjector=providers.length>0?createEnvironmentInjector([providers],this._injector,`Standalone[${componentDef.type.name}]`):null;this.cachedInjectors.set(componentDef,standaloneInjector)}return this.cachedInjectors.get(componentDef)}ngOnDestroy(){try{for(const injector of this.cachedInjectors.values())null!==injector&&injector.destroy()}finally{this.cachedInjectors.clear()}}static ɵprov=ɵɵdefineInjectable({token:StandaloneService,providedIn:"environment",factory:()=>new StandaloneService(ɵɵinject(EnvironmentInjector))})}function ɵɵdefineComponent(componentDefinition){return noSideEffects(()=>{("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode();const baseDef=getNgDirectiveDef(componentDefinition),def={...baseDef,decls:componentDefinition.decls,vars:componentDefinition.vars,template:componentDefinition.template,consts:componentDefinition.consts||null,ngContentSelectors:componentDefinition.ngContentSelectors,onPush:componentDefinition.changeDetection===ChangeDetectionStrategy.OnPush,directiveDefs:null,pipeDefs:null,dependencies:baseDef.standalone&&componentDefinition.dependencies||null,getStandaloneInjector:baseDef.standalone?parentInjector=>parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def):null,getExternalStyles:null,signals:componentDefinition.signals??!1,data:componentDefinition.data||{},encapsulation:componentDefinition.encapsulation||ViewEncapsulation.Emulated,styles:componentDefinition.styles||EMPTY_ARRAY,_:null,schemas:componentDefinition.schemas||null,tView:null,id:""};baseDef.standalone&&debug_node_performanceMarkFeature("NgStandalone"),initFeatures(def);const dependencies=componentDefinition.dependencies;return def.directiveDefs=extractDefListOrFactory(dependencies,extractDirectiveDef),def.pipeDefs=extractDefListOrFactory(dependencies,getPipeDef),def.id=function getComponentId(componentDef){let hash=0;const componentDefConsts="function"==typeof componentDef.consts?"":componentDef.consts,hashSelectors=[componentDef.selectors,componentDef.ngContentSelectors,componentDef.hostVars,componentDef.hostAttrs,componentDefConsts,componentDef.vars,componentDef.decls,componentDef.encapsulation,componentDef.standalone,componentDef.signals,componentDef.exportAs,JSON.stringify(componentDef.inputs),JSON.stringify(componentDef.outputs),Object.getOwnPropertyNames(componentDef.type.prototype),!!componentDef.contentQueries,!!componentDef.viewQuery];if("undefined"==typeof ngDevMode||ngDevMode)for(const item of hashSelectors)root_effect_scheduler_assertNotEqual(typeof item,"function","Internal error: attempting to use a function in component id computation logic.");for(const char of hashSelectors.join("|"))hash=Math.imul(31,hash)+char.charCodeAt(0)|0;hash+=2147483648;const compId="c"+hash;if(("undefined"==typeof ngDevMode||ngDevMode)&&("undefined"==typeof ngServerMode||!ngServerMode))if(GENERATED_COMP_IDS.has(compId)){const previousCompDefType=GENERATED_COMP_IDS.get(compId);previousCompDefType!==componentDef.type&&console.warn(root_effect_scheduler_formatRuntimeError(-912,`Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`))}else GENERATED_COMP_IDS.set(compId,componentDef.type);return compId}(def),def})}function extractDirectiveDef(type){return root_effect_scheduler_getComponentDef(type)||getDirectiveDef(type)}function ɵɵdefineNgModule(def){return noSideEffects(()=>({type:def.type,bootstrap:def.bootstrap||EMPTY_ARRAY,declarations:def.declarations||EMPTY_ARRAY,imports:def.imports||EMPTY_ARRAY,exports:def.exports||EMPTY_ARRAY,transitiveCompileScopes:null,schemas:def.schemas||null,id:def.id||null}))}function parseAndConvertInputsForDefinition(obj,declaredInputs){if(null==obj)return EMPTY_OBJ;const newLookup={};for(const minifiedKey in obj)if(obj.hasOwnProperty(minifiedKey)){const value=obj[minifiedKey];let publicName,declaredName,inputFlags,transform;Array.isArray(value)?(inputFlags=value[0],publicName=value[1],declaredName=value[2]??publicName,transform=value[3]||null):(publicName=value,declaredName=value,inputFlags=InputFlags.None,transform=null),newLookup[publicName]=[minifiedKey,inputFlags,transform],declaredInputs[publicName]=declaredName}return newLookup}function parseAndConvertOutputsForDefinition(obj){if(null==obj)return EMPTY_OBJ;const newLookup={};for(const minifiedKey in obj)obj.hasOwnProperty(minifiedKey)&&(newLookup[obj[minifiedKey]]=minifiedKey);return newLookup}function ɵɵdefineDirective(directiveDefinition){return noSideEffects(()=>{const def=getNgDirectiveDef(directiveDefinition);return initFeatures(def),def})}function ɵɵdefinePipe(pipeDef){return{type:pipeDef.type,name:pipeDef.name,factory:null,pure:!1!==pipeDef.pure,standalone:pipeDef.standalone??!0,onDestroy:pipeDef.type.prototype.ngOnDestroy||null}}function getNgDirectiveDef(directiveDefinition){const declaredInputs={};return{type:directiveDefinition.type,providersResolver:null,factory:null,hostBindings:directiveDefinition.hostBindings||null,hostVars:directiveDefinition.hostVars||0,hostAttrs:directiveDefinition.hostAttrs||null,contentQueries:directiveDefinition.contentQueries||null,declaredInputs,inputConfig:directiveDefinition.inputs||EMPTY_OBJ,exportAs:directiveDefinition.exportAs||null,standalone:directiveDefinition.standalone??!0,signals:!0===directiveDefinition.signals,selectors:directiveDefinition.selectors||EMPTY_ARRAY,viewQuery:directiveDefinition.viewQuery||null,features:directiveDefinition.features||null,setInput:null,resolveHostDirectives:null,hostDirectives:null,inputs:parseAndConvertInputsForDefinition(directiveDefinition.inputs,declaredInputs),outputs:parseAndConvertOutputsForDefinition(directiveDefinition.outputs),debugInfo:null}}function initFeatures(definition){definition.features?.forEach(fn=>fn(definition))}function extractDefListOrFactory(dependencies,defExtractor){return dependencies?()=>{const resolvedDependencies="function"==typeof dependencies?dependencies():dependencies,result=[];for(const dep of resolvedDependencies){const definition=defExtractor(dep);null!==definition&&result.push(definition)}return result}:null}const GENERATED_COMP_IDS=new Map;function getSuperType(type){return Object.getPrototypeOf(type.prototype).constructor}function ɵɵInheritDefinitionFeature(definition){let superType=getSuperType(definition.type),shouldInheritFields=!0;const inheritanceChain=[definition];for(;superType;){let superDef;if(isComponentDef(definition))superDef=superType.ɵcmp||superType.ɵdir;else{if(superType.ɵcmp)throw new root_effect_scheduler_RuntimeError(903,ngDevMode&&`Directives cannot inherit Components. Directive ${root_effect_scheduler_stringifyForError(definition.type)} is attempting to extend component ${root_effect_scheduler_stringifyForError(superType)}`);superDef=superType.ɵdir}if(superDef){if(shouldInheritFields){inheritanceChain.push(superDef);const writeableDef=definition;writeableDef.inputs=maybeUnwrapEmpty(definition.inputs),writeableDef.declaredInputs=maybeUnwrapEmpty(definition.declaredInputs),writeableDef.outputs=maybeUnwrapEmpty(definition.outputs);const superHostBindings=superDef.hostBindings;superHostBindings&&inheritHostBindings(definition,superHostBindings);const superViewQuery=superDef.viewQuery,superContentQueries=superDef.contentQueries;if(superViewQuery&&inheritViewQuery(definition,superViewQuery),superContentQueries&&inheritContentQueries(definition,superContentQueries),mergeInputsWithTransforms(definition,superDef),fillProperties(definition.outputs,superDef.outputs),isComponentDef(superDef)&&superDef.data.animation){const defData=definition.data;defData.animation=(defData.animation||[]).concat(superDef.data.animation)}}const features=superDef.features;if(features)for(let i=0;i<features.length;i++){const feature=features[i];feature&&feature.ngInherit&&feature(definition),feature===ɵɵInheritDefinitionFeature&&(shouldInheritFields=!1)}}superType=Object.getPrototypeOf(superType)}!function mergeHostAttrsAcrossInheritance(inheritanceChain){let hostVars=0,hostAttrs=null;for(let i=inheritanceChain.length-1;i>=0;i--){const def=inheritanceChain[i];def.hostVars=hostVars+=def.hostVars,def.hostAttrs=mergeHostAttrs(def.hostAttrs,hostAttrs=mergeHostAttrs(hostAttrs,def.hostAttrs))}}(inheritanceChain)}function mergeInputsWithTransforms(target,source){for(const key in source.inputs){if(!source.inputs.hasOwnProperty(key))continue;if(target.inputs.hasOwnProperty(key))continue;const value=source.inputs[key];void 0!==value&&(target.inputs[key]=value,target.declaredInputs[key]=source.declaredInputs[key])}}function maybeUnwrapEmpty(value){return value===EMPTY_OBJ?{}:value===EMPTY_ARRAY?[]:value}function inheritViewQuery(definition,superViewQuery){const prevViewQuery=definition.viewQuery;definition.viewQuery=prevViewQuery?(rf,ctx)=>{superViewQuery(rf,ctx),prevViewQuery(rf,ctx)}:superViewQuery}function inheritContentQueries(definition,superContentQueries){const prevContentQueries=definition.contentQueries;definition.contentQueries=prevContentQueries?(rf,ctx,directiveIndex)=>{superContentQueries(rf,ctx,directiveIndex),prevContentQueries(rf,ctx,directiveIndex)}:superContentQueries}function inheritHostBindings(definition,superHostBindings){const prevHostBindings=definition.hostBindings;definition.hostBindings=prevHostBindings?(rf,ctx)=>{superHostBindings(rf,ctx),prevHostBindings(rf,ctx)}:superHostBindings}const COPY_DIRECTIVE_FIELDS=["providersResolver"],COPY_COMPONENT_FIELDS=["template","decls","consts","vars","onPush","ngContentSelectors","styles","encapsulation","schemas"];function ɵɵCopyDefinitionFeature(definition){let superDef,superType=getSuperType(definition.type);superDef=isComponentDef(definition)?superType.ɵcmp:superType.ɵdir;const defAny=definition;for(const field of COPY_DIRECTIVE_FIELDS)defAny[field]=superDef[field];if(isComponentDef(superDef))for(const field of COPY_COMPONENT_FIELDS)defAny[field]=superDef[field]}function ɵɵHostDirectivesFeature(rawHostDirectives){const feature=definition=>{const isEager=Array.isArray(rawHostDirectives);null===definition.hostDirectives?(definition.resolveHostDirectives=resolveHostDirectives,definition.hostDirectives=isEager?rawHostDirectives.map(createHostDirectiveDef):[rawHostDirectives]):isEager?definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef)):definition.hostDirectives.unshift(rawHostDirectives)};return feature.ngInherit=!0,feature}function resolveHostDirectives(matches){const allDirectiveDefs=[];let hasComponent=!1,hostDirectiveDefs=null,hostDirectiveRanges=null;for(let i=0;i<matches.length;i++){const def=matches[i];if(null!==def.hostDirectives){const start=allDirectiveDefs.length;hostDirectiveDefs??=new Map,hostDirectiveRanges??=new Map,findHostDirectiveDefs(def,allDirectiveDefs,hostDirectiveDefs),hostDirectiveRanges.set(def,[start,allDirectiveDefs.length-1])}0===i&&isComponentDef(def)&&(hasComponent=!0,allDirectiveDefs.push(def))}for(let i=hasComponent?1:0;i<matches.length;i++)allDirectiveDefs.push(matches[i]);return[allDirectiveDefs,hostDirectiveDefs,hostDirectiveRanges]}function findHostDirectiveDefs(currentDef,matchedDefs,hostDirectiveDefs){if(null!==currentDef.hostDirectives)for(const configOrFn of currentDef.hostDirectives)if("function"==typeof configOrFn){const resolved=configOrFn();for(const config of resolved)trackHostDirectiveDef(createHostDirectiveDef(config),matchedDefs,hostDirectiveDefs)}else trackHostDirectiveDef(configOrFn,matchedDefs,hostDirectiveDefs)}function trackHostDirectiveDef(def,matchedDefs,hostDirectiveDefs){const hostDirectiveDef=getDirectiveDef(def.directive);("undefined"==typeof ngDevMode||ngDevMode)&&function validateHostDirective(hostDirectiveConfig,directiveDef){const type=hostDirectiveConfig.directive;if(null===directiveDef){if(null!==root_effect_scheduler_getComponentDef(type))throw new root_effect_scheduler_RuntimeError(310,`Host directive ${type.name} cannot be a component.`);throw new root_effect_scheduler_RuntimeError(307,`Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`)}if(!directiveDef.standalone)throw new root_effect_scheduler_RuntimeError(308,`Host directive ${directiveDef.type.name} must be standalone.`);validateMappings("input",directiveDef,hostDirectiveConfig.inputs),validateMappings("output",directiveDef,hostDirectiveConfig.outputs)}(def,hostDirectiveDef),function patchDeclaredInputs(declaredInputs,exposedInputs){for(const publicName in exposedInputs)if(exposedInputs.hasOwnProperty(publicName)){const remappedPublicName=exposedInputs[publicName],privateName=declaredInputs[publicName];("undefined"==typeof ngDevMode||ngDevMode)&&declaredInputs.hasOwnProperty(remappedPublicName)&&root_effect_scheduler_assertEqual(declaredInputs[remappedPublicName],declaredInputs[publicName],`Conflicting host directive input alias ${publicName}.`),declaredInputs[remappedPublicName]=privateName}}(hostDirectiveDef.declaredInputs,def.inputs),findHostDirectiveDefs(hostDirectiveDef,matchedDefs,hostDirectiveDefs),hostDirectiveDefs.set(hostDirectiveDef,def),matchedDefs.push(hostDirectiveDef)}function createHostDirectiveDef(config){return"function"==typeof config?{directive:resolveForwardRef(config),inputs:EMPTY_OBJ,outputs:EMPTY_OBJ}:{directive:resolveForwardRef(config.directive),inputs:bindingArrayToMap(config.inputs),outputs:bindingArrayToMap(config.outputs)}}function bindingArrayToMap(bindings){if(void 0===bindings||0===bindings.length)return EMPTY_OBJ;const result={};for(let i=0;i<bindings.length;i+=2)result[bindings[i]]=bindings[i+1];return result}function validateMappings(bindingType,def,hostDirectiveBindings){const className=def.type.name,bindings="input"===bindingType?def.inputs:def.outputs;for(const publicName in hostDirectiveBindings)if(hostDirectiveBindings.hasOwnProperty(publicName)){if(!bindings.hasOwnProperty(publicName))throw new root_effect_scheduler_RuntimeError(311,`Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);const remappedPublicName=hostDirectiveBindings[publicName];if(bindings.hasOwnProperty(remappedPublicName)&&remappedPublicName!==publicName)throw new root_effect_scheduler_RuntimeError(312,`Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`)}}function templateCreate(tNode,declarationLView,declarationTView,index,templateFn,decls,vars,flags){if(declarationTView.firstCreatePass){tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,tNode.attrs);const embeddedTView=tNode.tView=createTView(2,tNode,templateFn,decls,vars,declarationTView.directiveRegistry,declarationTView.pipeRegistry,null,declarationTView.schemas,declarationTView.consts,null);null!==declarationTView.queries&&(declarationTView.queries.template(declarationTView,tNode),embeddedTView.queries=declarationTView.queries.embeddedTView(tNode))}flags&&(tNode.flags|=flags),setCurrentTNode(tNode,!1);const comment=_locateOrCreateContainerAnchor(declarationTView,declarationLView,tNode,index);wasLastNodeCreated()&&appendChild(declarationTView,declarationLView,comment,tNode),attachPatchData(comment,declarationLView);const lContainer=createLContainer(comment,declarationLView,comment,tNode);declarationLView[index+27]=lContainer,addToEndOfViewTree(declarationLView,lContainer),populateDehydratedViewsInLContainer(lContainer,tNode,declarationLView)}function declareNoDirectiveHostTemplate(declarationLView,declarationTView,index,templateFn,decls,vars,tagName,attrs,flags,localRefsIndex,localRefExtractor){const adjustedIndex=index+27;let tNode;if(declarationTView.firstCreatePass){if(tNode=getOrCreateTNode(declarationTView,adjustedIndex,4,tagName||null,attrs||null),null!=localRefsIndex){const refs=getConstant(declarationTView.consts,localRefsIndex);tNode.localNames=[];for(let i=0;i<refs.length;i+=2)tNode.localNames.push(refs[i],-1)}}else tNode=declarationTView.data[adjustedIndex];return templateCreate(tNode,declarationLView,declarationTView,index,templateFn,decls,vars,flags),null!=localRefsIndex&&saveResolvedLocalsInData(declarationLView,tNode,localRefExtractor),tNode}function ɵɵtemplate(index,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex,localRefExtractor){const lView=root_effect_scheduler_getLView(),tView=getTView();return function declareDirectiveHostTemplate(declarationLView,declarationTView,index,templateFn,decls,vars,tagName,attrs,flags,localRefsIndex,localRefExtractor){const adjustedIndex=index+27;let tNode;return declarationTView.firstCreatePass?(tNode=getOrCreateTNode(declarationTView,adjustedIndex,4,tagName||null,attrs||null),getBindingsEnabled()&&resolveDirectives(declarationTView,declarationLView,tNode,getConstant(declarationTView.consts,localRefsIndex),findDirectiveDefMatches),registerPostOrderHooks(declarationTView,tNode)):tNode=declarationTView.data[adjustedIndex],templateCreate(tNode,declarationLView,declarationTView,index,templateFn,decls,vars,flags),isDirectiveHost(tNode)&&createDirectivesInstances(declarationTView,declarationLView,tNode),null!=localRefsIndex&&saveResolvedLocalsInData(declarationLView,tNode,localRefExtractor),tNode}(lView,tView,index,templateFn,decls,vars,tagName,getConstant(tView.consts,attrsIndex),void 0,localRefsIndex,localRefExtractor),ɵɵtemplate}function ɵɵdomTemplate(index,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex,localRefExtractor){const lView=root_effect_scheduler_getLView(),tView=getTView();return declareNoDirectiveHostTemplate(lView,tView,index,templateFn,decls,vars,tagName,getConstant(tView.consts,attrsIndex),void 0,localRefsIndex,localRefExtractor),ɵɵdomTemplate}let _locateOrCreateContainerAnchor=createContainerAnchorImpl;function createContainerAnchorImpl(tView,lView,tNode,index){return root_effect_scheduler_lastNodeWasCreated(!0),lView[11].createComment(ngDevMode?"container":"")}var DeferDependenciesLoadingState;!function(DeferDependenciesLoadingState){DeferDependenciesLoadingState[DeferDependenciesLoadingState.NOT_STARTED=0]="NOT_STARTED",DeferDependenciesLoadingState[DeferDependenciesLoadingState.IN_PROGRESS=1]="IN_PROGRESS",DeferDependenciesLoadingState[DeferDependenciesLoadingState.COMPLETE=2]="COMPLETE",DeferDependenciesLoadingState[DeferDependenciesLoadingState.FAILED=3]="FAILED"}(DeferDependenciesLoadingState||(DeferDependenciesLoadingState={}));var DeferBlockState,DeferBlockInternalState;!function(DeferBlockState){DeferBlockState[DeferBlockState.Placeholder=0]="Placeholder",DeferBlockState[DeferBlockState.Loading=1]="Loading",DeferBlockState[DeferBlockState.Complete=2]="Complete",DeferBlockState[DeferBlockState.Error=3]="Error"}(DeferBlockState||(DeferBlockState={})),function(DeferBlockInternalState){DeferBlockInternalState[DeferBlockInternalState.Initial=-1]="Initial"}(DeferBlockInternalState||(DeferBlockInternalState={}));var DeferBlockBehavior;function storeTriggerCleanupFn(type,lDetails,cleanupFn){const key=getCleanupFnKeyByType(type);null===lDetails[key]&&(lDetails[key]=[]),lDetails[key].push(cleanupFn)}function invokeTriggerCleanupFns(type,lDetails){const key=getCleanupFnKeyByType(type),cleanupFns=lDetails[key];if(null!==cleanupFns){for(const cleanupFn of cleanupFns)cleanupFn();lDetails[key]=null}}function invokeAllTriggerCleanupFns(lDetails){invokeTriggerCleanupFns(1,lDetails),invokeTriggerCleanupFns(0,lDetails),invokeTriggerCleanupFns(2,lDetails)}function getCleanupFnKeyByType(type){let key=4;return 1===type?key=5:2===type&&(key=9),key}function getDeferBlockDataIndex(deferBlockIndex){return deferBlockIndex+1}function debug_node_getLDeferBlockDetails(lView,tNode){const tView=lView[1],slotIndex=getDeferBlockDataIndex(tNode.index);return ngDevMode&&assertIndexInDeclRange(tView,slotIndex),lView[slotIndex]}function debug_node_getTDeferBlockDetails(tView,tNode){const slotIndex=getDeferBlockDataIndex(tNode.index);return ngDevMode&&assertIndexInDeclRange(tView,slotIndex),tView.data[slotIndex]}function getMinimumDurationForState(tDetails,currentState){return currentState===DeferBlockState.Placeholder?tDetails.placeholderBlockConfig?.[0]??null:currentState===DeferBlockState.Loading?tDetails.loadingBlockConfig?.[0]??null:null}function getLoadingBlockAfter(tDetails){return tDetails.loadingBlockConfig?.[1]??null}function addDepsToRegistry(currentDeps,newDeps){if(!currentDeps||0===currentDeps.length)return newDeps;const currentDepSet=new Set(currentDeps);for(const dep of newDeps)currentDepSet.add(dep);return currentDeps.length===currentDepSet.size?currentDeps:Array.from(currentDepSet)}function assertDeferredDependenciesLoaded(tDetails){root_effect_scheduler_assertEqual(tDetails.loadingState,DeferDependenciesLoadingState.COMPLETE,"Expecting all deferred dependencies to be loaded.")}function isTDeferBlockDetails(value){return null!==value&&"object"==typeof value&&"number"==typeof value.primaryTmplIndex}function trackTriggerForDebugging(tView,tNode,textRepresentation){const tDetails=debug_node_getTDeferBlockDetails(tView,tNode);tDetails.debug??={},tDetails.debug.triggers??=new Set,tDetails.debug.triggers.add(textRepresentation)}function onViewportWrapper(trigger,callback,injector){const ngZone=injector.get(debug_node_NgZone);return function onViewport(trigger,callback,observerFactoryFn){let entry=viewportTriggers.get(trigger);return intersectionObserver=intersectionObserver||observerFactoryFn(),entry||(entry=new DeferEventEntry,intersectionObserver.observe(trigger),viewportTriggers.set(trigger,entry),observedViewportElements++),entry.callbacks.add(callback),()=>{viewportTriggers.has(trigger)&&(entry.callbacks.delete(callback),0===entry.callbacks.size&&(intersectionObserver?.unobserve(trigger),viewportTriggers.delete(trigger),observedViewportElements--),0===observedViewportElements&&(intersectionObserver?.disconnect(),intersectionObserver=null))}}(trigger,()=>ngZone.run(callback),()=>ngZone.runOutsideAngular(()=>function createIntersectionObserver(){return new IntersectionObserver(entries=>{for(const current of entries)current.isIntersecting&&viewportTriggers.has(current.target)&&viewportTriggers.get(current.target).listener()})}()))}function getTriggerElement(triggerLView,triggerIndex){const element=getNativeByIndex(27+triggerIndex,triggerLView);return ngDevMode&&function assertElement(node){node instanceof Element||throwError(`The provided value must be an element but got ${stringify(node)}`)}(element),element}function registerDomTrigger(initialLView,tNode,triggerIndex,walkUpTimes,registerFn,callback,type){const injector=initialLView[9],zone=injector.get(debug_node_NgZone);let poll;poll=afterEveryRender({read:function pollDomTrigger(){if(isDestroyed(initialLView))return void poll.destroy();const lDetails=debug_node_getLDeferBlockDetails(initialLView,tNode),renderedState=lDetails[1];if(renderedState!==DeferBlockInternalState.Initial&&renderedState!==DeferBlockState.Placeholder)return void poll.destroy();const triggerLView=function getTriggerLView(deferredHostLView,deferredTNode,walkUpTimes){if(null==walkUpTimes)return deferredHostLView;if(walkUpTimes>=0)return walkUpViews(walkUpTimes,deferredHostLView);const deferredContainer=deferredHostLView[deferredTNode.index];ngDevMode&&assertLContainer(deferredContainer);const triggerLView=deferredContainer[10]??null;ngDevMode&&null!==triggerLView&&(root_effect_scheduler_assertEqual(debug_node_getLDeferBlockDetails(deferredHostLView,deferredTNode)[1],DeferBlockState.Placeholder,"Expected a placeholder to be rendered in this defer block."),assertLView(triggerLView));return triggerLView}(initialLView,tNode,walkUpTimes);if(!triggerLView)return;if(poll.destroy(),isDestroyed(triggerLView))return;const element=getTriggerElement(triggerLView,triggerIndex),cleanup=registerFn(element,()=>{zone.run(()=>{initialLView!==triggerLView&&removeLViewOnDestroy(triggerLView,cleanup),callback()})},injector);initialLView!==triggerLView&&storeLViewOnDestroy(triggerLView,cleanup),storeTriggerCleanupFn(type,lDetails,cleanup)}},{injector})}function onIdle(callback,injector){const scheduler=injector.get(IdleScheduler);return scheduler.add(callback),()=>scheduler.remove(callback)}!function(DeferBlockBehavior){DeferBlockBehavior[DeferBlockBehavior.Manual=0]="Manual",DeferBlockBehavior[DeferBlockBehavior.Playthrough=1]="Playthrough"}(DeferBlockBehavior||(DeferBlockBehavior={}));class IdleScheduler{executingCallbacks=!1;idleId=null;current=new Set;deferred=new Set;ngZone=root_effect_scheduler_inject(debug_node_NgZone);requestIdleCallbackFn=(()=>"undefined"!=typeof requestIdleCallback?requestIdleCallback:setTimeout)().bind(globalThis);cancelIdleCallbackFn=(()=>"undefined"!=typeof requestIdleCallback?cancelIdleCallback:clearTimeout)().bind(globalThis);add(callback){(this.executingCallbacks?this.deferred:this.current).add(callback),null===this.idleId&&this.scheduleIdleCallback()}remove(callback){const{current,deferred}=this;current.delete(callback),deferred.delete(callback),0===current.size&&0===deferred.size&&this.cancelIdleCallback()}scheduleIdleCallback(){const callback=()=>{this.cancelIdleCallback(),this.executingCallbacks=!0;for(const callback of this.current)callback();if(this.current.clear(),this.executingCallbacks=!1,this.deferred.size>0){for(const callback of this.deferred)this.current.add(callback);this.deferred.clear(),this.scheduleIdleCallback()}};this.idleId=this.requestIdleCallbackFn(()=>this.ngZone.run(callback))}cancelIdleCallback(){null!==this.idleId&&(this.cancelIdleCallbackFn(this.idleId),this.idleId=null)}ngOnDestroy(){this.cancelIdleCallback(),this.current.clear(),this.deferred.clear()}static ɵprov=ɵɵdefineInjectable({token:IdleScheduler,providedIn:"root",factory:()=>new IdleScheduler})}function onTimer(delay){return(callback,injector)=>scheduleTimerTrigger(delay,callback,injector)}function scheduleTimerTrigger(delay,callback,injector){const scheduler=injector.get(TimerScheduler),ngZone=injector.get(debug_node_NgZone);return scheduler.add(delay,callback,ngZone),()=>scheduler.remove(callback)}class TimerScheduler{executingCallbacks=!1;timeoutId=null;invokeTimerAt=null;current=[];deferred=[];add(delay,callback,ngZone){const target=this.executingCallbacks?this.deferred:this.current;this.addToQueue(target,Date.now()+delay,callback),this.scheduleTimer(ngZone)}remove(callback){const{current,deferred}=this;-1===this.removeFromQueue(current,callback)&&this.removeFromQueue(deferred,callback),0===current.length&&0===deferred.length&&this.clearTimeout()}addToQueue(target,invokeAt,callback){let insertAtIndex=target.length;for(let i=0;i<target.length;i+=2){if(target[i]>invokeAt){insertAtIndex=i;break}}arrayInsert2(target,insertAtIndex,invokeAt,callback)}removeFromQueue(target,callback){let index=-1;for(let i=0;i<target.length;i+=2){if(target[i+1]===callback){index=i;break}}return index>-1&&arraySplice(target,index,2),index}scheduleTimer(ngZone){const callback=()=>{this.clearTimeout(),this.executingCallbacks=!0;const current=[...this.current],now=Date.now();for(let i=0;i<current.length;i+=2){const callback=current[i+1];if(!(current[i]<=now))break;callback()}let lastCallbackIndex=-1;for(let i=0;i<this.current.length;i+=2){if(!(this.current[i]<=now))break;lastCallbackIndex=i+1}if(lastCallbackIndex>=0&&arraySplice(this.current,0,lastCallbackIndex+1),this.executingCallbacks=!1,this.deferred.length>0){for(let i=0;i<this.deferred.length;i+=2){const invokeAt=this.deferred[i],callback=this.deferred[i+1];this.addToQueue(this.current,invokeAt,callback)}this.deferred.length=0}this.scheduleTimer(ngZone)};if(this.current.length>0){const now=Date.now(),invokeAt=this.current[0];if(null===this.timeoutId||this.invokeTimerAt&&this.invokeTimerAt-invokeAt>16){this.clearTimeout();const timeout=Math.max(invokeAt-now,16);this.invokeTimerAt=invokeAt,this.timeoutId=ngZone.runOutsideAngular(()=>setTimeout(()=>ngZone.run(callback),timeout))}}}clearTimeout(){null!==this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}ngOnDestroy(){this.clearTimeout(),this.current.length=0,this.deferred.length=0}static ɵprov=ɵɵdefineInjectable({token:TimerScheduler,providedIn:"root",factory:()=>new TimerScheduler})}class CachedInjectorService{cachedInjectors=new Map;getOrCreateInjector(key,parentInjector,providers,debugName){if(!this.cachedInjectors.has(key)){const injector=providers.length>0?createEnvironmentInjector(providers,parentInjector,debugName):null;this.cachedInjectors.set(key,injector)}return this.cachedInjectors.get(key)}ngOnDestroy(){try{for(const injector of this.cachedInjectors.values())null!==injector&&injector.destroy()}finally{this.cachedInjectors.clear()}}static ɵprov=ɵɵdefineInjectable({token:CachedInjectorService,providedIn:"environment",factory:()=>new CachedInjectorService})}const DEFER_BLOCK_DEPENDENCY_INTERCEPTOR=new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR"),DEFER_BLOCK_CONFIG=new InjectionToken(ngDevMode?"DEFER_BLOCK_CONFIG":"");function getOrCreateEnvironmentInjector(parentInjector,tDetails,providers){return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails,parentInjector,providers,ngDevMode?"DeferBlock Injector":"")}function renderDeferBlockState(newState,tNode,lContainer,skipTimerScheduling=!1){const hostLView=lContainer[3],hostTView=hostLView[1];if(isDestroyed(hostLView))return;ngDevMode&&assertTNodeForLView(tNode,hostLView);const lDetails=debug_node_getLDeferBlockDetails(hostLView,tNode);ngDevMode&&root_effect_scheduler_assertDefined(lDetails,"Expected a defer block state defined");const currentState=lDetails[1],ssrState=lDetails[7];if(!(null!==ssrState&&newState<ssrState)&&isValidStateChange(currentState,newState)&&isValidStateChange(lDetails[0]??-1,newState)){const tDetails=debug_node_getTDeferBlockDetails(hostTView,tNode),needsScheduling=!skipTimerScheduling&&("undefined"==typeof ngServerMode||!ngServerMode)&&(null!==getLoadingBlockAfter(tDetails)||null!==getMinimumDurationForState(tDetails,DeferBlockState.Loading)||getMinimumDurationForState(tDetails,DeferBlockState.Placeholder));ngDevMode&&needsScheduling&&root_effect_scheduler_assertDefined(applyDeferBlockStateWithSchedulingImpl,"Expected scheduling function to be defined");const applyStateFn=needsScheduling?applyDeferBlockStateWithSchedulingImpl:applyDeferBlockState;try{applyStateFn(newState,lDetails,lContainer,tNode,hostLView)}catch(error){handleUncaughtError(hostLView,error)}}}function applyDeferBlockState(newState,lDetails,lContainer,tNode,hostLView){debug_node_profiler(20);const stateTmplIndex=function getTemplateIndexForState(newState,hostLView,tNode){const tDetails=debug_node_getTDeferBlockDetails(hostLView[1],tNode);switch(newState){case DeferBlockState.Complete:return tDetails.primaryTmplIndex;case DeferBlockState.Loading:return tDetails.loadingTmplIndex;case DeferBlockState.Error:return tDetails.errorTmplIndex;case DeferBlockState.Placeholder:return tDetails.placeholderTmplIndex;default:return ngDevMode&&throwError(`Unexpected defer block state: ${newState}`),null}}(newState,hostLView,tNode);if(null!==stateTmplIndex){lDetails[1]=newState;const hostTView=hostLView[1],activeBlockTNode=root_effect_scheduler_getTNode(hostTView,stateTmplIndex+27),viewIndex=0;let injector;if(removeLViewFromLContainer(lContainer,viewIndex),newState===DeferBlockState.Complete){const tDetails=debug_node_getTDeferBlockDetails(hostTView,tNode),providers=tDetails.providers;providers&&providers.length>0&&(injector=function createDeferBlockInjector(parentInjector,tDetails,providers){if(parentInjector instanceof ChainedInjector){const origInjector=parentInjector.injector,envInjector=getOrCreateEnvironmentInjector(parentInjector.parentInjector,tDetails,providers);return new ChainedInjector(origInjector,envInjector)}const parentEnvInjector=parentInjector.get(EnvironmentInjector);if(parentEnvInjector!==parentInjector){const envInjector=getOrCreateEnvironmentInjector(parentEnvInjector,tDetails,providers);return new ChainedInjector(parentInjector,envInjector)}return getOrCreateEnvironmentInjector(parentInjector,tDetails,providers)}(hostLView[9],tDetails,providers))}const{dehydratedView,dehydratedViewIx}=function findMatchingDehydratedViewForDeferBlock(lContainer,lDetails){const dehydratedViewIx=lContainer[6]?.findIndex(view=>view.data.s===lDetails[1])??-1;return{dehydratedView:dehydratedViewIx>-1?lContainer[6][dehydratedViewIx]:null,dehydratedViewIx}}(lContainer,lDetails),embeddedLView=createAndRenderEmbeddedLView(hostLView,activeBlockTNode,null,{injector,dehydratedView});if(addLViewToLContainer(lContainer,embeddedLView,viewIndex,shouldAddViewToDom(activeBlockTNode,dehydratedView)),markViewDirty(embeddedLView,2),dehydratedViewIx>-1&&lContainer[6]?.splice(dehydratedViewIx,1),(newState===DeferBlockState.Complete||newState===DeferBlockState.Error)&&Array.isArray(lDetails[8])){for(const callback of lDetails[8])callback();lDetails[8]=null}}debug_node_profiler(21)}function applyDeferBlockStateWithScheduling(newState,lDetails,lContainer,tNode,hostLView){const now=Date.now(),tDetails=debug_node_getTDeferBlockDetails(hostLView[1],tNode);if(null===lDetails[2]||lDetails[2]<=now){lDetails[2]=null;const loadingAfter=getLoadingBlockAfter(tDetails),inLoadingAfterPhase=null!==lDetails[3];if(newState!==DeferBlockState.Loading||null===loadingAfter||inLoadingAfterPhase){newState>DeferBlockState.Loading&&inLoadingAfterPhase&&(lDetails[3](),lDetails[3]=null,lDetails[0]=null),applyDeferBlockState(newState,lDetails,lContainer,tNode,hostLView);const duration=getMinimumDurationForState(tDetails,newState);null!==duration&&(lDetails[2]=now+duration,scheduleDeferBlockUpdate(duration,lDetails,tNode,lContainer,hostLView))}else{lDetails[0]=newState;const cleanupFn=scheduleDeferBlockUpdate(loadingAfter,lDetails,tNode,lContainer,hostLView);lDetails[3]=cleanupFn}}else lDetails[0]=newState}function scheduleDeferBlockUpdate(timeout,lDetails,tNode,lContainer,hostLView){return scheduleTimerTrigger(timeout,()=>{const nextState=lDetails[0];lDetails[2]=null,lDetails[0]=null,null!==nextState&&renderDeferBlockState(nextState,tNode,lContainer)},hostLView[9])}function isValidStateChange(currentState,newState){return currentState<newState}function renderPlaceholder(lView,tNode){const lContainer=lView[tNode.index];ngDevMode&&assertLContainer(lContainer),renderDeferBlockState(DeferBlockState.Placeholder,tNode,lContainer)}function renderDeferStateAfterResourceLoading(tDetails,tNode,lContainer){ngDevMode&&root_effect_scheduler_assertDefined(tDetails.loadingPromise,"Expected loading Promise to exist on this defer block"),tDetails.loadingPromise.then(()=>{tDetails.loadingState===DeferDependenciesLoadingState.COMPLETE?(ngDevMode&&assertDeferredDependenciesLoaded(tDetails),renderDeferBlockState(DeferBlockState.Complete,tNode,lContainer)):tDetails.loadingState===DeferDependenciesLoadingState.FAILED&&renderDeferBlockState(DeferBlockState.Error,tNode,lContainer)})}let applyDeferBlockStateWithSchedulingImpl=null;function ɵɵdeferEnableTimerScheduling(tView,tDetails,placeholderConfigIndex,loadingConfigIndex){const tViewConsts=tView.consts;null!=placeholderConfigIndex&&(tDetails.placeholderBlockConfig=getConstant(tViewConsts,placeholderConfigIndex)),null!=loadingConfigIndex&&(tDetails.loadingBlockConfig=getConstant(tViewConsts,loadingConfigIndex)),null===applyDeferBlockStateWithSchedulingImpl&&(applyDeferBlockStateWithSchedulingImpl=applyDeferBlockStateWithScheduling)}function debug_node_setClassMetadata(type,decorators,ctorParameters,propDecorators){return noSideEffects(()=>{const clazz=type;null!==decorators&&(clazz.hasOwnProperty("decorators")&&void 0!==clazz.decorators?clazz.decorators.push(...decorators):clazz.decorators=decorators),null!==ctorParameters&&(clazz.ctorParameters=ctorParameters),null!==propDecorators&&(clazz.hasOwnProperty("propDecorators")&&void 0!==clazz.propDecorators?clazz.propDecorators={...clazz.propDecorators,...propDecorators}:clazz.propDecorators=propDecorators)})}class debug_node_Console{log(message){console.log(message)}warn(message){console.warn(message)}static ɵfac=function Console_Factory(__ngFactoryType__){return new(__ngFactoryType__||debug_node_Console)};static ɵprov=ɵɵdefineInjectable({token:debug_node_Console,factory:debug_node_Console.ɵfac,providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(debug_node_Console,[{type:Injectable,args:[{providedIn:"platform"}]}],null,null);let frameworkDIDebugData=new class DIDebugData{resolverToTokenToDependencies=new WeakMap;resolverToProviders=new WeakMap;resolverToEffects=new WeakMap;standaloneInjectorToComponent=new WeakMap;reset(){this.resolverToTokenToDependencies=new WeakMap,this.resolverToProviders=new WeakMap,this.standaloneInjectorToComponent=new WeakMap}};function getFrameworkDIDebugData(){return frameworkDIDebugData}function injectorProfilerEventHandler(injectorProfilerEvent){const{context,type}=injectorProfilerEvent;0===type?function handleInjectEvent(context,data){const diResolver=getDIResolver(context.injector);null===diResolver&&throwError("An Inject event must be run within an injection context.");const diResolverToInstantiatedToken=frameworkDIDebugData.resolverToTokenToDependencies;diResolverToInstantiatedToken.has(diResolver)||diResolverToInstantiatedToken.set(diResolver,new WeakMap);if(!function canBeHeldWeakly(value){return null!==value&&("object"==typeof value||"function"==typeof value||"symbol"==typeof value)}(context.token))return;const instantiatedTokenToDependencies=diResolverToInstantiatedToken.get(diResolver);instantiatedTokenToDependencies.has(context.token)||instantiatedTokenToDependencies.set(context.token,[]);const{token,value,flags}=data;root_effect_scheduler_assertDefined(context.token,"Injector profiler context token is undefined.");const dependencies=instantiatedTokenToDependencies.get(context.token);root_effect_scheduler_assertDefined(dependencies,"Could not resolve dependencies for token."),context.injector instanceof NodeInjector?dependencies.push({token,value,flags,injectedIn:getNodeInjectorContext(context.injector)}):dependencies.push({token,value,flags})}(context,injectorProfilerEvent.service):1===type?function handleInstanceCreatedByInjectorEvent(context,data){const{value}=data;if(null==data.value)return;null===getDIResolver(context.injector)&&throwError("An InjectorCreatedInstance event must be run within an injection context.");let standaloneComponent;"object"==typeof value&&(standaloneComponent=value?.constructor);if(null==standaloneComponent||!function isStandaloneComponent(value){const def=root_effect_scheduler_getComponentDef(value);return!!def?.standalone}(standaloneComponent))return;const environmentInjector=context.injector.get(EnvironmentInjector,null,{optional:!0});if(null===environmentInjector)return;const{standaloneInjectorToComponent}=frameworkDIDebugData;if(standaloneInjectorToComponent.has(environmentInjector))return;standaloneInjectorToComponent.set(environmentInjector,standaloneComponent)}(context,injectorProfilerEvent.instance):2===type?function handleProviderConfiguredEvent(context,data){const{resolverToProviders}=frameworkDIDebugData;let diResolver;diResolver=context?.injector instanceof NodeInjector?getNodeInjectorTNode(context.injector):context.injector;null===diResolver&&throwError("A ProviderConfigured event must be run within an injection context.");resolverToProviders.has(diResolver)||resolverToProviders.set(diResolver,[]);resolverToProviders.get(diResolver).push(data)}(context,injectorProfilerEvent.providerRecord):3===type&&function handleEffectCreatedEvent(context,effect){const diResolver=getDIResolver(context.injector);null===diResolver&&throwError("An EffectCreated event must be run within an injection context.");const{resolverToEffects}=frameworkDIDebugData;resolverToEffects.has(diResolver)||resolverToEffects.set(diResolver,[]);resolverToEffects.get(diResolver).push(effect)}(context,injectorProfilerEvent.effect)}function getNodeInjectorContext(injector){injector instanceof NodeInjector||throwError("getNodeInjectorContext must be called with a NodeInjector");const lView=getNodeInjectorLView(injector),tNode=getNodeInjectorTNode(injector);if(null!==tNode)return assertTNodeForLView(tNode,lView),{lView,tNode}}function getDIResolver(injector){let diResolver=null;return void 0===injector||(diResolver=injector instanceof NodeInjector?getNodeInjectorLView(injector):injector),diResolver}function getDeferBlocks$1(lView,deferBlocks){const tView=lView[1];for(let i=27;i<tView.bindingStartIndex;i++)if(root_effect_scheduler_isLContainer(lView[i])){const lContainer=lView[i];if(!(i===tView.bindingStartIndex-1)){const tNode=tView.data[i],tDetails=debug_node_getTDeferBlockDetails(tView,tNode);if(isTDeferBlockDetails(tDetails)){deferBlocks.push({lContainer,lView,tNode,tDetails});continue}}root_effect_scheduler_isLView(lContainer[0])&&getDeferBlocks$1(lContainer[0],deferBlocks);for(let j=10;j<lContainer.length;j++)getDeferBlocks$1(lContainer[j],deferBlocks)}else root_effect_scheduler_isLView(lView[i])&&getDeferBlocks$1(lView[i],deferBlocks)}function findDeferBlocks(node,lView,results){const viewInjector=lView[9],registry=viewInjector.get(debug_node_DEHYDRATED_BLOCK_REGISTRY,null,{optional:!0}),blocks=[];getDeferBlocks$1(lView,blocks);const deferBlockParents=viewInjector.get(debug_node_TransferState).get("__nghDeferData__",{});for(const details of blocks){const native=root_effect_scheduler_getNativeByTNode(details.tNode,details.lView),lDetails=debug_node_getLDeferBlockDetails(details.lView,details.tNode);if(!node.contains(native))continue;const tDetails=details.tDetails,renderedLView=getRendererLView(details),rootNodes=[],hydrationState=inferHydrationState(tDetails,lDetails,registry);if(null!==renderedLView)debug_node_collectNativeNodes(renderedLView[1],renderedLView,renderedLView[1].firstChild,rootNodes);else if("dehydrated"===hydrationState){const numberOfRootNodes=deferBlockParents[lDetails[6]].r;let collectedNodeCount=0;let currentNode=details.lContainer[7].previousSibling;for(;collectedNodeCount<numberOfRootNodes&&currentNode;)rootNodes.unshift(currentNode),currentNode=currentNode.previousSibling,collectedNodeCount++}const data={state:stringifyState(lDetails[1]),incrementalHydrationState:hydrationState,hasErrorBlock:null!==tDetails.errorTmplIndex,loadingBlock:{exists:null!==tDetails.loadingTmplIndex,minimumTime:tDetails.loadingBlockConfig?.[0]??null,afterTime:tDetails.loadingBlockConfig?.[1]??null},placeholderBlock:{exists:null!==tDetails.placeholderTmplIndex,minimumTime:tDetails.placeholderBlockConfig?.[0]??null},triggers:tDetails.debug?.triggers?Array.from(tDetails.debug.triggers).sort():[],rootNodes};results.push(data),null!==renderedLView&&findDeferBlocks(node,renderedLView,results)}}function stringifyState(state){switch(state){case DeferBlockState.Complete:return"complete";case DeferBlockState.Loading:return"loading";case DeferBlockState.Placeholder:return"placeholder";case DeferBlockState.Error:return"error";case DeferBlockInternalState.Initial:return"initial";default:throw new Error(`Unrecognized state ${state}`)}}function inferHydrationState(tDetails,lDetails,registry){return null===registry||null===lDetails[6]||null===tDetails.hydrateTriggers||tDetails.hydrateTriggers.has(7)?"not-configured":registry.has(lDetails[6])?"dehydrated":"hydrated"}function getRendererLView(details){if(details.lContainer.length<=10)return null;const lView=details.lContainer[10];return ngDevMode&&assertLView(lView),lView}function getProviderImportPaths(providerImportsContainer){const providerToPath=new Map,visitor=function walkProviderTreeToDiscoverImportPaths(providerToPath,visitedContainers){return(provider,container)=>{if(providerToPath.has(provider)||providerToPath.set(provider,[container]),!visitedContainers.has(container))for(const prov of providerToPath.keys()){const existingImportPath=providerToPath.get(prov);let containerDef=getInjectorDef(container);if(!containerDef){containerDef=getInjectorDef(container.ngModule)}if(!containerDef)return;const lastContainerAddedToPath=existingImportPath[0];let isNextStepInPath=!1;deepForEach(containerDef.imports,moduleImport=>{isNextStepInPath||(isNextStepInPath=moduleImport.ngModule===lastContainerAddedToPath||moduleImport===lastContainerAddedToPath,isNextStepInPath&&providerToPath.get(prov)?.unshift(container))})}visitedContainers.add(container)}}(providerToPath,new Set);return walkProviderTree(providerImportsContainer,visitor,[],new Set),providerToPath}function getEnvironmentInjectorProviders(injector){const providerRecordsWithoutImportPaths=getFrameworkDIDebugData().resolverToProviders.get(injector)??[];if(function isPlatformInjector(injector){return injector instanceof R3Injector&&injector.scopes.has("platform")}(injector))return providerRecordsWithoutImportPaths;const providerImportsContainer=function getProviderImportsContainer(injector){const{standaloneInjectorToComponent}=getFrameworkDIDebugData();if(standaloneInjectorToComponent.has(injector))return standaloneInjectorToComponent.get(injector);const defTypeRef=injector.get(NgModuleRef$1,null,{self:!0,optional:!0});return null===defTypeRef||null===defTypeRef.instance?null:defTypeRef.instance.constructor}(injector);if(null===providerImportsContainer)return providerRecordsWithoutImportPaths;const providerToPath=getProviderImportPaths(providerImportsContainer),providerRecords=[];for(const providerRecord of providerRecordsWithoutImportPaths){const provider=providerRecord.provider,token=provider.provide;if(token===root_effect_scheduler_ENVIRONMENT_INITIALIZER||token===INJECTOR_DEF_TYPES)continue;let importPath=providerToPath.get(provider)??[];const def=root_effect_scheduler_getComponentDef(providerImportsContainer);!!def?.standalone&&(importPath=[providerImportsContainer,...importPath]),providerRecords.push({...providerRecord,importPath})}return providerRecords}function getInjectorResolutionPath(injector){const resolutionPath=[injector];return getInjectorResolutionPathHelper(injector,resolutionPath),resolutionPath}function getInjectorResolutionPathHelper(injector,resolutionPath){const parent=function getInjectorParent(injector){if(injector instanceof R3Injector)return injector.parent;let tNode,lView;if(injector instanceof NodeInjector)tNode=getNodeInjectorTNode(injector),lView=getNodeInjectorLView(injector);else{if(injector instanceof NullInjector)return null;if(injector instanceof ChainedInjector)return injector.parentInjector;throwError("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector")}const parentLocation=getParentInjectorLocation(tNode,lView);if(hasParentInjector(parentLocation)){const parentInjectorIndex=getParentInjectorIndex(parentLocation),parentLView=getParentInjectorView(parentLocation,lView),parentTNode=parentLView[1].data[parentInjectorIndex+8];return new NodeInjector(parentTNode,parentLView)}{const chainedInjector=lView[9],injectorParent=chainedInjector.injector?.parent;if(injectorParent instanceof NodeInjector)return injectorParent}return null}(injector);if(null===parent){if(injector instanceof NodeInjector){const firstInjector=resolutionPath[0];if(firstInjector instanceof NodeInjector){const moduleInjector=function getModuleInjectorOfNodeInjector(injector){let lView;injector instanceof NodeInjector?lView=getNodeInjectorLView(injector):throwError("getModuleInjectorOfNodeInjector must be called with a NodeInjector");const inj=lView[9],moduleInjector=inj instanceof ChainedInjector?inj.parentInjector:inj.parent;moduleInjector||throwError("NodeInjector must have some connection to the module injector tree");return moduleInjector}(firstInjector);null===moduleInjector&&throwError("NodeInjector must have some connection to the module injector tree"),resolutionPath.push(moduleInjector),getInjectorResolutionPathHelper(moduleInjector,resolutionPath)}return resolutionPath}}else resolutionPath.push(parent),getInjectorResolutionPathHelper(parent,resolutionPath);return resolutionPath}function isComputedNode(node){return"computed"===node.kind}function isTemplateEffectNode(node){return"template"===node.kind}function isSignalNode(node){return"signal"===node.kind}const signalDebugMap=new WeakMap;let counter$1=0;function extractSignalNodesAndEdgesFromRoots(nodes,signalDependenciesMap=new Map){for(const node of nodes){if(signalDependenciesMap.has(node))continue;const producerNodes=[];for(let link=node.producers;void 0!==link;link=link.nextProducer){const producer=link.producer;producerNodes.push(producer)}signalDependenciesMap.set(node,producerNodes),extractSignalNodesAndEdgesFromRoots(producerNodes,signalDependenciesMap)}return signalDependenciesMap}let changeDetectionRuns=0,changeDetectionSyncRuns=0,counter=0;const eventsStack=[];function measureStart(startEvent){eventsStack.push([startEvent,counter]),console.timeStamp("Event_"+startEvent+"_"+counter++)}function measureEnd(startEvent,entryName,color){const top=eventsStack.pop();root_effect_scheduler_assertDefined(top,"Profiling error: could not find start event entry "+startEvent),root_effect_scheduler_assertEqual(top[0],startEvent,`Profiling error: expected to see ${startEvent} event but got ${top[0]}`),console.timeStamp(entryName,"Event_"+top[0]+"_"+top[1],void 0,"🅰️ Angular",void 0,color)}const chromeDevToolsInjectorProfiler=event=>{const eventType=event.type;if(4===eventType)measureStart(100);else if(1===eventType){measureEnd(100,getProviderTokenMeasureName(event.context.token),"tertiary-dark")}},devToolsProfiler=(event,instance,eventFn)=>{switch(event){case 8:case 10:case 12:case 14:case 16:case 18:case 20:case 22:case 0:case 4:case 2:case 24:case 6:measureStart(event);break;case 9:measureEnd(8,"Bootstrap application","primary-dark");break;case 11:measureEnd(10,"Bootstrap component","primary-dark");break;case 13:changeDetectionSyncRuns=0,measureEnd(12,"Change detection "+changeDetectionRuns++,"primary-dark");break;case 15:measureEnd(14,"Synchronization "+changeDetectionSyncRuns++,"primary");break;case 17:measureEnd(16,"After render hooks","primary");break;case 19:measureEnd(18,getComponentMeasureName(instance),"primary-light");break;case 21:measureEnd(20,"Defer block","primary-dark");break;case 23:measureEnd(22,"Dynamic component creation","primary-dark");break;case 3:measureEnd(2,root_effect_scheduler_stringifyForError(eventFn)+" (update)","secondary-dark");break;case 1:measureEnd(0,root_effect_scheduler_stringifyForError(eventFn)+" (create)","secondary");break;case 25:measureEnd(24,"HostBindings","secondary-dark");break;case 5:measureEnd(4,`${getComponentMeasureName(instance)}:${root_effect_scheduler_stringifyForError(eventFn)}`,"tertiary");break;case 7:measureEnd(6,root_effect_scheduler_stringifyForError(eventFn),"tertiary-light");break;default:throw new Error("Unexpected profiling event type: "+event)}};function getComponentMeasureName(instance){return instance.constructor.name}function getProviderTokenMeasureName(token){return isTypeProvider(token)?token.name:null!=token.provide?getProviderTokenMeasureName(token.provide):token.toString()}const globalUtilsFunctions={ɵgetDependenciesFromInjectable:function getDependenciesFromInjectable(injector,token){const instance=injector.get(token,null,{self:!0,optional:!0});if(null===instance)throw new Error(`Unable to determine instance of ${token} in given injector`);const unformattedDependencies=function getDependenciesForTokenInInjector(token,injector){const{resolverToTokenToDependencies}=getFrameworkDIDebugData();if(!(injector instanceof NodeInjector))return resolverToTokenToDependencies.get(injector)?.get?.(token)??[];const lView=getNodeInjectorLView(injector),tokenDependencyMap=resolverToTokenToDependencies.get(lView),dependencies=tokenDependencyMap?.get(token)??[];return dependencies.filter(dependency=>{const dependencyNode=dependency.injectedIn?.tNode;if(void 0===dependencyNode)return!1;const instanceNode=getNodeInjectorTNode(injector);return root_effect_scheduler_assertTNode(dependencyNode),root_effect_scheduler_assertTNode(instanceNode),dependencyNode===instanceNode})}(token,injector),resolutionPath=getInjectorResolutionPath(injector);return{instance,dependencies:unformattedDependencies.map(dep=>{const formattedDependency={value:dep.value},flags=dep.flags;formattedDependency.flags={optional:!(8&~flags),host:!(1&~flags),self:!(2&~flags),skipSelf:!(4&~flags)};for(let i=0;i<resolutionPath.length;i++){const injectorToCheck=resolutionPath[i];if(0===i&&formattedDependency.flags.skipSelf)continue;if(formattedDependency.flags.host&&injectorToCheck instanceof EnvironmentInjector)break;if(null!==injectorToCheck.get(dep.token,null,{self:!0,optional:!0})){if(formattedDependency.flags.host){null!==resolutionPath[0].get(dep.token,null,{...formattedDependency.flags,optional:!0})&&(formattedDependency.providedIn=injectorToCheck);break}formattedDependency.providedIn=injectorToCheck;break}if(0===i&&formattedDependency.flags.self)break}return dep.token&&(formattedDependency.token=dep.token),formattedDependency})}},ɵgetInjectorProviders:function getInjectorProviders(injector){return injector instanceof NodeInjector?function getNodeInjectorProviders(injector){const diResolver=getNodeInjectorTNode(injector),{resolverToProviders}=getFrameworkDIDebugData();return resolverToProviders.get(diResolver)??[]}(injector):injector instanceof EnvironmentInjector?getEnvironmentInjectorProviders(injector):void throwError("getInjectorProviders only supports NodeInjector and EnvironmentInjector")},ɵgetInjectorResolutionPath:getInjectorResolutionPath,ɵgetInjectorMetadata:function getInjectorMetadata(injector){if(injector instanceof NodeInjector){const lView=getNodeInjectorLView(injector),tNode=getNodeInjectorTNode(injector);return assertTNodeForLView(tNode,lView),{type:"element",source:root_effect_scheduler_getNativeByTNode(tNode,lView)}}return injector instanceof R3Injector?{type:"environment",source:injector.source??null}:injector instanceof NullInjector?{type:"null",source:null}:null},ɵsetProfiler:setProfiler,ɵgetSignalGraph:function getSignalGraph(injector){let templateConsumer=null;if(!(injector instanceof NodeInjector||injector instanceof R3Injector))return throwError("getSignalGraph must be called with a NodeInjector or R3Injector");injector instanceof NodeInjector&&(templateConsumer=function getTemplateConsumer(injector){const tNode=getNodeInjectorTNode(injector);root_effect_scheduler_assertTNode(tNode);const lView=getNodeInjectorLView(injector);assertLView(lView);const templateLView=lView[tNode.index];return root_effect_scheduler_isLView(templateLView)?templateLView[24]??null:null}(injector));const nonTemplateEffectNodes=function extractEffectsFromInjector(injector){let diResolver=injector;injector instanceof NodeInjector&&(diResolver=getNodeInjectorLView(injector));return(getFrameworkDIDebugData().resolverToEffects.get(diResolver)??[]).map(effect=>effect[SIGNAL])}(injector);return function getNodesAndEdgesFromSignalMap(signalMap){const nodes=Array.from(signalMap.keys()),debugSignalGraphNodes=[],edges=[];for(const[consumer,producers]of signalMap.entries()){const consumerIndex=nodes.indexOf(consumer);let id=signalDebugMap.get(consumer);id||(counter$1++,id=counter$1.toString(),signalDebugMap.set(consumer,id)),isComputedNode(consumer)?debugSignalGraphNodes.push({label:consumer.debugName,value:consumer.value,kind:consumer.kind,epoch:consumer.version,debuggableFn:consumer.computation,id}):isSignalNode(consumer)?debugSignalGraphNodes.push({label:consumer.debugName,value:consumer.value,kind:consumer.kind,epoch:consumer.version,id}):isTemplateEffectNode(consumer)?debugSignalGraphNodes.push({label:consumer.debugName??consumer.lView?.[0]?.tagName?.toLowerCase?.(),kind:consumer.kind,epoch:consumer.version,debuggableFn:consumer.lView?.[8]?.constructor,id}):debugSignalGraphNodes.push({label:consumer.debugName,kind:consumer.kind,epoch:consumer.version,id});for(const producer of producers)edges.push({consumer:consumerIndex,producer:nodes.indexOf(producer)})}return{nodes:debugSignalGraphNodes,edges}}(extractSignalNodesAndEdgesFromRoots(templateConsumer?[templateConsumer,...nonTemplateEffectNodes]:nonTemplateEffectNodes))},ɵgetDeferBlocks:function getDeferBlocks(node){const results=[],lView=getLContext(node)?.lView;return lView&&findDeferBlocks(node,lView,results),results},ɵgetTransferState:function getTransferState(injector){const transferState=retrieveTransferredState(debug_node_getDocument(),injector.get(debug_node_APP_ID)),filteredEntries={};for(const[key,value]of Object.entries(transferState))isInternalHydrationTransferStateKey(key)||(filteredEntries[key]=value);return filteredEntries},getDirectiveMetadata:function getDirectiveMetadata$1(directiveOrComponentInstance){const{constructor}=directiveOrComponentInstance;if(!constructor)throw new Error("Unable to find the instance constructor");const componentDef=root_effect_scheduler_getComponentDef(constructor);if(componentDef){return{inputs:extractInputDebugMetadata(componentDef.inputs),outputs:componentDef.outputs,encapsulation:componentDef.encapsulation,changeDetection:componentDef.onPush?ChangeDetectionStrategy.OnPush:ChangeDetectionStrategy.Default}}const directiveDef=getDirectiveDef(constructor);if(directiveDef){return{inputs:extractInputDebugMetadata(directiveDef.inputs),outputs:directiveDef.outputs}}return null},getComponent,getContext,getListeners,getOwningComponent,getHostElement:function getHostElement(componentOrDirective){return getLContext(componentOrDirective).native},getInjector,getRootComponents,getDirectives:function getDirectives(node){if(node instanceof Text)return[];const context=getLContext(node),lView=context?context.lView:null;if(null===lView)return[];const tView=lView[1],nodeIndex=context.nodeIndex;return tView?.data[nodeIndex]?(void 0===context.directives&&(context.directives=getDirectivesAtNodeIndex(nodeIndex,lView)),null===context.directives?[]:[...context.directives]):[]},applyChanges:function applyChanges(component){ngDevMode&&root_effect_scheduler_assertDefined(component,"component"),markViewDirty(getComponentViewByInstance(component),3),getRootComponents(component).forEach(rootComponent=>function detectChanges(component){const view=getComponentViewByInstance(component);view[2]|=1024,detectChangesInternal(view)}(rootComponent))},isSignal,enableProfiling:function enableProfiling(){if(debug_node_performanceMarkFeature("Chrome DevTools profiling"),"undefined"!=typeof ngDevMode&&ngDevMode){const removeInjectorProfiler=setInjectorProfiler(chromeDevToolsInjectorProfiler),removeProfiler=setProfiler(devToolsProfiler);return()=>{removeInjectorProfiler(),removeProfiler()}}return()=>{}}};let _published=!1;function publishDefaultGlobalUtils$1(){if(!_published){_published=!0,"undefined"!=typeof window&&function setupFrameworkInjectorProfiler(){frameworkDIDebugData.reset(),setInjectorProfiler(injectorProfilerEventHandler)}();for(const[methodName,method]of Object.entries(globalUtilsFunctions))publishGlobalUtil(methodName,method)}}function publishGlobalUtil(name,fn){publishUtil(name,fn)}function publishUtil(name,fn){if("undefined"==typeof COMPILED||!COMPILED){const w=root_effect_scheduler_global;ngDevMode&&root_effect_scheduler_assertDefined(fn,"function not defined"),w.ng??={},w.ng[name]=fn}}const TESTABILITY=new InjectionToken(""),TESTABILITY_GETTER=new InjectionToken("");class Testability{_ngZone;registry;_isZoneStable=!0;_callbacks=[];_taskTrackingZone=null;_destroyRef;constructor(_ngZone,registry,testabilityGetter){this._ngZone=_ngZone,this.registry=registry,isInInjectionContext()&&(this._destroyRef=root_effect_scheduler_inject(DestroyRef,{optional:!0})??void 0),_testabilityGetter||(!function setTestabilityGetter(getter){_testabilityGetter=getter}(testabilityGetter),testabilityGetter.addToWindow(registry)),this._watchAngularEvents(),_ngZone.run(()=>{this._taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){const onUnstableSubscription=this._ngZone.onUnstable.subscribe({next:()=>{this._isZoneStable=!1}}),onStableSubscription=this._ngZone.runOutsideAngular(()=>this._ngZone.onStable.subscribe({next:()=>{debug_node_NgZone.assertNotInAngularZone(),queueMicrotask(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}}));this._destroyRef?.onDestroy(()=>{onUnstableSubscription.unsubscribe(),onStableSubscription.unsubscribe()})}isStable(){return this._isZoneStable&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())queueMicrotask(()=>{for(;0!==this._callbacks.length;){let cb=this._callbacks.pop();clearTimeout(cb.timeoutId),cb.doneCb()}});else{let pending=this.getPendingTasks();this._callbacks=this._callbacks.filter(cb=>!cb.updateCb||!cb.updateCb(pending)||(clearTimeout(cb.timeoutId),!1))}}getPendingTasks(){return this._taskTrackingZone?this._taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(cb,timeout,updateCb){let timeoutId=-1;timeout&&timeout>0&&(timeoutId=setTimeout(()=>{this._callbacks=this._callbacks.filter(cb=>cb.timeoutId!==timeoutId),cb()},timeout)),this._callbacks.push({doneCb:cb,timeoutId,updateCb})}whenStable(doneCb,timeout,updateCb){if(updateCb&&!this._taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(doneCb,timeout,updateCb),this._runCallbacksIfReady()}registerApplication(token){this.registry.registerApplication(token,this)}unregisterApplication(token){this.registry.unregisterApplication(token)}findProviders(using,provider,exactMatch){return[]}static ɵfac=function Testability_Factory(__ngFactoryType__){return new(__ngFactoryType__||Testability)(ɵɵinject(debug_node_NgZone),ɵɵinject(TestabilityRegistry),ɵɵinject(TESTABILITY_GETTER))};static ɵprov=ɵɵdefineInjectable({token:Testability,factory:Testability.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(Testability,[{type:Injectable}],()=>[{type:debug_node_NgZone},{type:TestabilityRegistry},{type:void 0,decorators:[{type:Inject,args:[TESTABILITY_GETTER]}]}],null);class TestabilityRegistry{_applications=new Map;registerApplication(token,testability){this._applications.set(token,testability)}unregisterApplication(token){this._applications.delete(token)}unregisterAllApplications(){this._applications.clear()}getTestability(elem){return this._applications.get(elem)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(elem,findInAncestors=!0){return _testabilityGetter?.findTestabilityInTree(this,elem,findInAncestors)??null}static ɵfac=function TestabilityRegistry_Factory(__ngFactoryType__){return new(__ngFactoryType__||TestabilityRegistry)};static ɵprov=ɵɵdefineInjectable({token:TestabilityRegistry,factory:TestabilityRegistry.ɵfac,providedIn:"platform"})}let _testabilityGetter;function isPromise(obj){return!!obj&&"function"==typeof obj.then}function isSubscribable(obj){return!!obj&&"function"==typeof obj.subscribe}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(TestabilityRegistry,[{type:Injectable,args:[{providedIn:"platform"}]}],null,null);const APP_INITIALIZER=new InjectionToken(ngDevMode?"Application Initializer":"");class ApplicationInitStatus{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((res,rej)=>{this.resolve=res,this.reject=rej});appInits=root_effect_scheduler_inject(APP_INITIALIZER,{optional:!0})??[];injector=root_effect_scheduler_inject(root_effect_scheduler_Injector);constructor(){if(("undefined"==typeof ngDevMode||ngDevMode)&&!Array.isArray(this.appInits))throw new root_effect_scheduler_RuntimeError(-209,`Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`)}runInitializers(){if(this.initialized)return;const asyncInitPromises=[];for(const appInits of this.appInits){const initResult=runInInjectionContext(this.injector,appInits);if(isPromise(initResult))asyncInitPromises.push(initResult);else if(isSubscribable(initResult)){const observableAsPromise=new Promise((resolve,reject)=>{initResult.subscribe({complete:resolve,error:reject})});asyncInitPromises.push(observableAsPromise)}}const complete=()=>{this.done=!0,this.resolve()};Promise.all(asyncInitPromises).then(()=>{complete()}).catch(e=>{this.reject(e)}),0===asyncInitPromises.length&&complete(),this.initialized=!0}static ɵfac=function ApplicationInitStatus_Factory(__ngFactoryType__){return new(__ngFactoryType__||ApplicationInitStatus)};static ɵprov=ɵɵdefineInjectable({token:ApplicationInitStatus,factory:ApplicationInitStatus.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ApplicationInitStatus,[{type:Injectable,args:[{providedIn:"root"}]}],()=>[],null);const debug_node_APP_BOOTSTRAP_LISTENER=new InjectionToken(ngDevMode?"appBootstrapListener":"");function debug_node_publishSignalConfiguration(){!function setThrowInvalidWriteToSignalError(fn){throwInvalidWriteToSignalErrorFn=fn}(()=>{let errorMessage="";if(ngDevMode){const activeConsumer=getActiveConsumer();errorMessage=activeConsumer&&function isReactiveLViewConsumer(node){return"template"===node.kind}(activeConsumer)?"Writing to signals is not allowed while Angular renders the template (eg. interpolations)":"Writing to signals is not allowed in a `computed`"}throw new root_effect_scheduler_RuntimeError(600,errorMessage)})}function optionsReducer(dst,objs){return Array.isArray(objs)?objs.reduce(optionsReducer,dst):{...dst,...objs}}class debug_node_ApplicationRef{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=root_effect_scheduler_inject(INTERNAL_APPLICATION_ERROR_HANDLER);afterRenderManager=root_effect_scheduler_inject(debug_node_AfterRenderManager);zonelessEnabled=root_effect_scheduler_inject(root_effect_scheduler_ZONELESS_ENABLED);rootEffectScheduler=root_effect_scheduler_inject(EffectScheduler);dirtyFlags=0;tracingSnapshot=null;allTestViews=new Set;autoDetectTestViews=new Set;includeAllTestViews=!1;afterTick=new Subject.B;get allViews(){return[...(this.includeAllTestViews?this.allTestViews:this.autoDetectTestViews).keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];internalPendingTask=root_effect_scheduler_inject(PendingTasksInternal);get isStable(){return this.internalPendingTask.hasPendingTasksObservable.pipe((0,map.T)(pending=>!pending))}constructor(){root_effect_scheduler_inject(debug_node_TracingService,{optional:!0})}whenStable(){let subscription;return new Promise(resolve=>{subscription=this.isStable.subscribe({next:stable=>{stable&&resolve()}})}).finally(()=>{subscription.unsubscribe()})}_injector=root_effect_scheduler_inject(EnvironmentInjector);_rendererFactory=null;get injector(){return this._injector}bootstrap(componentOrFactory,rootSelectorOrNode){return this.bootstrapImpl(componentOrFactory,rootSelectorOrNode)}bootstrapImpl(componentOrFactory,rootSelectorOrNode,injector=root_effect_scheduler_Injector.NULL){return this._injector.get(debug_node_NgZone).run(()=>{debug_node_profiler(10),("undefined"==typeof ngDevMode||ngDevMode)&&warnIfDestroyed(this._destroyed);const isComponentFactory=componentOrFactory instanceof ComponentFactory$1;if(!this._injector.get(ApplicationInitStatus).done){let errorMessage="";if("undefined"==typeof ngDevMode||ngDevMode){errorMessage="Cannot bootstrap as there are still asynchronous initializers running."+(!isComponentFactory&&isStandalone(componentOrFactory)?"":" Bootstrap components in the `ngDoBootstrap` method of the root module.")}throw new root_effect_scheduler_RuntimeError(405,errorMessage)}let componentFactory;if(isComponentFactory)componentFactory=componentOrFactory;else{componentFactory=this._injector.get(ComponentFactoryResolver$1).resolveComponentFactory(componentOrFactory)}this.componentTypes.push(componentFactory.componentType);const ngModule=function isBoundToModule(cf){return cf.isBoundToModule}(componentFactory)?void 0:this._injector.get(NgModuleRef$1),selectorOrNode=rootSelectorOrNode||componentFactory.selector,compRef=componentFactory.create(injector,[],selectorOrNode,ngModule),nativeElement=compRef.location.nativeElement,testability=compRef.injector.get(TESTABILITY,null);if(testability?.registerApplication(nativeElement),compRef.onDestroy(()=>{this.detachView(compRef.hostView),remove(this.components,compRef),testability?.unregisterApplication(nativeElement)}),this._loadComponent(compRef),"undefined"==typeof ngDevMode||ngDevMode){this._injector.get(debug_node_Console).log("Angular is running in development mode.")}return debug_node_profiler(11,compRef),compRef})}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){debug_node_profiler(12),null!==this.tracingSnapshot?this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION,this.tickImpl):this.tickImpl()}tickImpl=()=>{if(("undefined"==typeof ngDevMode||ngDevMode)&&warnIfDestroyed(this._destroyed),this._runningTick)throw new root_effect_scheduler_RuntimeError(101,ngDevMode&&"ApplicationRef.tick is called recursively");const prevConsumer=setActiveConsumer(null);try{if(this._runningTick=!0,this.synchronize(),"undefined"==typeof ngDevMode||ngDevMode)for(let view of this.allViews)view.checkNoChanges()}finally{this._runningTick=!1,this.tracingSnapshot?.dispose(),this.tracingSnapshot=null,setActiveConsumer(prevConsumer),this.afterTick.next(),debug_node_profiler(13)}};synchronize(){null!==this._rendererFactory||this._injector.destroyed||(this._rendererFactory=this._injector.get(RendererFactory2,null,{optional:!0}));let runs=0;for(;0!==this.dirtyFlags&&runs++<10;)debug_node_profiler(14),this.synchronizeOnce(),debug_node_profiler(15);if(("undefined"==typeof ngDevMode||ngDevMode)&&runs>=10)throw new root_effect_scheduler_RuntimeError(103,ngDevMode&&"Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.")}synchronizeOnce(){16&this.dirtyFlags&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush());let ranDetectChanges=!1;if(7&this.dirtyFlags){const useGlobalCheck=Boolean(1&this.dirtyFlags);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView}of this.allViews){if(!useGlobalCheck&&!root_effect_scheduler_requiresRefreshOrTraversal(_lView))continue;detectChangesInternal(_lView,useGlobalCheck&&!this.zonelessEnabled?0:1),ranDetectChanges=!0}if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),23&this.dirtyFlags)return}ranDetectChanges||(this._rendererFactory?.begin?.(),this._rendererFactory?.end?.()),8&this.dirtyFlags&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){this.allViews.some(({_lView})=>root_effect_scheduler_requiresRefreshOrTraversal(_lView))?this.dirtyFlags|=2:this.dirtyFlags&=-8}attachView(viewRef){("undefined"==typeof ngDevMode||ngDevMode)&&warnIfDestroyed(this._destroyed);const view=viewRef;this._views.push(view),view.attachToAppRef(this)}detachView(viewRef){("undefined"==typeof ngDevMode||ngDevMode)&&warnIfDestroyed(this._destroyed);const view=viewRef;remove(this._views,view),view.detachFromAppRef()}_loadComponent(componentRef){this.attachView(componentRef.hostView);try{this.tick()}catch(e){this.internalErrorHandler(e)}this.components.push(componentRef);const listeners=this._injector.get(debug_node_APP_BOOTSTRAP_LISTENER,[]);if(ngDevMode&&!Array.isArray(listeners))throw new root_effect_scheduler_RuntimeError(-209,`Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);listeners.forEach(listener=>listener(componentRef))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(listener=>listener()),this._views.slice().forEach(view=>view.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(callback){return("undefined"==typeof ngDevMode||ngDevMode)&&warnIfDestroyed(this._destroyed),this._destroyListeners.push(callback),()=>remove(this._destroyListeners,callback)}destroy(){if(this._destroyed)throw new root_effect_scheduler_RuntimeError(406,ngDevMode&&"This instance of the `ApplicationRef` has already been destroyed.");const injector=this._injector;injector.destroy&&!injector.destroyed&&injector.destroy()}get viewCount(){return this._views.length}static ɵfac=function ApplicationRef_Factory(__ngFactoryType__){return new(__ngFactoryType__||debug_node_ApplicationRef)};static ɵprov=ɵɵdefineInjectable({token:debug_node_ApplicationRef,factory:debug_node_ApplicationRef.ɵfac,providedIn:"root"})}function warnIfDestroyed(destroyed){destroyed&&console.warn(root_effect_scheduler_formatRuntimeError(406,"This instance of the `ApplicationRef` has already been destroyed."))}function remove(list,el){const index=list.indexOf(el);index>-1&&list.splice(index,1)}function promiseWithResolvers(){let resolve,reject;return{promise:new Promise((res,rej)=>{resolve=res,reject=rej}),resolve,reject}}function scheduleDelayedTrigger(scheduleFn){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(renderPlaceholder(lView,tNode),!shouldTriggerDeferBlock(0,lView))return;const injector=lView[9];storeTriggerCleanupFn(0,debug_node_getLDeferBlockDetails(lView,tNode),scheduleFn(()=>triggerDeferBlock(0,lView,tNode),injector))}function scheduleDelayedPrefetching(scheduleFn){if("undefined"!=typeof ngServerMode&&ngServerMode)return;const lView=root_effect_scheduler_getLView(),injector=lView[9],tNode=root_effect_scheduler_getCurrentTNode(),tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode);if(tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED){storeTriggerCleanupFn(1,debug_node_getLDeferBlockDetails(lView,tNode),scheduleFn(()=>triggerPrefetching(tDetails,lView,tNode),injector))}}function scheduleDelayedHydrating(scheduleFn,lView,tNode){if("undefined"!=typeof ngServerMode&&ngServerMode)return;const injector=lView[9],lDetails=debug_node_getLDeferBlockDetails(lView,tNode),ssrUniqueId=lDetails[6];ngDevMode&&assertSsrIdDefined(ssrUniqueId);storeTriggerCleanupFn(2,lDetails,scheduleFn(()=>debug_node_triggerHydrationFromBlockName(injector,ssrUniqueId),injector))}function triggerPrefetching(tDetails,lView,tNode){triggerResourceLoading(tDetails,lView,tNode)}function triggerResourceLoading(tDetails,lView,tNode){const injector=lView[9],tView=lView[1];if(tDetails.loadingState!==DeferDependenciesLoadingState.NOT_STARTED)return tDetails.loadingPromise??Promise.resolve();const lDetails=debug_node_getLDeferBlockDetails(lView,tNode),primaryBlockTNode=function getPrimaryBlockTNode(tView,tDetails){return root_effect_scheduler_getTNode(tView,tDetails.primaryTmplIndex+27)}(tView,tDetails);tDetails.loadingState=DeferDependenciesLoadingState.IN_PROGRESS,invokeTriggerCleanupFns(1,lDetails);let dependenciesFn=tDetails.dependencyResolverFn;if(ngDevMode){const deferDependencyInterceptor=injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR,null,{optional:!0});deferDependencyInterceptor&&(dependenciesFn=deferDependencyInterceptor.intercept(dependenciesFn))}const removeTask=injector.get(PendingTasks).add();return dependenciesFn?(tDetails.loadingPromise=Promise.allSettled(dependenciesFn()).then(results=>{let failed=!1;const directiveDefs=[],pipeDefs=[];for(const result of results){if("fulfilled"!==result.status){failed=!0;break}{const dependency=result.value,directiveDef=root_effect_scheduler_getComponentDef(dependency)||getDirectiveDef(dependency);if(directiveDef)directiveDefs.push(directiveDef);else{const pipeDef=getPipeDef(dependency);pipeDef&&pipeDefs.push(pipeDef)}}}if(failed){if(tDetails.loadingState=DeferDependenciesLoadingState.FAILED,null===tDetails.errorTmplIndex){const templateLocation=ngDevMode?getTemplateLocationDetails(lView):"",error=new root_effect_scheduler_RuntimeError(-750,ngDevMode&&`Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);handleUncaughtError(lView,error)}}else{tDetails.loadingState=DeferDependenciesLoadingState.COMPLETE;const primaryBlockTView=primaryBlockTNode.tView;if(directiveDefs.length>0){primaryBlockTView.directiveRegistry=addDepsToRegistry(primaryBlockTView.directiveRegistry,directiveDefs);const providers=internalImportProvidersFrom(!1,...directiveDefs.map(def=>def.type));tDetails.providers=providers}pipeDefs.length>0&&(primaryBlockTView.pipeRegistry=addDepsToRegistry(primaryBlockTView.pipeRegistry,pipeDefs))}}),tDetails.loadingPromise.finally(()=>{tDetails.loadingPromise=null,removeTask()})):(tDetails.loadingPromise=Promise.resolve().then(()=>{tDetails.loadingPromise=null,tDetails.loadingState=DeferDependenciesLoadingState.COMPLETE,removeTask()}),tDetails.loadingPromise)}function shouldTriggerDeferBlock(triggerType,lView){if(0===triggerType&&"undefined"!=typeof ngServerMode&&ngServerMode)return!1;const config=lView[9].get(DEFER_BLOCK_CONFIG,null,{optional:!0});return config?.behavior!==DeferBlockBehavior.Manual}function triggerDeferBlock(triggerType,lView,tNode){const tView=lView[1],lContainer=lView[tNode.index];if(ngDevMode&&assertLContainer(lContainer),!shouldTriggerDeferBlock(triggerType,lView))return;const lDetails=debug_node_getLDeferBlockDetails(lView,tNode),tDetails=debug_node_getTDeferBlockDetails(tView,tNode);switch(invokeAllTriggerCleanupFns(lDetails),tDetails.loadingState){case DeferDependenciesLoadingState.NOT_STARTED:renderDeferBlockState(DeferBlockState.Loading,tNode,lContainer),triggerResourceLoading(tDetails,lView,tNode),tDetails.loadingState===DeferDependenciesLoadingState.IN_PROGRESS&&renderDeferStateAfterResourceLoading(tDetails,tNode,lContainer);break;case DeferDependenciesLoadingState.IN_PROGRESS:renderDeferBlockState(DeferBlockState.Loading,tNode,lContainer),renderDeferStateAfterResourceLoading(tDetails,tNode,lContainer);break;case DeferDependenciesLoadingState.COMPLETE:ngDevMode&&assertDeferredDependenciesLoaded(tDetails),renderDeferBlockState(DeferBlockState.Complete,tNode,lContainer);break;case DeferDependenciesLoadingState.FAILED:renderDeferBlockState(DeferBlockState.Error,tNode,lContainer);break;default:ngDevMode&&throwError("Unknown defer block state")}}function debug_node_triggerHydrationFromBlockName(_x,_x2,_x3){return _triggerHydrationFromBlockName.apply(this,arguments)}function _triggerHydrationFromBlockName(){return(_triggerHydrationFromBlockName=(0,asyncToGenerator.A)(function*(injector,blockName,replayQueuedEventsFn){const dehydratedBlockRegistry=injector.get(debug_node_DEHYDRATED_BLOCK_REGISTRY);if(dehydratedBlockRegistry.hydrating.has(blockName))return;const{parentBlockPromise,hydrationQueue}=function getParentBlockHydrationQueue(deferBlockId,injector){const dehydratedBlockRegistry=injector.get(debug_node_DEHYDRATED_BLOCK_REGISTRY),deferBlockParents=injector.get(debug_node_TransferState).get("__nghDeferData__",{});let isTopMostDeferBlock=!1,currentBlockId=deferBlockId,parentBlockPromise=null;const hydrationQueue=[];for(;!isTopMostDeferBlock&&currentBlockId;){ngDevMode&&root_effect_scheduler_assertEqual(hydrationQueue.indexOf(currentBlockId),-1,"Internal error: defer block hierarchy has a cycle."),isTopMostDeferBlock=dehydratedBlockRegistry.has(currentBlockId);const hydratingParentBlock=dehydratedBlockRegistry.hydrating.get(currentBlockId);if(null===parentBlockPromise&&null!=hydratingParentBlock){parentBlockPromise=hydratingParentBlock.promise;break}hydrationQueue.unshift(currentBlockId),currentBlockId=deferBlockParents[currentBlockId].p}return{parentBlockPromise,hydrationQueue}}(blockName,injector);if(0===hydrationQueue.length)return;null!==parentBlockPromise&&hydrationQueue.shift(),function populateHydratingStateForQueue(registry,queue){for(let blockId of queue)registry.hydrating.set(blockId,promiseWithResolvers())}(dehydratedBlockRegistry,hydrationQueue),null!==parentBlockPromise&&(yield parentBlockPromise);const topmostParentBlock=hydrationQueue[0];dehydratedBlockRegistry.has(topmostParentBlock)?yield triggerHydrationForBlockQueue(injector,hydrationQueue,replayQueuedEventsFn):dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock,(0,asyncToGenerator.A)(function*(){return yield triggerHydrationForBlockQueue(injector,hydrationQueue,replayQueuedEventsFn)}))})).apply(this,arguments)}function triggerHydrationForBlockQueue(_x4,_x5,_x6){return _triggerHydrationForBlockQueue.apply(this,arguments)}function _triggerHydrationForBlockQueue(){return(_triggerHydrationForBlockQueue=(0,asyncToGenerator.A)(function*(injector,hydrationQueue,replayQueuedEventsFn){const dehydratedBlockRegistry=injector.get(debug_node_DEHYDRATED_BLOCK_REGISTRY),blocksBeingHydrated=dehydratedBlockRegistry.hydrating,pendingTasks=injector.get(PendingTasksInternal),taskId=pendingTasks.add();for(let blockQueueIdx=0;blockQueueIdx<hydrationQueue.length;blockQueueIdx++){const dehydratedBlockId=hydrationQueue[blockQueueIdx],dehydratedDeferBlock=dehydratedBlockRegistry.get(dehydratedBlockId);if(null==dehydratedDeferBlock){cleanupParentContainer(blockQueueIdx,hydrationQueue,dehydratedBlockRegistry),cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx),dehydratedBlockRegistry);break}if(yield triggerResourceLoadingForHydration(dehydratedDeferBlock),yield nextRender(injector),deferBlockHasErrored(dehydratedDeferBlock)){removeDehydratedViewList(dehydratedDeferBlock),cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx),dehydratedBlockRegistry);break}blocksBeingHydrated.get(dehydratedBlockId).resolve()}const lastBlockName=hydrationQueue[hydrationQueue.length-1];yield blocksBeingHydrated.get(lastBlockName)?.promise,pendingTasks.remove(taskId),replayQueuedEventsFn&&replayQueuedEventsFn(hydrationQueue),cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName),hydrationQueue,dehydratedBlockRegistry,injector.get(debug_node_ApplicationRef))})).apply(this,arguments)}function deferBlockHasErrored(deferBlock){return debug_node_getLDeferBlockDetails(deferBlock.lView,deferBlock.tNode)[1]===DeferBlockState.Error}function cleanupParentContainer(currentBlockIdx,hydrationQueue,dehydratedBlockRegistry){const parentDeferBlockIdx=currentBlockIdx-1,parentDeferBlock=parentDeferBlockIdx>-1?dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]):null;parentDeferBlock&&cleanupLContainer(parentDeferBlock.lContainer)}function cleanupRemainingHydrationQueue(hydrationQueue,dehydratedBlockRegistry){const blocksBeingHydrated=dehydratedBlockRegistry.hydrating;for(const dehydratedBlockId in hydrationQueue)blocksBeingHydrated.get(dehydratedBlockId)?.reject();dehydratedBlockRegistry.cleanup(hydrationQueue)}function nextRender(injector){return new Promise(resolveFn=>afterNextRender(resolveFn,{injector}))}function triggerResourceLoadingForHydration(_x7){return _triggerResourceLoadingForHydration.apply(this,arguments)}function _triggerResourceLoadingForHydration(){return(_triggerResourceLoadingForHydration=(0,asyncToGenerator.A)(function*(dehydratedBlock){const{tNode,lView}=dehydratedBlock,lDetails=debug_node_getLDeferBlockDetails(lView,tNode);return new Promise(resolve=>{!function onDeferBlockCompletion(lDetails,callback){Array.isArray(lDetails[8])||(lDetails[8]=[]);lDetails[8].push(callback)}(lDetails,resolve),triggerDeferBlock(2,lView,tNode)})})).apply(this,arguments)}function shouldAttachTrigger(triggerType,lView,tNode){return 0===triggerType?shouldAttachRegularTrigger(lView,tNode):2===triggerType?!shouldAttachRegularTrigger(lView,tNode):!("undefined"!=typeof ngServerMode&&ngServerMode)}function hasHydrateTriggers(flags){return null!=flags&&!(1&~flags)}function shouldAttachRegularTrigger(lView,tNode){const injector=lView[9],tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode),incrementalHydrationEnabled=debug_node_isIncrementalHydrationEnabled(injector),_hasHydrateTriggers=hasHydrateTriggers(tDetails.flags);if("undefined"!=typeof ngServerMode&&ngServerMode)return!incrementalHydrationEnabled||!_hasHydrateTriggers;const wasServerSideRendered=null!==debug_node_getLDeferBlockDetails(lView,tNode)[6];return!(_hasHydrateTriggers&&wasServerSideRendered&&incrementalHydrationEnabled)}function getHydrateTriggers(tView,tNode){const tDetails=debug_node_getTDeferBlockDetails(tView,tNode);return tDetails.hydrateTriggers??=new Map}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(debug_node_ApplicationRef,[{type:Injectable,args:[{providedIn:"root"}]}],()=>[],null);let _hmrWarningProduced=!1;function ɵɵdefer(index,primaryTmplIndex,dependencyResolverFn,loadingTmplIndex,placeholderTmplIndex,errorTmplIndex,loadingConfigIndex,placeholderConfigIndex,enableTimerScheduling,flags){const lView=root_effect_scheduler_getLView(),tView=getTView(),adjustedIndex=index+27,tNode=declareNoDirectiveHostTemplate(lView,tView,index,null,0,0),injector=lView[9],incrementalHydrationEnabled=debug_node_isIncrementalHydrationEnabled(injector);if(tView.firstCreatePass){debug_node_performanceMarkFeature("NgDefer"),ngDevMode&&("undefined"!=typeof ngHmrMode&&ngHmrMode&&function logHmrWarning(injector){_hmrWarningProduced||(_hmrWarningProduced=!0,injector.get(debug_node_Console).log(root_effect_scheduler_formatRuntimeError(-751,"Angular has detected that this application contains `@defer` blocks and the hot module replacement (HMR) mode is enabled. All `@defer` block dependencies will be loaded eagerly.")))}(injector),hasHydrateTriggers(flags)&&!incrementalHydrationEnabled&&function warnIncrementalHydrationNotConfigured(){incrementalHydrationEnabledWarned||(incrementalHydrationEnabledWarned=!0,console.warn(root_effect_scheduler_formatRuntimeError(508,"Angular has detected that some `@defer` blocks use `hydrate` triggers, but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` call is added as an argument for the `provideClientHydration()` function call in your application config.")))}());const tDetails={primaryTmplIndex,loadingTmplIndex:loadingTmplIndex??null,placeholderTmplIndex:placeholderTmplIndex??null,errorTmplIndex:errorTmplIndex??null,placeholderBlockConfig:null,loadingBlockConfig:null,dependencyResolverFn:dependencyResolverFn??null,loadingState:DeferDependenciesLoadingState.NOT_STARTED,loadingPromise:null,providers:null,hydrateTriggers:null,debug:null,flags:flags??0};enableTimerScheduling?.(tView,tDetails,placeholderConfigIndex,loadingConfigIndex),function setTDeferBlockDetails(tView,deferBlockIndex,deferBlockConfig){const slotIndex=getDeferBlockDataIndex(deferBlockIndex);ngDevMode&&assertIndexInDeclRange(tView,slotIndex),tView.data[slotIndex]=deferBlockConfig}(tView,adjustedIndex,tDetails)}const lContainer=lView[adjustedIndex];populateDehydratedViewsInLContainer(lContainer,tNode,lView);let ssrBlockState=null,ssrUniqueId=null;if(lContainer[6]?.length>0){const info=lContainer[6][0].data;ssrUniqueId=info.di??null,ssrBlockState=info.s}const lDetails=[null,DeferBlockInternalState.Initial,null,null,null,null,ssrUniqueId,ssrBlockState,null,null];!function setLDeferBlockDetails(lView,deferBlockIndex,lDetails){const tView=lView[1],slotIndex=getDeferBlockDataIndex(deferBlockIndex);ngDevMode&&assertIndexInDeclRange(tView,slotIndex),lView[slotIndex]=lDetails}(lView,adjustedIndex,lDetails);let registry=null;null!==ssrUniqueId&&incrementalHydrationEnabled&&(registry=injector.get(debug_node_DEHYDRATED_BLOCK_REGISTRY),registry.add(ssrUniqueId,{lView,tNode,lContainer}));const onLViewDestroy=()=>{invokeAllTriggerCleanupFns(lDetails),null!==ssrUniqueId&&registry?.cleanup([ssrUniqueId])};storeTriggerCleanupFn(0,lDetails,()=>removeLViewOnDestroy(lView,onLViewDestroy)),storeLViewOnDestroy(lView,onLViewDestroy)}function ɵɵdeferWhen(rawValue){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getSelectedTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"when <expression>"),!shouldAttachTrigger(0,lView,tNode))return;if(bindingUpdated(lView,root_effect_scheduler_nextBindingIndex(),rawValue)){const prevConsumer=setActiveConsumer(null);try{const value=Boolean(rawValue),renderedState=debug_node_getLDeferBlockDetails(lView,tNode)[1];!1===value&&renderedState===DeferBlockInternalState.Initial?renderPlaceholder(lView,tNode):!0!==value||renderedState!==DeferBlockInternalState.Initial&&renderedState!==DeferBlockState.Placeholder||triggerDeferBlock(0,lView,tNode)}finally{setActiveConsumer(prevConsumer)}}}function ɵɵdeferPrefetchWhen(rawValue){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getSelectedTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"prefetch when <expression>"),!shouldAttachTrigger(1,lView,tNode))return;if(bindingUpdated(lView,root_effect_scheduler_nextBindingIndex(),rawValue)){const prevConsumer=setActiveConsumer(null);try{const value=Boolean(rawValue),tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode);!0===value&&tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&triggerPrefetching(tDetails,lView,tNode)}finally{setActiveConsumer(prevConsumer)}}}function ɵɵdeferHydrateWhen(rawValue){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getSelectedTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate when <expression>"),!shouldAttachTrigger(2,lView,tNode))return;const bindingIndex=root_effect_scheduler_nextBindingIndex();if(getHydrateTriggers(getTView(),tNode).set(6,null),bindingUpdated(lView,bindingIndex,rawValue))if("undefined"!=typeof ngServerMode&&ngServerMode)triggerDeferBlock(2,lView,tNode);else{const injector=lView[9],prevConsumer=setActiveConsumer(null);try{if(!0===Boolean(rawValue)){const ssrUniqueId=debug_node_getLDeferBlockDetails(lView,tNode)[6];ngDevMode&&assertSsrIdDefined(ssrUniqueId),debug_node_triggerHydrationFromBlockName(injector,ssrUniqueId)}}finally{setActiveConsumer(prevConsumer)}}}function ɵɵdeferHydrateNever(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate never"),!shouldAttachTrigger(2,lView,tNode))return;getHydrateTriggers(getTView(),tNode).set(7,null),"undefined"!=typeof ngServerMode&&ngServerMode&&triggerDeferBlock(2,lView,tNode)}function ɵɵdeferOnIdle(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"on idle"),shouldAttachTrigger(0,lView,tNode)&&scheduleDelayedTrigger(onIdle)}function ɵɵdeferPrefetchOnIdle(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"prefetch on idle"),shouldAttachTrigger(1,lView,tNode)&&scheduleDelayedPrefetching(onIdle)}function ɵɵdeferHydrateOnIdle(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate on idle"),!shouldAttachTrigger(2,lView,tNode))return;getHydrateTriggers(getTView(),tNode).set(0,null),"undefined"!=typeof ngServerMode&&ngServerMode?triggerDeferBlock(2,lView,tNode):scheduleDelayedHydrating(onIdle,lView,tNode)}function ɵɵdeferOnImmediate(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"on immediate"),!shouldAttachTrigger(0,lView,tNode))return;null===debug_node_getTDeferBlockDetails(lView[1],tNode).loadingTmplIndex&&renderPlaceholder(lView,tNode),triggerDeferBlock(0,lView,tNode)}function ɵɵdeferPrefetchOnImmediate(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"prefetch on immediate"),!shouldAttachTrigger(1,lView,tNode))return;const tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&triggerResourceLoading(tDetails,lView,tNode)}function ɵɵdeferHydrateOnImmediate(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate on immediate"),!shouldAttachTrigger(2,lView,tNode))return;if(getHydrateTriggers(getTView(),tNode).set(1,null),"undefined"!=typeof ngServerMode&&ngServerMode)triggerDeferBlock(2,lView,tNode);else{const injector=lView[9],ssrUniqueId=debug_node_getLDeferBlockDetails(lView,tNode)[6];ngDevMode&&assertSsrIdDefined(ssrUniqueId),debug_node_triggerHydrationFromBlockName(injector,ssrUniqueId)}}function ɵɵdeferOnTimer(delay){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,`on timer(${delay}ms)`),shouldAttachTrigger(0,lView,tNode)&&scheduleDelayedTrigger(onTimer(delay))}function ɵɵdeferPrefetchOnTimer(delay){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,`prefetch on timer(${delay}ms)`),shouldAttachTrigger(1,lView,tNode)&&scheduleDelayedPrefetching(onTimer(delay))}function ɵɵdeferHydrateOnTimer(delay){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,`hydrate on timer(${delay}ms)`),!shouldAttachTrigger(2,lView,tNode))return;getHydrateTriggers(getTView(),tNode).set(5,{delay}),"undefined"!=typeof ngServerMode&&ngServerMode?triggerDeferBlock(2,lView,tNode):scheduleDelayedHydrating(onTimer(delay),lView,tNode)}function ɵɵdeferOnHover(triggerIndex,walkUpTimes){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"on hover"+(-1===walkUpTimes?"":"(<target>)")),shouldAttachTrigger(0,lView,tNode)&&(renderPlaceholder(lView,tNode),"undefined"!=typeof ngServerMode&&ngServerMode||registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onHover,()=>triggerDeferBlock(0,lView,tNode),0))}function ɵɵdeferPrefetchOnHover(triggerIndex,walkUpTimes){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"prefetch on hover"+(-1===walkUpTimes?"":"(<target>)")),!shouldAttachTrigger(1,lView,tNode))return;const tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onHover,()=>triggerPrefetching(tDetails,lView,tNode),1)}function ɵɵdeferHydrateOnHover(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate on hover"),!shouldAttachTrigger(2,lView,tNode))return;getHydrateTriggers(getTView(),tNode).set(4,null),"undefined"!=typeof ngServerMode&&ngServerMode&&triggerDeferBlock(2,lView,tNode)}function ɵɵdeferOnInteraction(triggerIndex,walkUpTimes){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"on interaction"+(-1===walkUpTimes?"":"(<target>)")),shouldAttachTrigger(0,lView,tNode)&&(renderPlaceholder(lView,tNode),"undefined"!=typeof ngServerMode&&ngServerMode||registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onInteraction,()=>triggerDeferBlock(0,lView,tNode),0))}function ɵɵdeferPrefetchOnInteraction(triggerIndex,walkUpTimes){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"prefetch on interaction"+(-1===walkUpTimes?"":"(<target>)")),!shouldAttachTrigger(1,lView,tNode))return;const tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onInteraction,()=>triggerPrefetching(tDetails,lView,tNode),1)}function ɵɵdeferHydrateOnInteraction(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate on interaction"),!shouldAttachTrigger(2,lView,tNode))return;getHydrateTriggers(getTView(),tNode).set(3,null),"undefined"!=typeof ngServerMode&&ngServerMode&&triggerDeferBlock(2,lView,tNode)}function ɵɵdeferOnViewport(triggerIndex,walkUpTimes){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"on viewport"+(-1===walkUpTimes?"":"(<target>)")),shouldAttachTrigger(0,lView,tNode)&&(renderPlaceholder(lView,tNode),"undefined"!=typeof ngServerMode&&ngServerMode||registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onViewportWrapper,()=>triggerDeferBlock(0,lView,tNode),0))}function ɵɵdeferPrefetchOnViewport(triggerIndex,walkUpTimes){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"prefetch on viewport"+(-1===walkUpTimes?"":"(<target>)")),!shouldAttachTrigger(1,lView,tNode))return;const tDetails=debug_node_getTDeferBlockDetails(lView[1],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onViewportWrapper,()=>triggerPrefetching(tDetails,lView,tNode),1)}function ɵɵdeferHydrateOnViewport(){const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();if(ngDevMode&&trackTriggerForDebugging(lView[1],tNode,"hydrate on viewport"),!shouldAttachTrigger(2,lView,tNode))return;getHydrateTriggers(getTView(),tNode).set(2,null),"undefined"!=typeof ngServerMode&&ngServerMode&&triggerDeferBlock(2,lView,tNode)}function ɵɵariaProperty(name,value){const lView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=root_effect_scheduler_getSelectedTNode();if(setAllInputsForProperty(tNode,tView,lView,name,value))root_effect_scheduler_isComponentHost(tNode)&&markDirtyIfOnPush(lView,tNode.index),ngDevMode&&setNgReflectProperties(lView,tView,tNode,name,value);else{ngDevMode&&assertTNodeType(tNode,2);const element=root_effect_scheduler_getNativeByTNode(tNode,lView);setElementAttribute(lView[11],element,null,tNode.value,name,value,null)}ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,name,bindingIndex)}return ɵɵariaProperty}function ɵɵattribute(name,value,sanitizer,namespace){const lView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=root_effect_scheduler_getSelectedTNode();elementAttributeInternal(tNode,lView,name,value,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,"attr."+name,bindingIndex)}return ɵɵattribute}const ANIMATIONS_DISABLED=new InjectionToken("undefined"!=typeof ngDevMode&&ngDevMode?"AnimationsDisabled":"",{providedIn:"root",factory:()=>!1}),MAX_ANIMATION_TIMEOUT=new InjectionToken("undefined"!=typeof ngDevMode&&ngDevMode?"MaxAnimationTimeout":"",{providedIn:"root",factory:()=>MAX_ANIMATION_TIMEOUT_DEFAULT}),MAX_ANIMATION_TIMEOUT_DEFAULT=4e3,areAnimationSupported=("undefined"==typeof ngServerMode||!ngServerMode)&&"undefined"!=typeof document&&"function"==typeof document?.documentElement?.getAnimations;function areAnimationsDisabled(lView){return lView[9].get(ANIMATIONS_DISABLED,false)}function assertAnimationTypes(value,instruction){if(null==value||"string"!=typeof value&&"function"!=typeof value)throw new root_effect_scheduler_RuntimeError(650,`'${instruction}' value must be a string of CSS classes or an animation function, got ${stringify(value)}`)}function assertElementNodes(nativeElement,instruction){if(nativeElement.nodeType!==Node.ELEMENT_NODE)throw new root_effect_scheduler_RuntimeError(650,`'${instruction}' can only be used on an element node, got ${stringify(nativeElement.nodeType)}`)}function cleanupEnterClassData(element){const elementData=enterClassMap.get(element);if(elementData){for(const fn of elementData.cleanupFns)fn();enterClassMap.delete(element)}longestAnimations.delete(element)}const noOpAnimationComplete=()=>{},enterClassMap=new WeakMap,longestAnimations=new WeakMap,leavingNodes=new WeakMap;function clearLeavingNodes(tNode,el){const nodes=leavingNodes.get(tNode);if(nodes&&nodes.length>0){const ix=nodes.findIndex(node=>node===el);ix>-1&&nodes.splice(ix,1)}0===nodes?.length&&leavingNodes.delete(tNode)}function cancelLeavingNodes(tNode,lView){const leavingEl=leavingNodes.get(tNode)?.shift(),lContainer=lView[16];if(lContainer){const beforeNode=getBeforeNodeForView(tNode.index,lContainer),previousNode=beforeNode?.previousSibling;leavingEl&&previousNode&&leavingEl===previousNode&&leavingEl.dispatchEvent(new CustomEvent("animationend",{detail:{cancel:!0}}))}}function trackLeavingNodes(tNode,el){leavingNodes.has(tNode)?leavingNodes.get(tNode)?.push(el):leavingNodes.set(tNode,[el])}function getLViewEnterAnimations(lView){const animationData=lView[26]??={};return animationData.enter??=new Map}function getLViewLeaveAnimations(lView){const animationData=lView[26]??={};return animationData.leave??=new Map}function getClassListFromValue(value){const classes="function"==typeof value?value():value;let classList=Array.isArray(classes)?classes:null;return"string"==typeof classes&&(classList=classes.trim().split(/\s+/).filter(k=>k)),classList}function isLongestAnimation(event,nativeElement){const longestAnimation=longestAnimations.get(nativeElement);return void 0===longestAnimation||nativeElement===event.target&&(void 0!==longestAnimation.animationName&&event.animationName===longestAnimation.animationName||void 0!==longestAnimation.propertyName&&event.propertyName===longestAnimation.propertyName)}function addAnimationToLView(animations,tNode,fn){const nodeAnimations=animations.get(tNode.index)??{animateFns:[]};nodeAnimations.animateFns.push(fn),animations.set(tNode.index,nodeAnimations)}function cleanupAfterLeaveAnimations(resolvers,cleanupFns){if(resolvers)for(const fn of resolvers)fn();for(const fn of cleanupFns)fn()}function clearLViewNodeAnimationResolvers(lView,tNode){const nodeAnimations=getLViewLeaveAnimations(lView).get(tNode.index);nodeAnimations&&(nodeAnimations.resolvers=void 0)}function leaveAnimationFunctionCleanup(lView,tNode,nativeElement,resolvers,cleanupFns){clearLeavingNodes(tNode,nativeElement),cleanupAfterLeaveAnimations(resolvers,cleanupFns),clearLViewNodeAnimationResolvers(lView,tNode)}function ɵɵanimateEnter(value){if(debug_node_performanceMarkFeature("NgAnimateEnter"),"undefined"!=typeof ngServerMode&&ngServerMode||!areAnimationSupported)return ɵɵanimateEnter;ngDevMode&&assertAnimationTypes(value,"animate.enter");const lView=root_effect_scheduler_getLView();if(areAnimationsDisabled(lView))return ɵɵanimateEnter;const tNode=root_effect_scheduler_getCurrentTNode();return cancelLeavingNodes(tNode,lView),addAnimationToLView(getLViewEnterAnimations(lView),tNode,()=>function runEnterAnimation(lView,tNode,value){const nativeElement=root_effect_scheduler_getNativeByTNode(tNode,lView);ngDevMode&&assertElementNodes(nativeElement,"animate.enter");const renderer=lView[11],ngZone=lView[9].get(debug_node_NgZone),activeClasses=getClassListFromValue(value),cleanupFns=[],handleEnterAnimationStart=event=>{if(event.target!==nativeElement)return;const eventName=event instanceof AnimationEvent?"animationend":"transitionend";ngZone.runOutsideAngular(()=>{renderer.listen(nativeElement,eventName,handleEnterAnimationEnd)})},handleEnterAnimationEnd=event=>{event.target===nativeElement&&function enterAnimationEnd(event,nativeElement,renderer){const elementData=enterClassMap.get(nativeElement);if(event.target!==nativeElement||!elementData)return;if(isLongestAnimation(event,nativeElement)){event.stopImmediatePropagation();for(const klass of elementData.classList)renderer.removeClass(nativeElement,klass);cleanupEnterClassData(nativeElement)}}(event,nativeElement,renderer)};if(activeClasses&&activeClasses.length>0){ngZone.runOutsideAngular(()=>{cleanupFns.push(renderer.listen(nativeElement,"animationstart",handleEnterAnimationStart)),cleanupFns.push(renderer.listen(nativeElement,"transitionstart",handleEnterAnimationStart))}),function trackEnterClasses(el,classList,cleanupFns){const elementData=enterClassMap.get(el);if(elementData){for(const klass of classList)elementData.classList.push(klass);for(const fn of cleanupFns)elementData.cleanupFns.push(fn)}else enterClassMap.set(el,{classList,cleanupFns})}(nativeElement,activeClasses,cleanupFns);for(const klass of activeClasses)renderer.addClass(nativeElement,klass);ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{if(determineLongestAnimation(nativeElement,longestAnimations,areAnimationSupported),!longestAnimations.has(nativeElement)){for(const klass of activeClasses)renderer.removeClass(nativeElement,klass);cleanupEnterClassData(nativeElement)}})})}}(lView,tNode,value)),initializeAnimationQueueScheduler(lView[9]),queueEnterAnimations(lView[9],getLViewEnterAnimations(lView)),ɵɵanimateEnter}function ɵɵanimateEnterListener(value){if(debug_node_performanceMarkFeature("NgAnimateEnter"),"undefined"!=typeof ngServerMode&&ngServerMode||!areAnimationSupported)return ɵɵanimateEnterListener;ngDevMode&&assertAnimationTypes(value,"animate.enter");const lView=root_effect_scheduler_getLView();if(areAnimationsDisabled(lView))return ɵɵanimateEnterListener;const tNode=root_effect_scheduler_getCurrentTNode();return cancelLeavingNodes(tNode,lView),addAnimationToLView(getLViewEnterAnimations(lView),tNode,()=>function runEnterAnimationFunction(lView,tNode,value){const nativeElement=root_effect_scheduler_getNativeByTNode(tNode,lView);ngDevMode&&assertElementNodes(nativeElement,"animate.enter"),value.call(lView[8],{target:nativeElement,animationComplete:noOpAnimationComplete})}(lView,tNode,value)),initializeAnimationQueueScheduler(lView[9]),queueEnterAnimations(lView[9],getLViewEnterAnimations(lView)),ɵɵanimateEnterListener}function ɵɵanimateLeave(value){if(debug_node_performanceMarkFeature("NgAnimateLeave"),"undefined"!=typeof ngServerMode&&ngServerMode||!areAnimationSupported)return ɵɵanimateLeave;ngDevMode&&assertAnimationTypes(value,"animate.leave");const lView=root_effect_scheduler_getLView();if(areAnimationsDisabled(lView))return ɵɵanimateLeave;const tNode=root_effect_scheduler_getCurrentTNode();return cancelLeavingNodes(tNode,lView),addAnimationToLView(getLViewLeaveAnimations(lView),tNode,()=>function runLeaveAnimations(lView,tNode,value){const{promise,resolve}=promiseWithResolvers(),nativeElement=root_effect_scheduler_getNativeByTNode(tNode,lView);ngDevMode&&assertElementNodes(nativeElement,"animate.leave");const renderer=lView[11],ngZone=lView[9].get(debug_node_NgZone);allLeavingAnimations.add(lView),(getLViewLeaveAnimations(lView).get(tNode.index).resolvers??=[]).push(resolve);const activeClasses=getClassListFromValue(value);activeClasses&&activeClasses.length>0?function animateLeaveClassRunner(el,tNode,lView,classList,renderer,ngZone){!function cancelAnimationsIfRunning(element,renderer){if(!areAnimationSupported)return;const elementData=enterClassMap.get(element);if(elementData&&elementData.classList.length>0&&function elementHasClassList(element,classList){for(const className of classList)if(element.classList.contains(className))return!0;return!1}(element,elementData.classList))for(const klass of elementData.classList)renderer.removeClass(element,klass);cleanupEnterClassData(element)}(el,renderer);const cleanupFns=[],resolvers=getLViewLeaveAnimations(lView).get(tNode.index)?.resolvers,handleOutAnimationEnd=event=>{if(event.target===el&&(event instanceof CustomEvent||isLongestAnimation(event,el))){if(event.stopImmediatePropagation(),longestAnimations.delete(el),clearLeavingNodes(tNode,el),Array.isArray(tNode.projection))for(const item of classList)renderer.removeClass(el,item);cleanupAfterLeaveAnimations(resolvers,cleanupFns),clearLViewNodeAnimationResolvers(lView,tNode)}};ngZone.runOutsideAngular(()=>{cleanupFns.push(renderer.listen(el,"animationend",handleOutAnimationEnd)),cleanupFns.push(renderer.listen(el,"transitionend",handleOutAnimationEnd))}),trackLeavingNodes(tNode,el);for(const item of classList)renderer.addClass(el,item);ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{determineLongestAnimation(el,longestAnimations,areAnimationSupported),longestAnimations.has(el)||(clearLeavingNodes(tNode,el),cleanupAfterLeaveAnimations(resolvers,cleanupFns),clearLViewNodeAnimationResolvers(lView,tNode))})})}(nativeElement,tNode,lView,activeClasses,renderer,ngZone):resolve();return{promise,resolve}}(lView,tNode,value)),initializeAnimationQueueScheduler(lView[9]),ɵɵanimateLeave}function ɵɵanimateLeaveListener(value){if(debug_node_performanceMarkFeature("NgAnimateLeave"),"undefined"!=typeof ngServerMode&&ngServerMode||!areAnimationSupported)return ɵɵanimateLeaveListener;ngDevMode&&assertAnimationTypes(value,"animate.leave");const lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();return cancelLeavingNodes(tNode,lView),allLeavingAnimations.add(lView),addAnimationToLView(getLViewLeaveAnimations(lView),tNode,()=>function runLeaveAnimationFunction(lView,tNode,value){const{promise,resolve}=promiseWithResolvers(),nativeElement=root_effect_scheduler_getNativeByTNode(tNode,lView);ngDevMode&&assertElementNodes(nativeElement,"animate.leave");const cleanupFns=[],renderer=lView[11],animationsDisabled=areAnimationsDisabled(lView),ngZone=lView[9].get(debug_node_NgZone),maxAnimationTimeout=lView[9].get(MAX_ANIMATION_TIMEOUT);(getLViewLeaveAnimations(lView).get(tNode.index).resolvers??=[]).push(resolve);const resolvers=getLViewLeaveAnimations(lView).get(tNode.index)?.resolvers;if(animationsDisabled)leaveAnimationFunctionCleanup(lView,tNode,nativeElement,resolvers,cleanupFns);else{const timeoutId=setTimeout(()=>leaveAnimationFunctionCleanup(lView,tNode,nativeElement,resolvers,cleanupFns),maxAnimationTimeout),event={target:nativeElement,animationComplete:()=>{leaveAnimationFunctionCleanup(lView,tNode,nativeElement,resolvers,cleanupFns),clearTimeout(timeoutId)}};trackLeavingNodes(tNode,nativeElement),ngZone.runOutsideAngular(()=>{cleanupFns.push(renderer.listen(nativeElement,"animationend",()=>{leaveAnimationFunctionCleanup(lView,tNode,nativeElement,resolvers,cleanupFns),clearTimeout(timeoutId)},{once:!0}))}),value.call(lView[8],event)}return{promise,resolve}}(lView,tNode,value)),initializeAnimationQueueScheduler(lView[9]),ɵɵanimateLeaveListener}function ɵɵcomponentInstance(){const instance=root_effect_scheduler_getLView()[15][8];return ngDevMode&&root_effect_scheduler_assertDefined(instance,"Expected component instance to be defined"),instance}class LiveCollection{destroy(item){}updateValue(index,value){}swap(index1,index2){const startIdx=Math.min(index1,index2),endIdx=Math.max(index1,index2),endItem=this.detach(endIdx);if(endIdx-startIdx>1){const startItem=this.detach(startIdx);this.attach(startIdx,endItem),this.attach(endIdx,startItem)}else this.attach(startIdx,endItem)}move(prevIndex,newIdx){this.attach(newIdx,this.detach(prevIndex))}}function valuesMatching(liveIdx,liveValue,newIdx,newValue,trackBy){return liveIdx===newIdx&&Object.is(liveValue,newValue)?1:Object.is(trackBy(liveIdx,liveValue),trackBy(newIdx,newValue))?-1:0}function recordDuplicateKeys(keyToIdx,key,idx){const idxSoFar=keyToIdx.get(key);void 0!==idxSoFar?idxSoFar.add(idx):keyToIdx.set(key,new Set([idx]))}function attachPreviouslyDetached(prevCollection,detachedItems,index,key){return!(void 0===detachedItems||!detachedItems.has(key))&&(prevCollection.attach(index,detachedItems.get(key)),detachedItems.delete(key),!0)}function createOrAttach(liveCollection,detachedItems,trackByFn,index,value){if(attachPreviouslyDetached(liveCollection,detachedItems,index,trackByFn(index,value)))liveCollection.updateValue(index,value);else{const newItem=liveCollection.create(index,value);liveCollection.attach(index,newItem)}}function initLiveItemsInTheFuture(liveCollection,start,end,trackByFn){const keys=new Set;for(let i=start;i<=end;i++)keys.add(trackByFn(i,liveCollection.at(i)));return keys}class UniqueValueMultiKeyMap{kvMap=new Map;_vMap=void 0;has(key){return this.kvMap.has(key)}delete(key){if(!this.has(key))return!1;const value=this.kvMap.get(key);return void 0!==this._vMap&&this._vMap.has(value)?(this.kvMap.set(key,this._vMap.get(value)),this._vMap.delete(value)):this.kvMap.delete(key),!0}get(key){return this.kvMap.get(key)}set(key,value){if(this.kvMap.has(key)){let prevValue=this.kvMap.get(key);if(ngDevMode&&prevValue===value)throw new Error(`Detected a duplicated value ${value} for the key ${key}`);void 0===this._vMap&&(this._vMap=new Map);const vMap=this._vMap;for(;vMap.has(prevValue);)prevValue=vMap.get(prevValue);vMap.set(prevValue,value)}else this.kvMap.set(key,value)}forEach(cb){for(let[key,value]of this.kvMap)if(cb(value,key),void 0!==this._vMap){const vMap=this._vMap;for(;vMap.has(value);)value=vMap.get(value),cb(value,key)}}}function ɵɵconditionalCreate(index,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex,localRefExtractor){debug_node_performanceMarkFeature("NgControlFlow");const lView=root_effect_scheduler_getLView(),tView=getTView();return declareNoDirectiveHostTemplate(lView,tView,index,templateFn,decls,vars,tagName,getConstant(tView.consts,attrsIndex),256,localRefsIndex,localRefExtractor),ɵɵconditionalBranchCreate}function ɵɵconditionalBranchCreate(index,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex,localRefExtractor){debug_node_performanceMarkFeature("NgControlFlow");const lView=root_effect_scheduler_getLView(),tView=getTView();return declareNoDirectiveHostTemplate(lView,tView,index,templateFn,decls,vars,tagName,getConstant(tView.consts,attrsIndex),512,localRefsIndex,localRefExtractor),ɵɵconditionalBranchCreate}function ɵɵconditional(matchingTemplateIndex,contextValue){debug_node_performanceMarkFeature("NgControlFlow");const hostLView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex(),prevMatchingTemplateIndex=hostLView[bindingIndex]!==NO_CHANGE?hostLView[bindingIndex]:-1,prevContainer=-1!==prevMatchingTemplateIndex?getLContainer(hostLView,27+prevMatchingTemplateIndex):void 0;if(bindingUpdated(hostLView,bindingIndex,matchingTemplateIndex)){const prevConsumer=setActiveConsumer(null);try{if(void 0!==prevContainer&&removeLViewFromLContainer(prevContainer,0),-1!==matchingTemplateIndex){const nextLContainerIndex=27+matchingTemplateIndex,nextContainer=getLContainer(hostLView,nextLContainerIndex),templateTNode=getExistingTNode(hostLView[1],nextLContainerIndex),dehydratedView=findAndReconcileMatchingDehydratedViews(nextContainer,templateTNode,hostLView);addLViewToLContainer(nextContainer,createAndRenderEmbeddedLView(hostLView,templateTNode,contextValue,{dehydratedView}),0,shouldAddViewToDom(templateTNode,dehydratedView))}}finally{setActiveConsumer(prevConsumer)}}else if(void 0!==prevContainer){const lView=getLViewFromLContainer(prevContainer,0);void 0!==lView&&(lView[8]=contextValue)}}class RepeaterContext{lContainer;$implicit;$index;constructor(lContainer,$implicit,$index){this.lContainer=lContainer,this.$implicit=$implicit,this.$index=$index}get $count(){return this.lContainer.length-10}}function ɵɵrepeaterTrackByIndex(index){return index}function ɵɵrepeaterTrackByIdentity(_,value){return value}class RepeaterMetadata{hasEmptyBlock;trackByFn;liveCollection;constructor(hasEmptyBlock,trackByFn,liveCollection){this.hasEmptyBlock=hasEmptyBlock,this.trackByFn=trackByFn,this.liveCollection=liveCollection}}function ɵɵrepeaterCreate(index,templateFn,decls,vars,tagName,attrsIndex,trackByFn,trackByUsesComponentInstance,emptyTemplateFn,emptyDecls,emptyVars,emptyTagName,emptyAttrsIndex){debug_node_performanceMarkFeature("NgControlFlow"),ngDevMode&&assertFunction(trackByFn,`A track expression must be a function, was ${typeof trackByFn} instead.`);const lView=root_effect_scheduler_getLView(),tView=getTView(),hasEmptyBlock=void 0!==emptyTemplateFn,hostLView=root_effect_scheduler_getLView(),boundTrackBy=trackByUsesComponentInstance?trackByFn.bind(hostLView[15][8]):trackByFn,metadata=new RepeaterMetadata(hasEmptyBlock,boundTrackBy);hostLView[27+index]=metadata,declareNoDirectiveHostTemplate(lView,tView,index+1,templateFn,decls,vars,tagName,getConstant(tView.consts,attrsIndex),256),hasEmptyBlock&&(ngDevMode&&root_effect_scheduler_assertDefined(emptyDecls,"Missing number of declarations for the empty repeater block."),ngDevMode&&root_effect_scheduler_assertDefined(emptyVars,"Missing number of bindings for the empty repeater block."),declareNoDirectiveHostTemplate(lView,tView,index+2,emptyTemplateFn,emptyDecls,emptyVars,emptyTagName,getConstant(tView.consts,emptyAttrsIndex),512))}class OperationsCounter{created=0;destroyed=0;reset(){this.created=0,this.destroyed=0}recordCreate(){this.created++}recordDestroy(){this.destroyed++}wasReCreated(collectionLen){return collectionLen>0&&this.created===this.destroyed&&this.created===collectionLen}}class LiveCollectionLContainerImpl extends LiveCollection{lContainer;hostLView;templateTNode;operationsCounter=ngDevMode?new OperationsCounter:void 0;needsIndexUpdate=!1;constructor(lContainer,hostLView,templateTNode){super(),this.lContainer=lContainer,this.hostLView=hostLView,this.templateTNode=templateTNode}get length(){return this.lContainer.length-10}at(index){return this.getLView(index)[8].$implicit}attach(index,lView){const dehydratedView=lView[6];this.needsIndexUpdate||=index!==this.length,addLViewToLContainer(this.lContainer,lView,index,shouldAddViewToDom(this.templateTNode,dehydratedView)),function clearDetachAnimationList(lContainer,index){if(lContainer.length<=10)return;const indexInContainer=10+index,viewToDetach=lContainer[indexInContainer],animations=viewToDetach?viewToDetach[26]:void 0;if(viewToDetach&&animations&&animations.detachedLeaveAnimationFns&&animations.detachedLeaveAnimationFns.length>0){!function removeFromAnimationQueue(injector,animationData){const animationQueue=injector.get(ANIMATION_QUEUE);if(animationData.detachedLeaveAnimationFns){for(const animationFn of animationData.detachedLeaveAnimationFns)animationQueue.queue.delete(animationFn);animationData.detachedLeaveAnimationFns=void 0}}(viewToDetach[9],animations),allLeavingAnimations.delete(viewToDetach),animations.detachedLeaveAnimationFns=void 0}}(this.lContainer,index)}detach(index){return this.needsIndexUpdate||=index!==this.length-1,function maybeInitDetachAnimationList(lContainer,index){if(lContainer.length<=10)return;const indexInContainer=10+index,viewToDetach=lContainer[indexInContainer],animations=viewToDetach?viewToDetach[26]:void 0;animations&&animations.leave&&animations.leave.size>0&&(animations.detachedLeaveAnimationFns=[])}(this.lContainer,index),function detachExistingView(lContainer,index){const existingLView=detachView(lContainer,index);return ngDevMode&&assertLView(existingLView),existingLView}(this.lContainer,index)}create(index,value){const dehydratedView=findMatchingDehydratedView(this.lContainer,this.templateTNode.tView.ssrId),embeddedLView=createAndRenderEmbeddedLView(this.hostLView,this.templateTNode,new RepeaterContext(this.lContainer,value,index),{dehydratedView});return this.operationsCounter?.recordCreate(),embeddedLView}destroy(lView){destroyLView(lView[1],lView),this.operationsCounter?.recordDestroy()}updateValue(index,value){this.getLView(index)[8].$implicit=value}reset(){this.needsIndexUpdate=!1,this.operationsCounter?.reset()}updateIndexes(){if(this.needsIndexUpdate)for(let i=0;i<this.length;i++)this.getLView(i)[8].$index=i}getLView(index){return getExistingLViewFromLContainer(this.lContainer,index)}}function ɵɵrepeater(collection){const prevConsumer=setActiveConsumer(null),metadataSlotIdx=getSelectedIndex();try{const hostLView=root_effect_scheduler_getLView(),hostTView=hostLView[1],metadata=hostLView[metadataSlotIdx],containerIndex=metadataSlotIdx+1,lContainer=getLContainer(hostLView,containerIndex);if(void 0===metadata.liveCollection){const itemTemplateTNode=getExistingTNode(hostTView,containerIndex);metadata.liveCollection=new LiveCollectionLContainerImpl(lContainer,hostLView,itemTemplateTNode)}else metadata.liveCollection.reset();const liveCollection=metadata.liveCollection;if(function reconcile(liveCollection,newCollection,trackByFn){let detachedItems,liveKeysInTheFuture,liveStartIdx=0,liveEndIdx=liveCollection.length-1;const duplicateKeys=ngDevMode?new Map:void 0;if(Array.isArray(newCollection)){let newEndIdx=newCollection.length-1;for(;liveStartIdx<=liveEndIdx&&liveStartIdx<=newEndIdx;){const liveStartValue=liveCollection.at(liveStartIdx),newStartValue=newCollection[liveStartIdx];ngDevMode&&recordDuplicateKeys(duplicateKeys,trackByFn(liveStartIdx,newStartValue),liveStartIdx);const isStartMatching=valuesMatching(liveStartIdx,liveStartValue,liveStartIdx,newStartValue,trackByFn);if(0!==isStartMatching){isStartMatching<0&&liveCollection.updateValue(liveStartIdx,newStartValue),liveStartIdx++;continue}const liveEndValue=liveCollection.at(liveEndIdx),newEndValue=newCollection[newEndIdx];ngDevMode&&recordDuplicateKeys(duplicateKeys,trackByFn(newEndIdx,newEndValue),newEndIdx);const isEndMatching=valuesMatching(liveEndIdx,liveEndValue,newEndIdx,newEndValue,trackByFn);if(0!==isEndMatching){isEndMatching<0&&liveCollection.updateValue(liveEndIdx,newEndValue),liveEndIdx--,newEndIdx--;continue}const liveStartKey=trackByFn(liveStartIdx,liveStartValue),liveEndKey=trackByFn(liveEndIdx,liveEndValue),newStartKey=trackByFn(liveStartIdx,newStartValue);if(Object.is(newStartKey,liveEndKey)){const newEndKey=trackByFn(newEndIdx,newEndValue);Object.is(newEndKey,liveStartKey)?(liveCollection.swap(liveStartIdx,liveEndIdx),liveCollection.updateValue(liveEndIdx,newEndValue),newEndIdx--,liveEndIdx--):liveCollection.move(liveEndIdx,liveStartIdx),liveCollection.updateValue(liveStartIdx,newStartValue),liveStartIdx++;continue}if(detachedItems??=new UniqueValueMultiKeyMap,liveKeysInTheFuture??=initLiveItemsInTheFuture(liveCollection,liveStartIdx,liveEndIdx,trackByFn),attachPreviouslyDetached(liveCollection,detachedItems,liveStartIdx,newStartKey))liveCollection.updateValue(liveStartIdx,newStartValue),liveStartIdx++,liveEndIdx++;else if(liveKeysInTheFuture.has(newStartKey))detachedItems.set(liveStartKey,liveCollection.detach(liveStartIdx)),liveEndIdx--;else{const newItem=liveCollection.create(liveStartIdx,newCollection[liveStartIdx]);liveCollection.attach(liveStartIdx,newItem),liveStartIdx++,liveEndIdx++}}for(;liveStartIdx<=newEndIdx;)createOrAttach(liveCollection,detachedItems,trackByFn,liveStartIdx,newCollection[liveStartIdx]),liveStartIdx++}else if(null!=newCollection){const newCollectionIterator=newCollection[Symbol.iterator]();let newIterationResult=newCollectionIterator.next();for(;!newIterationResult.done&&liveStartIdx<=liveEndIdx;){const liveValue=liveCollection.at(liveStartIdx),newValue=newIterationResult.value;ngDevMode&&recordDuplicateKeys(duplicateKeys,trackByFn(liveStartIdx,newValue),liveStartIdx);const isStartMatching=valuesMatching(liveStartIdx,liveValue,liveStartIdx,newValue,trackByFn);if(0!==isStartMatching)isStartMatching<0&&liveCollection.updateValue(liveStartIdx,newValue),liveStartIdx++,newIterationResult=newCollectionIterator.next();else{detachedItems??=new UniqueValueMultiKeyMap,liveKeysInTheFuture??=initLiveItemsInTheFuture(liveCollection,liveStartIdx,liveEndIdx,trackByFn);const newKey=trackByFn(liveStartIdx,newValue);if(attachPreviouslyDetached(liveCollection,detachedItems,liveStartIdx,newKey))liveCollection.updateValue(liveStartIdx,newValue),liveStartIdx++,liveEndIdx++,newIterationResult=newCollectionIterator.next();else if(liveKeysInTheFuture.has(newKey)){const liveKey=trackByFn(liveStartIdx,liveValue);detachedItems.set(liveKey,liveCollection.detach(liveStartIdx)),liveEndIdx--}else liveCollection.attach(liveStartIdx,liveCollection.create(liveStartIdx,newValue)),liveStartIdx++,liveEndIdx++,newIterationResult=newCollectionIterator.next()}}for(;!newIterationResult.done;)createOrAttach(liveCollection,detachedItems,trackByFn,liveCollection.length,newIterationResult.value),newIterationResult=newCollectionIterator.next()}for(;liveStartIdx<=liveEndIdx;)liveCollection.destroy(liveCollection.detach(liveEndIdx--));if(detachedItems?.forEach(item=>{liveCollection.destroy(item)}),ngDevMode){let duplicatedKeysMsg=[];for(const[key,idxSet]of duplicateKeys)if(idxSet.size>1){const idx=[...idxSet].sort((a,b)=>a-b);for(let i=1;i<idx.length;i++)duplicatedKeysMsg.push(`key "${root_effect_scheduler_stringifyForError(key)}" at index "${idx[i-1]}" and "${idx[i]}"`)}if(duplicatedKeysMsg.length>0){const message=root_effect_scheduler_formatRuntimeError(-955,"The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n"+duplicatedKeysMsg.join(", \n")+".");console.warn(message)}}}(liveCollection,collection,metadata.trackByFn),ngDevMode&&metadata.trackByFn===ɵɵrepeaterTrackByIdentity&&liveCollection.operationsCounter?.wasReCreated(liveCollection.length)&&function isViewExpensiveToRecreate(lView){return lView.length-27>2}(getExistingLViewFromLContainer(lContainer,0))){const message=root_effect_scheduler_formatRuntimeError(-956,`The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);console.warn(message)}if(liveCollection.updateIndexes(),metadata.hasEmptyBlock){const bindingIndex=root_effect_scheduler_nextBindingIndex(),isCollectionEmpty=0===liveCollection.length;if(bindingUpdated(hostLView,bindingIndex,isCollectionEmpty)){const emptyTemplateIndex=metadataSlotIdx+2,lContainerForEmpty=getLContainer(hostLView,emptyTemplateIndex);if(isCollectionEmpty){const emptyTemplateTNode=getExistingTNode(hostTView,emptyTemplateIndex),dehydratedView=findAndReconcileMatchingDehydratedViews(lContainerForEmpty,emptyTemplateTNode,hostLView);addLViewToLContainer(lContainerForEmpty,createAndRenderEmbeddedLView(hostLView,emptyTemplateTNode,void 0,{dehydratedView}),0,shouldAddViewToDom(emptyTemplateTNode,dehydratedView))}else hostTView.firstUpdatePass&&removeDehydratedViews(lContainerForEmpty),removeLViewFromLContainer(lContainerForEmpty,0)}}}finally{setActiveConsumer(prevConsumer)}}function getLContainer(lView,index){const lContainer=lView[index];return ngDevMode&&assertLContainer(lContainer),lContainer}function getExistingLViewFromLContainer(lContainer,index){const existingLView=getLViewFromLContainer(lContainer,index);return ngDevMode&&assertLView(existingLView),existingLView}function getExistingTNode(tView,index){const tNode=root_effect_scheduler_getTNode(tView,index);return ngDevMode&&root_effect_scheduler_assertTNode(tNode),tNode}function ɵɵproperty(propName,value,sanitizer){const lView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=root_effect_scheduler_getSelectedTNode();setPropertyAndInputs(tNode,lView,propName,value,lView[11],sanitizer),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵproperty}function setDirectiveInputsWhichShadowsStyling(tView,tNode,lView,value,isClassBased){setAllInputsForProperty(tNode,tView,lView,isClassBased?"class":"style",value)}function ɵɵelementStart(index,name,attrsIndex,localRefsIndex){const lView=root_effect_scheduler_getLView();ngDevMode&&assertTNodeCreationIndex(lView,index);const tView=lView[1],adjustedIndex=index+27,tNode=tView.firstCreatePass?directiveHostFirstCreatePass(adjustedIndex,lView,2,name,findDirectiveDefMatches,getBindingsEnabled(),attrsIndex,localRefsIndex):tView.data[adjustedIndex];if(elementLikeStartShared(tNode,lView,index,name,_locateOrCreateElementNode),isDirectiveHost(tNode)){const tView=lView[1];createDirectivesInstances(tView,lView,tNode),executeContentQueries(tView,tNode,lView)}return null!=localRefsIndex&&saveResolvedLocalsInData(lView,tNode),ngDevMode&&lView[1].firstCreatePass&&validateElementIsKnown(lView,tNode),ɵɵelementStart}function ɵɵelementEnd(){const tView=getTView(),initialTNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&root_effect_scheduler_assertDefined(initialTNode,"No parent node to close.");const currentTNode=elementLikeEndShared(initialTNode);return ngDevMode&&assertTNodeType(currentTNode,3),tView.firstCreatePass&&directiveHostEndFirstCreatePass(tView,currentTNode),isSkipHydrationRootTNode(currentTNode)&&leaveSkipHydrationBlock(),decreaseElementDepthCount(),null!=currentTNode.classesWithoutHost&&function hasClassInput(tNode){return!!(8&tNode.flags)}(currentTNode)&&setDirectiveInputsWhichShadowsStyling(tView,currentTNode,root_effect_scheduler_getLView(),currentTNode.classesWithoutHost,!0),null!=currentTNode.stylesWithoutHost&&function hasStyleInput(tNode){return!!(16&tNode.flags)}(currentTNode)&&setDirectiveInputsWhichShadowsStyling(tView,currentTNode,root_effect_scheduler_getLView(),currentTNode.stylesWithoutHost,!1),ɵɵelementEnd}function ɵɵelement(index,name,attrsIndex,localRefsIndex){return ɵɵelementStart(index,name,attrsIndex,localRefsIndex),ɵɵelementEnd(),ɵɵelement}function ɵɵdomElementStart(index,name,attrsIndex,localRefsIndex){const lView=root_effect_scheduler_getLView();ngDevMode&&assertTNodeCreationIndex(lView,index);const tView=lView[1],adjustedIndex=index+27,tNode=tView.firstCreatePass?domOnlyFirstCreatePass(adjustedIndex,tView,2,name,attrsIndex,localRefsIndex):tView.data[adjustedIndex];return elementLikeStartShared(tNode,lView,index,name,_locateOrCreateElementNode),null!=localRefsIndex&&saveResolvedLocalsInData(lView,tNode),ngDevMode&&lView[1].firstCreatePass&&validateElementIsKnown(lView,tNode),ɵɵdomElementStart}function ɵɵdomElementEnd(){const initialTNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&root_effect_scheduler_assertDefined(initialTNode,"No parent node to close.");const currentTNode=elementLikeEndShared(initialTNode);return ngDevMode&&assertTNodeType(currentTNode,3),isSkipHydrationRootTNode(currentTNode)&&leaveSkipHydrationBlock(),decreaseElementDepthCount(),ɵɵdomElementEnd}function ɵɵdomElement(index,name,attrsIndex,localRefsIndex){return ɵɵdomElementStart(index,name,attrsIndex,localRefsIndex),ɵɵdomElementEnd(),ɵɵdomElement}let _locateOrCreateElementNode=(tView,lView,tNode,name,index)=>(root_effect_scheduler_lastNodeWasCreated(!0),createElementNode(lView[11],name,function root_effect_scheduler_getNamespace(){return instructionState.lFrame.currentNamespace}()));function ɵɵelementContainerStart(index,attrsIndex,localRefsIndex){const lView=root_effect_scheduler_getLView();ngDevMode&&assertTNodeCreationIndex(lView,index);const tView=lView[1],adjustedIndex=index+27,tNode=tView.firstCreatePass?directiveHostFirstCreatePass(adjustedIndex,lView,8,"ng-container",findDirectiveDefMatches,getBindingsEnabled(),attrsIndex,localRefsIndex):tView.data[adjustedIndex];if(elementLikeStartShared(tNode,lView,index,"ng-container",_locateOrCreateElementContainerNode),isDirectiveHost(tNode)){const tView=lView[1];createDirectivesInstances(tView,lView,tNode),executeContentQueries(tView,tNode,lView)}return null!=localRefsIndex&&saveResolvedLocalsInData(lView,tNode),ɵɵelementContainerStart}function ɵɵelementContainerEnd(){const tView=getTView(),initialTNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&root_effect_scheduler_assertDefined(initialTNode,"No parent node to close.");const currentTNode=elementLikeEndShared(initialTNode);return tView.firstCreatePass&&directiveHostEndFirstCreatePass(tView,currentTNode),ngDevMode&&assertTNodeType(currentTNode,8),ɵɵelementContainerEnd}function ɵɵelementContainer(index,attrsIndex,localRefsIndex){return ɵɵelementContainerStart(index,attrsIndex,localRefsIndex),ɵɵelementContainerEnd(),ɵɵelementContainer}function ɵɵdomElementContainerStart(index,attrsIndex,localRefsIndex){const lView=root_effect_scheduler_getLView();ngDevMode&&assertTNodeCreationIndex(lView,index);const tView=lView[1],adjustedIndex=index+27,tNode=tView.firstCreatePass?domOnlyFirstCreatePass(adjustedIndex,tView,8,"ng-container",attrsIndex,localRefsIndex):tView.data[adjustedIndex];return elementLikeStartShared(tNode,lView,index,"ng-container",_locateOrCreateElementContainerNode),null!=localRefsIndex&&saveResolvedLocalsInData(lView,tNode),ɵɵdomElementContainerStart}function ɵɵdomElementContainerEnd(){const initialTNode=root_effect_scheduler_getCurrentTNode();ngDevMode&&root_effect_scheduler_assertDefined(initialTNode,"No parent node to close.");const currentTNode=elementLikeEndShared(initialTNode);return ngDevMode&&assertTNodeType(currentTNode,8),ɵɵelementContainerEnd}function ɵɵdomElementContainer(index,attrsIndex,localRefsIndex){return ɵɵdomElementContainerStart(index,attrsIndex,localRefsIndex),ɵɵdomElementContainerEnd(),ɵɵdomElementContainer}let _locateOrCreateElementContainerNode=(tView,lView,tNode,commentText,index)=>(root_effect_scheduler_lastNodeWasCreated(!0),createCommentNode(lView[11],ngDevMode?commentText:""));function ɵɵgetCurrentView(){return root_effect_scheduler_getLView()}function ɵɵdomProperty(propName,value,sanitizer){const lView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=root_effect_scheduler_getSelectedTNode();setDomProperty(tNode,lView,propName,value,lView[11],sanitizer),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵdomProperty}function ɵɵsyntheticHostProperty(propName,value,sanitizer){const lView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=root_effect_scheduler_getSelectedTNode();setDomProperty(tNode,lView,propName,value,loadComponentRenderer(getCurrentDirectiveDef(tView.data),tNode,lView),sanitizer),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵsyntheticHostProperty}const u=void 0;var localeEn=["en",[["a","p"],["AM","PM"]],[["AM","PM"]],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],u,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],u,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",u,"{1} 'at' {0}",u],[".",",",";","%","+","-","E","×","‰","∞","NaN",":"],["#,##0.###","#,##0%","¤#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function plural(val){const i=Math.floor(Math.abs(val)),v=val.toString().replace(/^[^.]*\.?/,"").length;return 1===i&&0===v?1:5}];let LOCALE_DATA={};function findLocaleData(locale){const normalizedLocale=function normalizeLocale(locale){return locale.toLowerCase().replace(/_/g,"-")}(locale);let match=getLocaleData(normalizedLocale);if(match)return match;const parentLocale=normalizedLocale.split("-")[0];if(match=getLocaleData(parentLocale),match)return match;if("en"===parentLocale)return localeEn;throw new root_effect_scheduler_RuntimeError(701,ngDevMode&&`Missing locale data for the locale "${locale}".`)}function getLocaleData(normalizedLocale){return normalizedLocale in LOCALE_DATA||(LOCALE_DATA[normalizedLocale]=root_effect_scheduler_global.ng&&root_effect_scheduler_global.ng.common&&root_effect_scheduler_global.ng.common.locales&&root_effect_scheduler_global.ng.common.locales[normalizedLocale]),LOCALE_DATA[normalizedLocale]}var LocaleDataIndex;!function(LocaleDataIndex){LocaleDataIndex[LocaleDataIndex.LocaleId=0]="LocaleId",LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat=1]="DayPeriodsFormat",LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone=2]="DayPeriodsStandalone",LocaleDataIndex[LocaleDataIndex.DaysFormat=3]="DaysFormat",LocaleDataIndex[LocaleDataIndex.DaysStandalone=4]="DaysStandalone",LocaleDataIndex[LocaleDataIndex.MonthsFormat=5]="MonthsFormat",LocaleDataIndex[LocaleDataIndex.MonthsStandalone=6]="MonthsStandalone",LocaleDataIndex[LocaleDataIndex.Eras=7]="Eras",LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek=8]="FirstDayOfWeek",LocaleDataIndex[LocaleDataIndex.WeekendRange=9]="WeekendRange",LocaleDataIndex[LocaleDataIndex.DateFormat=10]="DateFormat",LocaleDataIndex[LocaleDataIndex.TimeFormat=11]="TimeFormat",LocaleDataIndex[LocaleDataIndex.DateTimeFormat=12]="DateTimeFormat",LocaleDataIndex[LocaleDataIndex.NumberSymbols=13]="NumberSymbols",LocaleDataIndex[LocaleDataIndex.NumberFormats=14]="NumberFormats",LocaleDataIndex[LocaleDataIndex.CurrencyCode=15]="CurrencyCode",LocaleDataIndex[LocaleDataIndex.CurrencySymbol=16]="CurrencySymbol",LocaleDataIndex[LocaleDataIndex.CurrencyName=17]="CurrencyName",LocaleDataIndex[LocaleDataIndex.Currencies=18]="Currencies",LocaleDataIndex[LocaleDataIndex.Directionality=19]="Directionality",LocaleDataIndex[LocaleDataIndex.PluralCase=20]="PluralCase",LocaleDataIndex[LocaleDataIndex.ExtraData=21]="ExtraData"}(LocaleDataIndex||(LocaleDataIndex={}));const pluralMapping=["zero","one","two","few","many"];function getPluralCase(value,locale){const plural=function getLocalePluralCase(locale){return findLocaleData(locale)[LocaleDataIndex.PluralCase]}(locale)(parseInt(value,10)),result=pluralMapping[plural];return void 0!==result?result:"other"}const ELEMENT_MARKER={marker:"element"},ICU_MARKER={marker:"ICU"};var I18nCreateOpCode;!function(I18nCreateOpCode){I18nCreateOpCode[I18nCreateOpCode.SHIFT=2]="SHIFT",I18nCreateOpCode[I18nCreateOpCode.APPEND_EAGERLY=1]="APPEND_EAGERLY",I18nCreateOpCode[I18nCreateOpCode.COMMENT=2]="COMMENT"}(I18nCreateOpCode||(I18nCreateOpCode={}));let LOCALE_ID$1="en-US";let changeMask=0,changeMaskCounter=0;function createNodeWithoutHydration(lView,textOrName,nodeType){const renderer=lView[11];switch(nodeType){case Node.COMMENT_NODE:return createCommentNode(renderer,textOrName);case Node.TEXT_NODE:return createTextNode(renderer,textOrName);case Node.ELEMENT_NODE:return createElementNode(renderer,textOrName,null)}}let _locateOrCreateNode=(lView,index,textOrName,nodeType)=>(root_effect_scheduler_lastNodeWasCreated(!0),createNodeWithoutHydration(lView,textOrName,nodeType));function applyMutableOpCodes(tView,mutableOpCodes,lView,anchorRNode){ngDevMode&&assertDomNode(anchorRNode);const renderer=lView[11];let rootRNode,rootIdx=null;for(let i=0;i<mutableOpCodes.length;i++){const opCode=mutableOpCodes[i];if("string"==typeof opCode){const textNodeIndex=mutableOpCodes[++i];null===lView[textNodeIndex]&&(ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,textNodeIndex),lView[textNodeIndex]=_locateOrCreateNode(lView,textNodeIndex,opCode,Node.TEXT_NODE))}else if("number"==typeof opCode)switch(1&opCode){case 0:const parentIdx=getParentFromIcuCreateOpCode(opCode);let insertInFrontOf,parentRNode;if(null===rootIdx&&(rootIdx=parentIdx,rootRNode=renderer.parentNode(anchorRNode)),parentIdx===rootIdx?(insertInFrontOf=anchorRNode,parentRNode=rootRNode):(insertInFrontOf=null,parentRNode=root_effect_scheduler_unwrapRNode(lView[parentIdx])),null!==parentRNode){ngDevMode&&assertDomNode(parentRNode);const refIdx=getRefFromIcuCreateOpCode(opCode);ngDevMode&&assertGreaterThan(refIdx,27,"Missing ref");const child=lView[refIdx];ngDevMode&&assertDomNode(child),nativeInsertBefore(renderer,parentRNode,child,insertInFrontOf,!1);const tIcu=getTIcu(tView,refIdx);if(null!==tIcu&&"object"==typeof tIcu){ngDevMode&&root_effect_scheduler_assertTIcu(tIcu);const caseIndex=getCurrentICUCaseIndex(tIcu,lView);null!==caseIndex&&applyMutableOpCodes(tView,tIcu.create[caseIndex],lView,lView[tIcu.anchorIdx])}}break;case 1:const elementNodeIndex=opCode>>>1,attrName=mutableOpCodes[++i],attrValue=mutableOpCodes[++i];setElementAttribute(renderer,getNativeByIndex(elementNodeIndex,lView),null,null,attrName,attrValue,null);break;default:if(ngDevMode)throw new root_effect_scheduler_RuntimeError(700,`Unable to determine the type of mutate operation for "${opCode}"`)}else switch(opCode){case ICU_MARKER:const commentValue=mutableOpCodes[++i],commentNodeIndex=mutableOpCodes[++i];if(null===lView[commentNodeIndex]){ngDevMode&&root_effect_scheduler_assertEqual(typeof commentValue,"string",`Expected "${commentValue}" to be a comment node value`),ngDevMode&&assertIndexInExpandoRange(lView,commentNodeIndex);attachPatchData(lView[commentNodeIndex]=_locateOrCreateNode(lView,commentNodeIndex,commentValue,Node.COMMENT_NODE),lView)}break;case ELEMENT_MARKER:const tagName=mutableOpCodes[++i],elementNodeIndex=mutableOpCodes[++i];if(null===lView[elementNodeIndex]){ngDevMode&&root_effect_scheduler_assertEqual(typeof tagName,"string",`Expected "${tagName}" to be an element node tag name`),ngDevMode&&assertIndexInExpandoRange(lView,elementNodeIndex);attachPatchData(lView[elementNodeIndex]=_locateOrCreateNode(lView,elementNodeIndex,tagName,Node.ELEMENT_NODE),lView)}break;default:ngDevMode&&throwError(`Unable to determine the type of mutate operation for "${opCode}"`)}}}function applyUpdateOpCodes(tView,lView,updateOpCodes,bindingsStartIndex,changeMask){for(let i=0;i<updateOpCodes.length;i++){const checkBit=updateOpCodes[i],skipCodes=updateOpCodes[++i];if(checkBit&changeMask){let value="";for(let j=i+1;j<=i+skipCodes;j++){const opCode=updateOpCodes[j];if("string"==typeof opCode)value+=opCode;else if("number"==typeof opCode)if(opCode<0)value+=root_effect_scheduler_renderStringify(lView[bindingsStartIndex-opCode]);else{const nodeIndex=opCode>>>2;switch(3&opCode){case 1:const propName=updateOpCodes[++j],sanitizeFn=updateOpCodes[++j],tNodeOrTagName=tView.data[nodeIndex];ngDevMode&&root_effect_scheduler_assertDefined(tNodeOrTagName,"Experting TNode or string"),"string"==typeof tNodeOrTagName?setElementAttribute(lView[11],lView[nodeIndex],null,tNodeOrTagName,propName,value,sanitizeFn):setPropertyAndInputs(tNodeOrTagName,lView,propName,value,lView[11],sanitizeFn);break;case 0:const rText=lView[nodeIndex];null!==rText&&updateTextNode(lView[11],rText,value);break;case 2:applyIcuSwitchCase(tView,getTIcu(tView,nodeIndex),lView,value);break;case 3:applyIcuUpdateCase(tView,getTIcu(tView,nodeIndex),bindingsStartIndex,lView)}}}}else{const opCode=updateOpCodes[i+1];if(opCode>0&&!(3&~opCode)){const tIcu=getTIcu(tView,opCode>>>2);lView[tIcu.currentCaseLViewIndex]<0&&applyIcuUpdateCase(tView,tIcu,bindingsStartIndex,lView)}}i+=skipCodes}}function applyIcuUpdateCase(tView,tIcu,bindingsStartIndex,lView){ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,tIcu.currentCaseLViewIndex);let activeCaseIndex=lView[tIcu.currentCaseLViewIndex];if(null!==activeCaseIndex){let mask=changeMask;activeCaseIndex<0&&(activeCaseIndex=lView[tIcu.currentCaseLViewIndex]=~activeCaseIndex,mask=-1),applyUpdateOpCodes(tView,lView,tIcu.update[activeCaseIndex],bindingsStartIndex,mask)}}function applyIcuSwitchCase(tView,tIcu,lView,value){const caseIndex=function getCaseIndex(icuExpression,bindingValue){let index=icuExpression.cases.indexOf(bindingValue);if(-1===index)switch(icuExpression.type){case 1:{const resolvedCase=getPluralCase(bindingValue,function getLocaleId(){return LOCALE_ID$1}());index=icuExpression.cases.indexOf(resolvedCase),-1===index&&"other"!==resolvedCase&&(index=icuExpression.cases.indexOf("other"));break}case 0:index=icuExpression.cases.indexOf("other")}return-1===index?null:index}(tIcu,value);if(getCurrentICUCaseIndex(tIcu,lView)!==caseIndex&&(applyIcuSwitchCaseRemove(tView,tIcu,lView),lView[tIcu.currentCaseLViewIndex]=null===caseIndex?null:~caseIndex,null!==caseIndex)){const anchorRNode=lView[tIcu.anchorIdx];anchorRNode&&(ngDevMode&&assertDomNode(anchorRNode),applyMutableOpCodes(tView,tIcu.create[caseIndex],lView,anchorRNode)),function claimDehydratedIcuCase(lView,icuIndex,caseIndex){_claimDehydratedIcuCaseImpl(lView,icuIndex,caseIndex)}(lView,tIcu.anchorIdx,caseIndex)}}function applyIcuSwitchCaseRemove(tView,tIcu,lView){let activeCaseIndex=getCurrentICUCaseIndex(tIcu,lView);if(null!==activeCaseIndex){const removeCodes=tIcu.remove[activeCaseIndex];for(let i=0;i<removeCodes.length;i++){const nodeOrIcuIndex=removeCodes[i];if(nodeOrIcuIndex>0){const rNode=getNativeByIndex(nodeOrIcuIndex,lView);null!==rNode&&nativeRemoveNode(lView[11],rNode)}else applyIcuSwitchCaseRemove(tView,getTIcu(tView,~nodeOrIcuIndex),lView)}}}function i18nCreateOpCodesToString(opcodes){const createOpCodes=opcodes||(Array.isArray(this)?this:[]);let lines=[];for(let i=0;i<createOpCodes.length;i++){const opCode=createOpCodes[i++],text=createOpCodes[i],isComment=(opCode&I18nCreateOpCode.COMMENT)===I18nCreateOpCode.COMMENT,appendNow=(opCode&I18nCreateOpCode.APPEND_EAGERLY)===I18nCreateOpCode.APPEND_EAGERLY,index=opCode>>>I18nCreateOpCode.SHIFT;lines.push(`lView[${index}] = document.${isComment?"createComment":"createText"}(${JSON.stringify(text)});`),appendNow&&lines.push(`parent.appendChild(lView[${index}]);`)}return lines}function i18nUpdateOpCodesToString(opcodes){const parser=new OpCodeParser(opcodes||(Array.isArray(this)?this:[]));let lines=[];function consumeOpCode(value){const ref=value>>>2,opCode=3&value;switch(opCode){case 0:return`(lView[${ref}] as Text).textContent = $$$`;case 1:const attrName=parser.consumeString(),sanitizationFn=parser.consumeFunction();return`(lView[${ref}] as Element).setAttribute('${attrName}', ${sanitizationFn?`(${sanitizationFn})($$$)`:"$$$"})`;case 2:return`icuSwitchCase(${ref}, $$$)`;case 3:return`icuUpdateCase(${ref})`}throw new Error("unexpected OpCode")}for(;parser.hasMore();){let mask=parser.consumeNumber(),size=parser.consumeNumber();const end=parser.i+size,statements=[];let statement="";for(;parser.i<end;){let value=parser.consumeNumberOrString();if("string"==typeof value)statement+=value;else if(value<0)statement+="${lView[i"+value+"]}";else{const opCodeText=consumeOpCode(value);statements.push(opCodeText.replace("$$$","`"+statement+"`")+";"),statement=""}}lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`)}return lines}function icuCreateOpCodesToString(opcodes){const parser=new OpCodeParser(opcodes||(Array.isArray(this)?this:[]));let lines=[];function consumeOpCode(opCode){const parent=getParentFromIcuCreateOpCode(opCode),ref=getRefFromIcuCreateOpCode(opCode);switch(getInstructionFromIcuCreateOpCode(opCode)){case 0:return`(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;case 1:return`(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`}throw new Error("Unexpected OpCode: "+getInstructionFromIcuCreateOpCode(opCode))}let lastRef=-1;for(;parser.hasMore();){let value=parser.consumeNumberStringOrMarker();if(value===ICU_MARKER){const text=parser.consumeString();lastRef=parser.consumeNumber(),lines.push(`lView[${lastRef}] = document.createComment("${text}")`)}else if(value===ELEMENT_MARKER){const text=parser.consumeString();lastRef=parser.consumeNumber(),lines.push(`lView[${lastRef}] = document.createElement("${text}")`)}else if("string"==typeof value)lastRef=parser.consumeNumber(),lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);else{if("number"!=typeof value)throw new Error("Unexpected value");{const line=consumeOpCode(value);line&&lines.push(line)}}}return lines}function i18nRemoveOpCodesToString(opcodes){const removeCodes=opcodes||(Array.isArray(this)?this:[]);let lines=[];for(let i=0;i<removeCodes.length;i++){const nodeOrIcuIndex=removeCodes[i];nodeOrIcuIndex>0?lines.push(`remove(lView[${nodeOrIcuIndex}])`):lines.push(`removeNestedICU(${~nodeOrIcuIndex})`)}return lines}class OpCodeParser{i=0;codes;constructor(codes){this.codes=codes}hasMore(){return this.i<this.codes.length}consumeNumber(){let value=this.codes[this.i++];return root_effect_scheduler_assertNumber(value,"expecting number in OpCode"),value}consumeString(){let value=this.codes[this.i++];return assertString(value,"expecting string in OpCode"),value}consumeFunction(){let value=this.codes[this.i++];if(null===value||"function"==typeof value)return value;throw new Error("expecting function in OpCode")}consumeNumberOrString(){let value=this.codes[this.i++];return"string"==typeof value||root_effect_scheduler_assertNumber(value,"expecting number or string in OpCode"),value}consumeNumberStringOrMarker(){let value=this.codes[this.i++];return"string"==typeof value||"number"==typeof value||value==ICU_MARKER||value==ELEMENT_MARKER||root_effect_scheduler_assertNumber(value,"expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode"),value}}const BINDING_REGEXP=/�(\d+):?\d*�/gi,ICU_REGEXP=/({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi,NESTED_ICU=/�(\d+)�/,ICU_BLOCK_REGEXP=/^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/,SUBTEMPLATE_REGEXP=/�\/?\*(\d+:\d+)�/gi,PH_REGEXP=/�(\/?[#*]\d+):?\d*�/gi,NGSP_UNICODE_REGEXP=/\uE500/g;function attachDebugGetter(obj,debugGetter){if(!ngDevMode)throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");Object.defineProperty(obj,"debug",{get:debugGetter,enumerable:!1})}function i18nStartFirstCreatePass(tView,parentTNodeIndex,lView,index,message,subTemplateIndex){const rootTNode=getCurrentParentTNode(),createOpCodes=[],updateOpCodes=[],existingTNodeStack=[[]],astStack=[[]];ngDevMode&&(attachDebugGetter(createOpCodes,i18nCreateOpCodesToString),attachDebugGetter(updateOpCodes,i18nUpdateOpCodesToString)),message=function getTranslationForTemplate(message,subTemplateIndex){if(isRootTemplateMessage(subTemplateIndex))return removeInnerTemplateTranslation(message);{const start=message.indexOf(`:${subTemplateIndex}�`)+2+subTemplateIndex.toString().length,end=message.search(new RegExp(`�\\/\\*\\d+:${subTemplateIndex}�`));return removeInnerTemplateTranslation(message.substring(start,end))}}(message,subTemplateIndex);const msgParts=function replaceNgsp(value){return value.replace(NGSP_UNICODE_REGEXP," ")}(message).split(PH_REGEXP);for(let i=0;i<msgParts.length;i++){let value=msgParts[i];if(1&i){const isClosing=47===value.charCodeAt(0),type=value.charCodeAt(isClosing?1:0);ngDevMode&&assertOneOf(type,42,35);const index=27+Number.parseInt(value.substring(isClosing?2:1));if(isClosing)existingTNodeStack.shift(),astStack.shift(),setCurrentTNode(getCurrentParentTNode(),!1);else{const tNode=createTNodePlaceholder(tView,existingTNodeStack[0],index);existingTNodeStack.unshift([]),setCurrentTNode(tNode,!0);const placeholderNode={kind:2,index,children:[],type:35===type?0:1};astStack[0].push(placeholderNode),astStack.unshift(placeholderNode.children)}}else{const parts=i18nParseTextIntoPartsAndICU(value);for(let j=0;j<parts.length;j++){let part=parts[j];if(1&j){const icuExpression=part;if("object"!=typeof icuExpression)throw new Error(`Unable to parse ICU expression in "${message}" message.`);const icuNodeIndex=createTNodeAndAddOpCode(tView,rootTNode,existingTNodeStack[0],lView,createOpCodes,ngDevMode?`ICU ${index}:${icuExpression.mainBinding}`:"",!0).index;ngDevMode&&assertGreaterThanOrEqual(icuNodeIndex,27,"Index must be in absolute LView offset"),icuStart(astStack[0],tView,lView,updateOpCodes,parentTNodeIndex,icuExpression,icuNodeIndex)}else{const text=part;ngDevMode&&assertString(text,"Parsed ICU part should be string"),""!==text&&i18nStartFirstCreatePassProcessTextNode(astStack[0],tView,rootTNode,existingTNodeStack[0],createOpCodes,updateOpCodes,lView,text)}}}}tView.data[index]={create:createOpCodes,update:updateOpCodes,ast:astStack[0],parentTNodeIndex}}function createTNodeAndAddOpCode(tView,rootTNode,existingTNodes,lView,createOpCodes,text,isICU){const i18nNodeIdx=allocExpando(tView,lView,1,null);let opCode=i18nNodeIdx<<I18nCreateOpCode.SHIFT,parentTNode=getCurrentParentTNode();rootTNode===parentTNode&&(parentTNode=null),null===parentTNode&&(opCode|=I18nCreateOpCode.APPEND_EAGERLY),isICU&&(opCode|=I18nCreateOpCode.COMMENT,function ensureIcuContainerVisitorLoaded(loader){void 0===_icuContainerIterate&&(_icuContainerIterate=loader())}(loadIcuContainerVisitor)),createOpCodes.push(opCode,null===text?"":text);const tNode=createTNodeAtIndex(tView,i18nNodeIdx,isICU?32:1,null===text?ngDevMode?"{{?}}":"":text,null);addTNodeAndUpdateInsertBeforeIndex(existingTNodes,tNode);const tNodeIdx=tNode.index;return setCurrentTNode(tNode,!1),null!==parentTNode&&rootTNode!==parentTNode&&function setTNodeInsertBeforeIndex(tNode,index){ngDevMode&&root_effect_scheduler_assertTNode(tNode);let insertBeforeIndex=tNode.insertBeforeIndex;null===insertBeforeIndex?(setI18nHandling(getInsertInFrontOfRNodeWithI18n,processI18nInsertBefore),insertBeforeIndex=tNode.insertBeforeIndex=[null,index]):(root_effect_scheduler_assertEqual(Array.isArray(insertBeforeIndex),!0,"Expecting array here"),insertBeforeIndex.push(index))}(parentTNode,tNodeIdx),tNode}function i18nStartFirstCreatePassProcessTextNode(ast,tView,rootTNode,existingTNodes,createOpCodes,updateOpCodes,lView,text){const hasBinding=text.match(BINDING_REGEXP),index=createTNodeAndAddOpCode(tView,rootTNode,existingTNodes,lView,createOpCodes,hasBinding?null:text,!1).index;hasBinding&&generateBindingUpdateOpCodes(updateOpCodes,text,index,null,0,null),ast.push({kind:0,index})}function generateBindingUpdateOpCodes(updateOpCodes,str,destinationNode,attrName,bindingStart,sanitizeFn){ngDevMode&&assertGreaterThanOrEqual(destinationNode,27,"Index must be in absolute LView offset");const maskIndex=updateOpCodes.length,sizeIndex=maskIndex+1;updateOpCodes.push(null,null);const startIndex=maskIndex+2;ngDevMode&&attachDebugGetter(updateOpCodes,i18nUpdateOpCodesToString);const textParts=str.split(BINDING_REGEXP);let mask=0;for(let j=0;j<textParts.length;j++){const textValue=textParts[j];if(1&j){const bindingIndex=bindingStart+parseInt(textValue,10);updateOpCodes.push(-1-bindingIndex),mask|=toMaskBit(bindingIndex)}else""!==textValue&&updateOpCodes.push(textValue)}return updateOpCodes.push(destinationNode<<2|(attrName?1:0)),attrName&&updateOpCodes.push(attrName,sanitizeFn),updateOpCodes[maskIndex]=mask,updateOpCodes[sizeIndex]=updateOpCodes.length-startIndex,mask}function countBindings(opCodes){let count=0;for(let i=0;i<opCodes.length;i++){const opCode=opCodes[i];"number"==typeof opCode&&opCode<0&&count++}return count}function toMaskBit(bindingIndex){return 1<<Math.min(bindingIndex,31)}function removeInnerTemplateTranslation(message){let match,tagMatched,res="",index=0,inTemplate=!1;for(;null!==(match=SUBTEMPLATE_REGEXP.exec(message));)inTemplate?match[0]===`�/*${tagMatched}�`&&(index=match.index,inTemplate=!1):(res+=message.substring(index,match.index+match[0].length),tagMatched=match[1],inTemplate=!0);return ngDevMode&&root_effect_scheduler_assertEqual(inTemplate,!1,`Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`),res+=message.slice(index),res}function icuStart(ast,tView,lView,updateOpCodes,parentIdx,icuExpression,anchorIdx){ngDevMode&&root_effect_scheduler_assertDefined(icuExpression,"ICU expression must be defined");let bindingMask=0;const tIcu={type:icuExpression.type,currentCaseLViewIndex:allocExpando(tView,lView,1,null),anchorIdx,cases:[],create:[],remove:[],update:[]};!function addUpdateIcuSwitch(update,icuExpression,index){update.push(toMaskBit(icuExpression.mainBinding),2,-1-icuExpression.mainBinding,index<<2|2)}(updateOpCodes,icuExpression,anchorIdx),function setTIcu(tView,index,tIcu){const tNode=tView.data[index];ngDevMode&&root_effect_scheduler_assertEqual(null===tNode||tNode.hasOwnProperty("tView"),!0,"We expect to get 'null'|'TIcuContainer'"),null===tNode?tView.data[index]=tIcu:(ngDevMode&&assertTNodeType(tNode,32),tNode.value=tIcu)}(tView,anchorIdx,tIcu);const values=icuExpression.values,cases=[];for(let i=0;i<values.length;i++){const valueArr=values[i],nestedIcus=[];for(let j=0;j<valueArr.length;j++){const value=valueArr[j];if("string"!=typeof value){const icuIndex=nestedIcus.push(value)-1;valueArr[j]=`\x3c!--�${icuIndex}�--\x3e`}}const caseAst=[];cases.push(caseAst),bindingMask=parseIcuCase(caseAst,tView,tIcu,lView,updateOpCodes,parentIdx,icuExpression.cases[i],valueArr.join(""),nestedIcus)|bindingMask}bindingMask&&function addUpdateIcuUpdate(update,bindingMask,index){update.push(bindingMask,1,index<<2|3)}(updateOpCodes,bindingMask,anchorIdx),ast.push({kind:3,index:anchorIdx,cases,currentCaseLViewIndex:tIcu.currentCaseLViewIndex})}function parseICUBlock(pattern){const cases=[],values=[];let icuType=1,mainBinding=0;const parts=i18nParseTextIntoPartsAndICU(pattern=pattern.replace(ICU_BLOCK_REGEXP,function(str,binding,type){return icuType="select"===type?0:1,mainBinding=parseInt(binding.slice(1),10),""}));for(let pos=0;pos<parts.length;){let key=parts[pos++].trim();1===icuType&&(key=key.replace(/\s*(?:=)?(\w+)\s*/,"$1")),key.length&&cases.push(key);const blocks=i18nParseTextIntoPartsAndICU(parts[pos++]);cases.length>values.length&&values.push(blocks)}return{type:icuType,mainBinding,cases,values}}function i18nParseTextIntoPartsAndICU(pattern){if(!pattern)return[];let prevPos=0;const braceStack=[],results=[],braces=/[{}]/g;let match;for(braces.lastIndex=0;match=braces.exec(pattern);){const pos=match.index;if("}"==match[0]){if(braceStack.pop(),0==braceStack.length){const block=pattern.substring(prevPos,pos);ICU_BLOCK_REGEXP.test(block)?results.push(parseICUBlock(block)):results.push(block),prevPos=pos+1}}else{if(0==braceStack.length){const substring=pattern.substring(prevPos,pos);results.push(substring),prevPos=pos+1}braceStack.push("{")}}const substring=pattern.substring(prevPos);return results.push(substring),results}function parseIcuCase(ast,tView,tIcu,lView,updateOpCodes,parentIdx,caseName,unsafeCaseHtml,nestedIcus){const create=[],remove=[],update=[];ngDevMode&&(attachDebugGetter(create,icuCreateOpCodesToString),attachDebugGetter(remove,i18nRemoveOpCodesToString),attachDebugGetter(update,i18nUpdateOpCodesToString)),tIcu.cases.push(caseName),tIcu.create.push(create),tIcu.remove.push(remove),tIcu.update.push(update);const inertBodyElement=getInertBodyHelper(debug_node_getDocument()).getInertBodyElement(unsafeCaseHtml);ngDevMode&&root_effect_scheduler_assertDefined(inertBodyElement,"Unable to generate inert body element");const inertRootNode=getTemplateContent(inertBodyElement)||inertBodyElement;return inertRootNode?walkIcuTree(ast,tView,tIcu,lView,updateOpCodes,create,remove,update,inertRootNode,parentIdx,nestedIcus,0):0}function walkIcuTree(ast,tView,tIcu,lView,sharedUpdateOpCodes,create,remove,update,parentNode,parentIdx,nestedIcus,depth){let bindingMask=0,currentNode=parentNode.firstChild;for(;currentNode;){const newIndex=allocExpando(tView,lView,1,null);switch(currentNode.nodeType){case Node.ELEMENT_NODE:const element=currentNode,tagName=element.tagName.toLowerCase();if(VALID_ELEMENTS.hasOwnProperty(tagName)){addCreateNodeAndAppend(create,ELEMENT_MARKER,tagName,parentIdx,newIndex),tView.data[newIndex]=tagName;const elAttrs=element.attributes;for(let i=0;i<elAttrs.length;i++){const attr=elAttrs.item(i),lowerAttrName=attr.name.toLowerCase();!!attr.value.match(BINDING_REGEXP)?VALID_ATTRS.hasOwnProperty(lowerAttrName)?URI_ATTRS[lowerAttrName]?generateBindingUpdateOpCodes(update,attr.value,newIndex,attr.name,0,_sanitizeUrl):generateBindingUpdateOpCodes(update,attr.value,newIndex,attr.name,0,null):ngDevMode&&console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`):addCreateAttribute(create,newIndex,attr)}const elementNode={kind:1,index:newIndex,children:[]};ast.push(elementNode),bindingMask=walkIcuTree(elementNode.children,tView,tIcu,lView,sharedUpdateOpCodes,create,remove,update,currentNode,newIndex,nestedIcus,depth+1)|bindingMask,addRemoveNode(remove,newIndex,depth)}break;case Node.TEXT_NODE:const value=currentNode.textContent||"",hasBinding=value.match(BINDING_REGEXP);addCreateNodeAndAppend(create,null,hasBinding?"":value,parentIdx,newIndex),addRemoveNode(remove,newIndex,depth),hasBinding&&(bindingMask=generateBindingUpdateOpCodes(update,value,newIndex,null,0,null)|bindingMask),ast.push({kind:0,index:newIndex});break;case Node.COMMENT_NODE:const isNestedIcu=NESTED_ICU.exec(currentNode.textContent||"");if(isNestedIcu){const nestedIcuIndex=parseInt(isNestedIcu[1],10),icuExpression=nestedIcus[nestedIcuIndex];addCreateNodeAndAppend(create,ICU_MARKER,ngDevMode?`nested ICU ${nestedIcuIndex}`:"",parentIdx,newIndex),icuStart(ast,tView,lView,sharedUpdateOpCodes,parentIdx,icuExpression,newIndex),addRemoveNestedIcu(remove,newIndex,depth)}}currentNode=currentNode.nextSibling}return bindingMask}function addRemoveNode(remove,index,depth){0===depth&&remove.push(index)}function addRemoveNestedIcu(remove,index,depth){0===depth&&(remove.push(~index),remove.push(index))}function addCreateNodeAndAppend(create,marker,text,appendToParentIdx,createAtIdx){null!==marker&&create.push(marker),create.push(text,createAtIdx,function icuCreateOpCode(opCode,parentIdx,refIdx){return ngDevMode&&assertGreaterThanOrEqual(parentIdx,0,"Missing parent index"),ngDevMode&&assertGreaterThan(refIdx,0,"Missing ref index"),opCode|parentIdx<<17|refIdx<<1}(0,appendToParentIdx,createAtIdx))}function addCreateAttribute(create,newIndex,attr){create.push(newIndex<<1|1,attr.name,attr.value)}const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP=/\[(�.+?�?)\]/,PP_PLACEHOLDERS_REGEXP=/\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g,PP_ICU_VARS_REGEXP=/({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g,PP_ICU_PLACEHOLDERS_REGEXP=/{([A-Z0-9_]+)}/g,PP_ICUS_REGEXP=/�I18N_EXP_(ICU(_\d+)?)�/g,PP_CLOSE_TEMPLATE_REGEXP=/\/\*/,PP_TEMPLATE_ID_REGEXP=/\d+\:(\d+)/;function ɵɵi18nStart(index,messageIndex,subTemplateIndex=-1){const tView=getTView(),lView=root_effect_scheduler_getLView(),adjustedIndex=27+index;ngDevMode&&root_effect_scheduler_assertDefined(tView,"tView should be defined");const message=getConstant(tView.consts,messageIndex),parentTNode=getCurrentParentTNode();if(tView.firstCreatePass&&i18nStartFirstCreatePass(tView,null===parentTNode?0:parentTNode.index,lView,adjustedIndex,message,subTemplateIndex),2===tView.type){lView[15][2]|=32}else lView[2]|=32;const tI18n=tView.data[adjustedIndex],parentRNode=getClosestRElement(tView,parentTNode===lView[5]?null:parentTNode,lView),insertInFrontOf=parentTNode&&8&parentTNode.type?lView[parentTNode.index]:null;!function prepareI18nBlockForHydration(lView,index,parentTNode,subTemplateIndex){_prepareI18nBlockForHydrationImpl(lView,index,parentTNode,subTemplateIndex)}(lView,adjustedIndex,parentTNode,subTemplateIndex),function applyCreateOpCodes(lView,createOpCodes,parentRNode,insertInFrontOf){const renderer=lView[11];for(let i=0;i<createOpCodes.length;i++){const opCode=createOpCodes[i++],text=createOpCodes[i],isComment=(opCode&I18nCreateOpCode.COMMENT)===I18nCreateOpCode.COMMENT,appendNow=(opCode&I18nCreateOpCode.APPEND_EAGERLY)===I18nCreateOpCode.APPEND_EAGERLY,index=opCode>>>I18nCreateOpCode.SHIFT;let rNode=lView[index],lastNodeWasCreated=!1;null===rNode&&(rNode=lView[index]=_locateOrCreateNode(lView,index,text,isComment?Node.COMMENT_NODE:Node.TEXT_NODE),lastNodeWasCreated=wasLastNodeCreated()),appendNow&&null!==parentRNode&&lastNodeWasCreated&&nativeInsertBefore(renderer,parentRNode,rNode,insertInFrontOf,!1)}}(lView,tI18n.create,parentRNode,insertInFrontOf),setInI18nBlock(!0)}function ɵɵi18nEnd(){setInI18nBlock(!1)}function ɵɵi18n(index,messageIndex,subTemplateIndex){ɵɵi18nStart(index,messageIndex,subTemplateIndex),ɵɵi18nEnd()}function ɵɵi18nAttributes(index,attrsIndex){const tView=getTView();ngDevMode&&root_effect_scheduler_assertDefined(tView,"tView should be defined");!function i18nAttributesFirstPass(tView,index,values){const previousElementIndex=root_effect_scheduler_getCurrentTNode().index,updateOpCodes=[];if(ngDevMode&&attachDebugGetter(updateOpCodes,i18nUpdateOpCodesToString),tView.firstCreatePass&&null===tView.data[index]){for(let i=0;i<values.length;i+=2){const attrName=values[i],message=values[i+1];if(""!==message){if(ICU_REGEXP.test(message))throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);generateBindingUpdateOpCodes(updateOpCodes,message,previousElementIndex,attrName,countBindings(updateOpCodes),null)}}tView.data[index]=updateOpCodes}}(tView,index+27,getConstant(tView.consts,attrsIndex))}function ɵɵi18nExp(value){return function setMaskBit(hasChange){hasChange&&(changeMask|=1<<Math.min(changeMaskCounter,31)),changeMaskCounter++}(bindingUpdated(root_effect_scheduler_getLView(),root_effect_scheduler_nextBindingIndex(),value)),ɵɵi18nExp}function ɵɵi18nApply(index){!function applyI18n(tView,lView,index){if(changeMaskCounter>0){ngDevMode&&root_effect_scheduler_assertDefined(tView,"tView should be defined");const tI18n=tView.data[index];applyUpdateOpCodes(tView,lView,Array.isArray(tI18n)?tI18n:tI18n.update,getBindingIndex()-changeMaskCounter-1,changeMask)}changeMask=0,changeMaskCounter=0}(getTView(),root_effect_scheduler_getLView(),index+27)}function ɵɵi18nPostprocess(message,replacements={}){return function i18nPostprocess(message,replacements={}){let result=message;if(PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)){const matches={},templateIdsStack=[0];result=result.replace(PP_PLACEHOLDERS_REGEXP,(m,phs,tmpl)=>{const content=phs||tmpl,placeholders=matches[content]||[];if(placeholders.length||(content.split("|").forEach(placeholder=>{const match=placeholder.match(PP_TEMPLATE_ID_REGEXP),templateId=match?parseInt(match[1],10):0,isCloseTemplateTag=PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);placeholders.push([templateId,isCloseTemplateTag,placeholder])}),matches[content]=placeholders),!placeholders.length)throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);const currentTemplateId=templateIdsStack[templateIdsStack.length-1];let idx=0;for(let i=0;i<placeholders.length;i++)if(placeholders[i][0]===currentTemplateId){idx=i;break}const[templateId,isCloseTemplateTag,placeholder]=placeholders[idx];return isCloseTemplateTag?templateIdsStack.pop():currentTemplateId!==templateId&&templateIdsStack.push(templateId),placeholders.splice(idx,1),placeholder})}return Object.keys(replacements).length?(result=result.replace(PP_ICU_VARS_REGEXP,(match,start,key,_type,_idx,end)=>replacements.hasOwnProperty(key)?`${start}${replacements[key]}${end}`:match),result=result.replace(PP_ICU_PLACEHOLDERS_REGEXP,(match,key)=>replacements.hasOwnProperty(key)?replacements[key]:match),result=result.replace(PP_ICUS_REGEXP,(match,key)=>{if(replacements.hasOwnProperty(key)){const list=replacements[key];if(!list.length)throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);return list.shift()}return match}),result):result}(message,replacements)}function ɵɵlistener(eventName,listenerFn,eventTargetResolver){const lView=root_effect_scheduler_getLView(),tView=getTView(),tNode=root_effect_scheduler_getCurrentTNode();return listenerInternal(tView,lView,lView[11],tNode,eventName,listenerFn,eventTargetResolver),ɵɵlistener}function ɵɵsyntheticHostListener(eventName,listenerFn){const tNode=root_effect_scheduler_getCurrentTNode(),lView=root_effect_scheduler_getLView(),tView=getTView();return listenerInternal(tView,lView,loadComponentRenderer(getCurrentDirectiveDef(tView.data),tNode,lView),tNode,eventName,listenerFn),ɵɵsyntheticHostListener}function ɵɵdomListener(eventName,listenerFn,eventTargetResolver){const lView=root_effect_scheduler_getLView(),tView=getTView(),tNode=root_effect_scheduler_getCurrentTNode();return(3&tNode.type||eventTargetResolver)&&listenToDomEvent(tNode,tView,lView,eventTargetResolver,lView[11],eventName,listenerFn,wrapListener(tNode,lView,listenerFn)),ɵɵdomListener}function listenerInternal(tView,lView,renderer,tNode,eventName,listenerFn,eventTargetResolver){ngDevMode&&assertTNodeType(tNode,15);let processOutputs=!0,wrappedListener=null;if(3&tNode.type||eventTargetResolver){wrappedListener??=wrapListener(tNode,lView,listenerFn);listenToDomEvent(tNode,tView,lView,eventTargetResolver,renderer,eventName,listenerFn,wrappedListener)&&(processOutputs=!1)}if(processOutputs){const outputConfig=tNode.outputs?.[eventName],hostDirectiveOutputConfig=tNode.hostDirectiveOutputs?.[eventName];if(hostDirectiveOutputConfig&&hostDirectiveOutputConfig.length)for(let i=0;i<hostDirectiveOutputConfig.length;i+=2){const index=hostDirectiveOutputConfig[i],lookupName=hostDirectiveOutputConfig[i+1];wrappedListener??=wrapListener(tNode,lView,listenerFn),listenToOutput(tNode,lView,index,lookupName,eventName,wrappedListener)}if(outputConfig&&outputConfig.length)for(const index of outputConfig)wrappedListener??=wrapListener(tNode,lView,listenerFn),listenToOutput(tNode,lView,index,eventName,eventName,wrappedListener)}}function ɵɵnextContext(level=1){return function nextContextImpl(level){return(instructionState.lFrame.contextLView=walkUpViews(level,instructionState.lFrame.contextLView))[8]}(level)}function matchingProjectionSlotIndex(tNode,projectionSlots){let wildcardNgContentIndex=null;const ngProjectAsAttrVal=function getProjectAsAttrValue(tNode){const nodeAttrs=tNode.attrs;if(null!=nodeAttrs){const ngProjectAsAttrIdx=nodeAttrs.indexOf(5);if(!(1&ngProjectAsAttrIdx))return nodeAttrs[ngProjectAsAttrIdx+1]}return null}(tNode);for(let i=0;i<projectionSlots.length;i++){const slotValue=projectionSlots[i];if("*"!==slotValue){if(null===ngProjectAsAttrVal?isNodeMatchingSelectorList(tNode,slotValue,!0):isSelectorInSelectorList(ngProjectAsAttrVal,slotValue))return i}else wildcardNgContentIndex=i}return wildcardNgContentIndex}function ɵɵprojectionDef(projectionSlots){const componentNode=root_effect_scheduler_getLView()[15][5];if(!componentNode.projection){const numProjectionSlots=projectionSlots?projectionSlots.length:1,projectionHeads=componentNode.projection=newArray(numProjectionSlots,null),tails=projectionHeads.slice();let componentChild=componentNode.child;for(;null!==componentChild;){if(128!==componentChild.type){const slotIndex=projectionSlots?matchingProjectionSlotIndex(componentChild,projectionSlots):0;null!==slotIndex&&(tails[slotIndex]?tails[slotIndex].projectionNext=componentChild:projectionHeads[slotIndex]=componentChild,tails[slotIndex]=componentChild)}componentChild=componentChild.next}}}function ɵɵprojection(nodeIndex,selectorIndex=0,attrs,fallbackTemplateFn,fallbackDecls,fallbackVars){const lView=root_effect_scheduler_getLView(),tView=getTView(),fallbackIndex=fallbackTemplateFn?nodeIndex+1:null;null!==fallbackIndex&&declareNoDirectiveHostTemplate(lView,tView,fallbackIndex,fallbackTemplateFn,fallbackDecls,fallbackVars,null,attrs);const tProjectionNode=getOrCreateTNode(tView,27+nodeIndex,16,null,attrs||null);null===tProjectionNode.projection&&(tProjectionNode.projection=selectorIndex),setCurrentTNodeAsNotParent();const isNodeCreationMode=!lView[6]||root_effect_scheduler_isInSkipHydrationBlock();null===lView[15][5].projection[tProjectionNode.projection]&&null!==fallbackIndex?function insertFallbackContent(lView,tView,fallbackIndex){const adjustedIndex=27+fallbackIndex,fallbackTNode=tView.data[adjustedIndex],fallbackLContainer=lView[adjustedIndex];ngDevMode&&root_effect_scheduler_assertTNode(fallbackTNode),ngDevMode&&assertLContainer(fallbackLContainer);const dehydratedView=findMatchingDehydratedView(fallbackLContainer,fallbackTNode.tView.ssrId),fallbackLView=createAndRenderEmbeddedLView(lView,fallbackTNode,void 0,{dehydratedView});addLViewToLContainer(fallbackLContainer,fallbackLView,0,shouldAddViewToDom(fallbackTNode,dehydratedView))}(lView,tView,fallbackIndex):isNodeCreationMode&&!debug_node_isDetachedByI18n(tProjectionNode)&&function applyProjection(tView,lView,tProjectionNode){applyProjectionRecursive(lView[11],0,lView,tProjectionNode,getParentRElement(tView,tProjectionNode,lView),getInsertInFrontOfRNode(tProjectionNode.parent||lView[5],tProjectionNode,lView))}(tView,lView,tProjectionNode)}function ɵɵcontentQuery(directiveIndex,predicate,flags,read){createContentQuery(directiveIndex,predicate,flags,read)}function ɵɵviewQuery(predicate,flags,read){createViewQuery(predicate,flags,read)}function ɵɵqueryRefresh(queryList){const lView=root_effect_scheduler_getLView(),tView=getTView(),queryIndex=getCurrentQueryIndex();setCurrentQueryIndex(queryIndex+1);const tQuery=getTQuery(tView,queryIndex);if(queryList.dirty&&isCreationMode(lView)===!(2&~tQuery.metadata.flags)){if(null===tQuery.matches)queryList.reset([]);else{const result=getQueryResults(lView,queryIndex);queryList.reset(result,unwrapElementRef),queryList.notifyOnChanges()}return!0}return!1}function ɵɵloadQuery(){return loadQueryInternal(root_effect_scheduler_getLView(),getCurrentQueryIndex())}function ɵɵcontentQuerySignal(directiveIndex,target,predicate,flags,read){bindQueryToSignal(target,createContentQuery(directiveIndex,predicate,flags,read))}function ɵɵviewQuerySignal(target,predicate,flags,read){bindQueryToSignal(target,createViewQuery(predicate,flags,read))}function ɵɵqueryAdvance(indexOffset=1){setCurrentQueryIndex(getCurrentQueryIndex()+indexOffset)}function ɵɵreference(index){return load(getContextLView(),27+index)}function toTStylingRange(prev,next){return ngDevMode&&assertNumberInRange(prev,0,32767),ngDevMode&&assertNumberInRange(next,0,32767),prev<<17|next<<2}function getTStylingRangePrev(tStylingRange){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),tStylingRange>>17&32767}function setTStylingRangePrevDuplicate(tStylingRange){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),2|tStylingRange}function getTStylingRangeNext(tStylingRange){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),(131068&tStylingRange)>>2}function setTStylingRangeNext(tStylingRange,next){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),ngDevMode&&assertNumberInRange(next,0,32767),-131069&tStylingRange|next<<2}function setTStylingRangeNextDuplicate(tStylingRange){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),1|tStylingRange}function insertTStylingBinding(tData,tNode,tStylingKeyWithStatic,index,isHostBinding,isClassBinding){ngDevMode&&assertFirstUpdatePass(getTView());let tBindings=isClassBinding?tNode.classBindings:tNode.styleBindings,tmplHead=getTStylingRangePrev(tBindings),tmplTail=getTStylingRangeNext(tBindings);tData[index]=tStylingKeyWithStatic;let tStylingKey,isKeyDuplicateOfStatic=!1;if(Array.isArray(tStylingKeyWithStatic)){const staticKeyValueArray=tStylingKeyWithStatic;tStylingKey=staticKeyValueArray[1],(null===tStylingKey||keyValueArrayIndexOf(staticKeyValueArray,tStylingKey)>0)&&(isKeyDuplicateOfStatic=!0)}else tStylingKey=tStylingKeyWithStatic;if(isHostBinding){if(0!==tmplTail){const previousNode=getTStylingRangePrev(tData[tmplHead+1]);tData[index+1]=toTStylingRange(previousNode,tmplHead),0!==previousNode&&(tData[previousNode+1]=setTStylingRangeNext(tData[previousNode+1],index)),tData[tmplHead+1]=function setTStylingRangePrev(tStylingRange,previous){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),ngDevMode&&assertNumberInRange(previous,0,32767),131071&tStylingRange|previous<<17}(tData[tmplHead+1],index)}else tData[index+1]=toTStylingRange(tmplHead,0),0!==tmplHead&&(tData[tmplHead+1]=setTStylingRangeNext(tData[tmplHead+1],index)),tmplHead=index}else tData[index+1]=toTStylingRange(tmplTail,0),ngDevMode&&root_effect_scheduler_assertEqual(0!==tmplHead&&0===tmplTail,!1,"Adding template bindings after hostBindings is not allowed."),0===tmplHead?tmplHead=index:tData[tmplTail+1]=setTStylingRangeNext(tData[tmplTail+1],index),tmplTail=index;isKeyDuplicateOfStatic&&(tData[index+1]=setTStylingRangePrevDuplicate(tData[index+1])),markDuplicates(tData,tStylingKey,index,!0),markDuplicates(tData,tStylingKey,index,!1),function markDuplicateOfResidualStyling(tNode,tStylingKey,tData,index,isClassBinding){const residual=isClassBinding?tNode.residualClasses:tNode.residualStyles;null!=residual&&"string"==typeof tStylingKey&&keyValueArrayIndexOf(residual,tStylingKey)>=0&&(tData[index+1]=setTStylingRangeNextDuplicate(tData[index+1]))}(tNode,tStylingKey,tData,index,isClassBinding),tBindings=toTStylingRange(tmplHead,tmplTail),isClassBinding?tNode.classBindings=tBindings:tNode.styleBindings=tBindings}function markDuplicates(tData,tStylingKey,index,isPrevDir){const tStylingAtIndex=tData[index+1],isMap=null===tStylingKey;let cursor=isPrevDir?getTStylingRangePrev(tStylingAtIndex):getTStylingRangeNext(tStylingAtIndex),foundDuplicate=!1;for(;0!==cursor&&(!1===foundDuplicate||isMap);){ngDevMode&&root_effect_scheduler_assertIndexInRange(tData,cursor);const tStylingValueAtCursor=tData[cursor],tStyleRangeAtCursor=tData[cursor+1];isStylingMatch(tStylingValueAtCursor,tStylingKey)&&(foundDuplicate=!0,tData[cursor+1]=isPrevDir?setTStylingRangeNextDuplicate(tStyleRangeAtCursor):setTStylingRangePrevDuplicate(tStyleRangeAtCursor)),cursor=isPrevDir?getTStylingRangePrev(tStyleRangeAtCursor):getTStylingRangeNext(tStyleRangeAtCursor)}foundDuplicate&&(tData[index+1]=isPrevDir?setTStylingRangePrevDuplicate(tStylingAtIndex):setTStylingRangeNextDuplicate(tStylingAtIndex))}function isStylingMatch(tStylingKeyCursor,tStylingKey){return ngDevMode&&root_effect_scheduler_assertNotEqual(Array.isArray(tStylingKey),!0,"Expected that 'tStylingKey' has been unwrapped"),null===tStylingKeyCursor||null==tStylingKey||(Array.isArray(tStylingKeyCursor)?tStylingKeyCursor[1]:tStylingKeyCursor)===tStylingKey||!(!Array.isArray(tStylingKeyCursor)||"string"!=typeof tStylingKey)&&keyValueArrayIndexOf(tStylingKeyCursor,tStylingKey)>=0}const parserState={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function getLastParsedKey(text){return text.substring(parserState.key,parserState.keyEnd)}function getLastParsedValue(text){return text.substring(parserState.value,parserState.valueEnd)}function parseClassNameNext(text,index){const end=parserState.textEnd;return end===index?-1:(index=parserState.keyEnd=function consumeClassToken(text,startIndex,endIndex){for(;startIndex<endIndex&&text.charCodeAt(startIndex)>32;)startIndex++;return startIndex}(text,parserState.key=index,end),consumeWhitespace(text,index,end))}function parseStyleNext(text,startIndex){const end=parserState.textEnd;let index=parserState.key=consumeWhitespace(text,startIndex,end);return end===index?-1:(index=parserState.keyEnd=function consumeStyleKey(text,startIndex,endIndex){let ch;for(;startIndex<endIndex&&(45===(ch=text.charCodeAt(startIndex))||95===ch||(-33&ch)>=65&&(-33&ch)<=90||ch>=48&&ch<=57);)startIndex++;return startIndex}(text,index,end),index=consumeSeparator(text,index,end,58),index=parserState.value=consumeWhitespace(text,index,end),index=parserState.valueEnd=function consumeStyleValue(text,startIndex,endIndex){let ch1=-1,ch2=-1,ch3=-1,i=startIndex,lastChIndex=i;for(;i<endIndex;){const ch=text.charCodeAt(i++);if(59===ch)return lastChIndex;34===ch||39===ch?lastChIndex=i=consumeQuotedText(text,ch,i,endIndex):startIndex===i-4&&85===ch3&&82===ch2&&76===ch1&&40===ch?lastChIndex=i=consumeQuotedText(text,41,i,endIndex):ch>32&&(lastChIndex=i),ch3=ch2,ch2=ch1,ch1=-33&ch}return lastChIndex}(text,index,end),consumeSeparator(text,index,end,59))}function resetParserState(text){parserState.key=0,parserState.keyEnd=0,parserState.value=0,parserState.valueEnd=0,parserState.textEnd=text.length}function consumeWhitespace(text,startIndex,endIndex){for(;startIndex<endIndex&&text.charCodeAt(startIndex)<=32;)startIndex++;return startIndex}function consumeSeparator(text,startIndex,endIndex,separator){return(startIndex=consumeWhitespace(text,startIndex,endIndex))<endIndex&&(ngDevMode&&text.charCodeAt(startIndex)!==separator&&malformedStyleError(text,String.fromCharCode(separator),startIndex),startIndex++),startIndex}function consumeQuotedText(text,quoteCharCode,startIndex,endIndex){let ch1=-1,index=startIndex;for(;index<endIndex;){const ch=text.charCodeAt(index++);if(ch==quoteCharCode&&92!==ch1)return index;ch1=92==ch&&92===ch1?0:ch}throw ngDevMode?malformedStyleError(text,String.fromCharCode(quoteCharCode),endIndex):new Error}function malformedStyleError(text,expecting,index){throw ngDevMode&&root_effect_scheduler_assertEqual("string"==typeof text,!0,"String expected here"),throwError(`Malformed style at location ${index} in string '`+text.substring(0,index)+"[>>"+text.substring(index,index+1)+"<<]"+text.slice(index+1)+`'. Expecting '${expecting}'.`)}function ɵɵstyleProp(prop,value,suffix){return checkStylingProperty(prop,value,suffix,!1),ɵɵstyleProp}function ɵɵclassProp(className,value){return checkStylingProperty(className,value,null,!0),ɵɵclassProp}function ɵɵstyleMap(styles){checkStylingMap(styleKeyValueArraySet,styleStringParser,styles,!1)}function styleStringParser(keyValueArray,text){for(let i=function parseStyle(text){return resetParserState(text),parseStyleNext(text,consumeWhitespace(text,0,parserState.textEnd))}(text);i>=0;i=parseStyleNext(text,i))styleKeyValueArraySet(keyValueArray,getLastParsedKey(text),getLastParsedValue(text))}function ɵɵclassMap(classes){checkStylingMap(classKeyValueArraySet,classStringParser,classes,!0)}function classStringParser(keyValueArray,text){for(let i=function parseClassName(text){return resetParserState(text),parseClassNameNext(text,consumeWhitespace(text,0,parserState.textEnd))}(text);i>=0;i=parseClassNameNext(text,i))keyValueArraySet(keyValueArray,getLastParsedKey(text),!0)}function checkStylingProperty(prop,value,suffix,isClassBased){const lView=root_effect_scheduler_getLView(),tView=getTView(),bindingIndex=incrementBindingIndex(2);if(tView.firstUpdatePass&&stylingFirstUpdatePass(tView,prop,bindingIndex,isClassBased),value!==NO_CHANGE&&bindingUpdated(lView,bindingIndex,value)){updateStyling(tView,tView.data[getSelectedIndex()],lView,lView[11],prop,lView[bindingIndex+1]=function normalizeSuffix(value,suffix){null==value||""===value||("string"==typeof suffix?value+=suffix:"object"==typeof value&&(value=stringify(unwrapSafeValue(value))));return value}(value,suffix),isClassBased,bindingIndex)}}function checkStylingMap(keyValueArraySet,stringParser,value,isClassBased){const tView=getTView(),bindingIndex=incrementBindingIndex(2);tView.firstUpdatePass&&stylingFirstUpdatePass(tView,null,bindingIndex,isClassBased);const lView=root_effect_scheduler_getLView();if(value!==NO_CHANGE&&bindingUpdated(lView,bindingIndex,value)){const tNode=tView.data[getSelectedIndex()];if(hasStylingInputShadow(tNode,isClassBased)&&!isInHostBindings(tView,bindingIndex)){if(ngDevMode){const tStylingKey=tView.data[bindingIndex];root_effect_scheduler_assertEqual(Array.isArray(tStylingKey)?tStylingKey[1]:tStylingKey,!1,"Styling linked list shadow input should be marked as 'false'")}let staticPrefix=isClassBased?tNode.classesWithoutHost:tNode.stylesWithoutHost;ngDevMode&&!1===isClassBased&&null!==staticPrefix&&root_effect_scheduler_assertEqual(staticPrefix.endsWith(";"),!0,"Expecting static portion to end with ';'"),null!==staticPrefix&&(value=concatStringsWithSpace(staticPrefix,value||"")),setDirectiveInputsWhichShadowsStyling(tView,tNode,lView,value,isClassBased)}else!function updateStylingMap(tView,tNode,lView,renderer,oldKeyValueArray,newKeyValueArray,isClassBased,bindingIndex){oldKeyValueArray===NO_CHANGE&&(oldKeyValueArray=EMPTY_ARRAY);let oldIndex=0,newIndex=0,oldKey=0<oldKeyValueArray.length?oldKeyValueArray[0]:null,newKey=0<newKeyValueArray.length?newKeyValueArray[0]:null;for(;null!==oldKey||null!==newKey;){ngDevMode&&assertLessThan(oldIndex,999,"Are we stuck in infinite loop?"),ngDevMode&&assertLessThan(newIndex,999,"Are we stuck in infinite loop?");const oldValue=oldIndex<oldKeyValueArray.length?oldKeyValueArray[oldIndex+1]:void 0,newValue=newIndex<newKeyValueArray.length?newKeyValueArray[newIndex+1]:void 0;let setValue,setKey=null;oldKey===newKey?(oldIndex+=2,newIndex+=2,oldValue!==newValue&&(setKey=newKey,setValue=newValue)):null===newKey||null!==oldKey&&oldKey<newKey?(oldIndex+=2,setKey=oldKey):(ngDevMode&&root_effect_scheduler_assertDefined(newKey,"Expecting to have a valid key"),newIndex+=2,setKey=newKey,setValue=newValue),null!==setKey&&updateStyling(tView,tNode,lView,renderer,setKey,setValue,isClassBased,bindingIndex),oldKey=oldIndex<oldKeyValueArray.length?oldKeyValueArray[oldIndex]:null,newKey=newIndex<newKeyValueArray.length?newKeyValueArray[newIndex]:null}}(tView,tNode,lView,lView[11],lView[bindingIndex+1],lView[bindingIndex+1]=function toStylingKeyValueArray(keyValueArraySet,stringParser,value){if(null==value||""===value)return EMPTY_ARRAY;const styleKeyValueArray=[],unwrappedValue=unwrapSafeValue(value);if(Array.isArray(unwrappedValue))for(let i=0;i<unwrappedValue.length;i++)keyValueArraySet(styleKeyValueArray,unwrappedValue[i],!0);else if("object"==typeof unwrappedValue)for(const key in unwrappedValue)unwrappedValue.hasOwnProperty(key)&&keyValueArraySet(styleKeyValueArray,key,unwrappedValue[key]);else"string"==typeof unwrappedValue?stringParser(styleKeyValueArray,unwrappedValue):ngDevMode&&throwError("Unsupported styling type: "+typeof unwrappedValue+" ("+unwrappedValue+")");return styleKeyValueArray}(keyValueArraySet,stringParser,value),isClassBased,bindingIndex)}}function isInHostBindings(tView,bindingIndex){return bindingIndex>=tView.expandoStartIndex}function stylingFirstUpdatePass(tView,tStylingKey,bindingIndex,isClassBased){ngDevMode&&assertFirstUpdatePass(tView);const tData=tView.data;if(null===tData[bindingIndex+1]){const tNode=tData[getSelectedIndex()];ngDevMode&&root_effect_scheduler_assertDefined(tNode,"TNode expected");const isHostBindings=isInHostBindings(tView,bindingIndex);hasStylingInputShadow(tNode,isClassBased)&&null===tStylingKey&&!isHostBindings&&(tStylingKey=!1),tStylingKey=function wrapInStaticStylingKey(tData,tNode,stylingKey,isClassBased){const hostDirectiveDef=getCurrentDirectiveDef(tData);let residual=isClassBased?tNode.residualClasses:tNode.residualStyles;if(null===hostDirectiveDef){0===(isClassBased?tNode.classBindings:tNode.styleBindings)&&(stylingKey=collectStylingFromTAttrs(stylingKey=collectStylingFromDirectives(null,tData,tNode,stylingKey,isClassBased),tNode.attrs,isClassBased),residual=null)}else{const directiveStylingLast=tNode.directiveStylingLast;if(-1===directiveStylingLast||tData[directiveStylingLast]!==hostDirectiveDef)if(stylingKey=collectStylingFromDirectives(hostDirectiveDef,tData,tNode,stylingKey,isClassBased),null===residual){let templateStylingKey=function getTemplateHeadTStylingKey(tData,tNode,isClassBased){const bindings=isClassBased?tNode.classBindings:tNode.styleBindings;if(0===getTStylingRangeNext(bindings))return;return tData[getTStylingRangePrev(bindings)]}(tData,tNode,isClassBased);void 0!==templateStylingKey&&Array.isArray(templateStylingKey)&&(templateStylingKey=collectStylingFromDirectives(null,tData,tNode,templateStylingKey[1],isClassBased),templateStylingKey=collectStylingFromTAttrs(templateStylingKey,tNode.attrs,isClassBased),function setTemplateHeadTStylingKey(tData,tNode,isClassBased,tStylingKey){const bindings=isClassBased?tNode.classBindings:tNode.styleBindings;ngDevMode&&root_effect_scheduler_assertNotEqual(getTStylingRangeNext(bindings),0,"Expecting to have at least one template styling binding."),tData[getTStylingRangePrev(bindings)]=tStylingKey}(tData,tNode,isClassBased,templateStylingKey))}else residual=function collectResidual(tData,tNode,isClassBased){let residual;const directiveEnd=tNode.directiveEnd;ngDevMode&&root_effect_scheduler_assertNotEqual(tNode.directiveStylingLast,-1,"By the time this function gets called at least one hostBindings-node styling instruction must have executed.");for(let i=1+tNode.directiveStylingLast;i<directiveEnd;i++){residual=collectStylingFromTAttrs(residual,tData[i].hostAttrs,isClassBased)}return collectStylingFromTAttrs(residual,tNode.attrs,isClassBased)}(tData,tNode,isClassBased)}void 0!==residual&&(isClassBased?tNode.residualClasses=residual:tNode.residualStyles=residual);return stylingKey}(tData,tNode,tStylingKey,isClassBased),insertTStylingBinding(tData,tNode,tStylingKey,bindingIndex,isHostBindings,isClassBased)}}function collectStylingFromDirectives(hostDirectiveDef,tData,tNode,stylingKey,isClassBased){let currentDirective=null;const directiveEnd=tNode.directiveEnd;let directiveStylingLast=tNode.directiveStylingLast;for(-1===directiveStylingLast?directiveStylingLast=tNode.directiveStart:directiveStylingLast++;directiveStylingLast<directiveEnd&&(currentDirective=tData[directiveStylingLast],ngDevMode&&root_effect_scheduler_assertDefined(currentDirective,"expected to be defined"),stylingKey=collectStylingFromTAttrs(stylingKey,currentDirective.hostAttrs,isClassBased),currentDirective!==hostDirectiveDef);)directiveStylingLast++;return null!==hostDirectiveDef&&(tNode.directiveStylingLast=directiveStylingLast),stylingKey}function collectStylingFromTAttrs(stylingKey,attrs,isClassBased){const desiredMarker=isClassBased?1:2;let currentMarker=-1;if(null!==attrs)for(let i=0;i<attrs.length;i++){const item=attrs[i];"number"==typeof item?currentMarker=item:currentMarker===desiredMarker&&(Array.isArray(stylingKey)||(stylingKey=void 0===stylingKey?[]:["",stylingKey]),keyValueArraySet(stylingKey,item,!!isClassBased||attrs[++i]))}return void 0===stylingKey?null:stylingKey}function styleKeyValueArraySet(keyValueArray,key,value){keyValueArraySet(keyValueArray,key,unwrapSafeValue(value))}function classKeyValueArraySet(keyValueArray,key,value){const stringKey=String(key);""===stringKey||stringKey.includes(" ")||keyValueArraySet(keyValueArray,stringKey,value)}function updateStyling(tView,tNode,lView,renderer,prop,value,isClassBased,bindingIndex){if(!(3&tNode.type))return;const tData=tView.data,tRange=tData[bindingIndex+1];if(!isStylingValuePresent(function getTStylingRangeNextDuplicate(tStylingRange){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),!(1&~tStylingRange)}(tRange)?findStylingValue(tData,tNode,lView,prop,getTStylingRangeNext(tRange),isClassBased):void 0)){isStylingValuePresent(value)||function getTStylingRangePrevDuplicate(tStylingRange){return ngDevMode&&root_effect_scheduler_assertNumber(tStylingRange,"expected number"),!(2&~tStylingRange)}(tRange)&&(value=findStylingValue(tData,null,lView,prop,bindingIndex,isClassBased));!function applyStyling(renderer,isClassBased,rNode,prop,value){if(isClassBased)value?renderer.addClass(rNode,prop):renderer.removeClass(rNode,prop);else{let flags=-1===prop.indexOf("-")?void 0:RendererStyleFlags2.DashCase;null==value?renderer.removeStyle(rNode,prop,flags):("string"==typeof value&&value.endsWith("!important")&&(value=value.slice(0,-10),flags|=RendererStyleFlags2.Important),renderer.setStyle(rNode,prop,value,flags))}}(renderer,isClassBased,getNativeByIndex(getSelectedIndex(),lView),prop,value)}}function findStylingValue(tData,tNode,lView,prop,index,isClassBased){const isPrevDirection=null===tNode;let value;for(;index>0;){const rawKey=tData[index],containsStatics=Array.isArray(rawKey),key=containsStatics?rawKey[1]:rawKey,isStylingMap=null===key;let valueAtLViewIndex=lView[index+1];valueAtLViewIndex===NO_CHANGE&&(valueAtLViewIndex=isStylingMap?EMPTY_ARRAY:void 0);let currentValue=isStylingMap?keyValueArrayGet(valueAtLViewIndex,prop):key===prop?valueAtLViewIndex:void 0;if(containsStatics&&!isStylingValuePresent(currentValue)&&(currentValue=keyValueArrayGet(rawKey,prop)),isStylingValuePresent(currentValue)&&(value=currentValue,isPrevDirection))return value;const tRange=tData[index+1];index=isPrevDirection?getTStylingRangePrev(tRange):getTStylingRangeNext(tRange)}if(null!==tNode){let residual=isClassBased?tNode.residualClasses:tNode.residualStyles;null!=residual&&(value=keyValueArrayGet(residual,prop))}return value}function isStylingValuePresent(value){return void 0!==value}function hasStylingInputShadow(tNode,isClassBased){return!!(tNode.flags&(isClassBased?8:16))}function ɵɵtext(index,value=""){const lView=root_effect_scheduler_getLView(),tView=getTView(),adjustedIndex=index+27;ngDevMode&&assertTNodeCreationIndex(lView,index);const tNode=tView.firstCreatePass?getOrCreateTNode(tView,adjustedIndex,1,value,null):tView.data[adjustedIndex],textNative=_locateOrCreateTextNode(tView,lView,tNode,value,index);lView[adjustedIndex]=textNative,wasLastNodeCreated()&&appendChild(tView,lView,textNative,tNode),setCurrentTNode(tNode,!1)}let _locateOrCreateTextNode=(tView,lView,tNode,value,index)=>(root_effect_scheduler_lastNodeWasCreated(!0),createTextNode(lView[11],value));function interpolationV(lView,values){ngDevMode&&assertLessThan(2,values.length,"should have at least 3 values");let isBindingUpdated=!1,bindingIndex=getBindingIndex();for(let i=1;i<values.length;i+=2)isBindingUpdated=bindingUpdated(lView,bindingIndex++,values[i])||isBindingUpdated;if(setBindingIndex(bindingIndex),!isBindingUpdated)return NO_CHANGE;let content=values[0];for(let i=1;i<values.length;i+=2)content+=root_effect_scheduler_renderStringify(values[i])+(i+1!==values.length?values[i+1]:"");return content}function interpolation1(lView,prefix,v0,suffix=""){return bindingUpdated(lView,root_effect_scheduler_nextBindingIndex(),v0)?prefix+root_effect_scheduler_renderStringify(v0)+suffix:NO_CHANGE}function interpolation2(lView,prefix,v0,i0,v1,suffix=""){const different=bindingUpdated2(lView,getBindingIndex(),v0,v1);return incrementBindingIndex(2),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+suffix:NO_CHANGE}function interpolation3(lView,prefix,v0,i0,v1,i1,v2,suffix=""){const different=bindingUpdated3(lView,getBindingIndex(),v0,v1,v2);return incrementBindingIndex(3),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+i1+root_effect_scheduler_renderStringify(v2)+suffix:NO_CHANGE}function interpolation4(lView,prefix,v0,i0,v1,i1,v2,i2,v3,suffix=""){const different=bindingUpdated4(lView,getBindingIndex(),v0,v1,v2,v3);return incrementBindingIndex(4),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+i1+root_effect_scheduler_renderStringify(v2)+i2+root_effect_scheduler_renderStringify(v3)+suffix:NO_CHANGE}function interpolation5(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix=""){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated(lView,bindingIndex+4,v4)||different,incrementBindingIndex(5),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+i1+root_effect_scheduler_renderStringify(v2)+i2+root_effect_scheduler_renderStringify(v3)+i3+root_effect_scheduler_renderStringify(v4)+suffix:NO_CHANGE}function interpolation6(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix=""){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated2(lView,bindingIndex+4,v4,v5)||different,incrementBindingIndex(6),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+i1+root_effect_scheduler_renderStringify(v2)+i2+root_effect_scheduler_renderStringify(v3)+i3+root_effect_scheduler_renderStringify(v4)+i4+root_effect_scheduler_renderStringify(v5)+suffix:NO_CHANGE}function interpolation7(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix=""){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated3(lView,bindingIndex+4,v4,v5,v6)||different,incrementBindingIndex(7),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+i1+root_effect_scheduler_renderStringify(v2)+i2+root_effect_scheduler_renderStringify(v3)+i3+root_effect_scheduler_renderStringify(v4)+i4+root_effect_scheduler_renderStringify(v5)+i5+root_effect_scheduler_renderStringify(v6)+suffix:NO_CHANGE}function interpolation8(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix=""){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated4(lView,bindingIndex+4,v4,v5,v6,v7)||different,incrementBindingIndex(8),different?prefix+root_effect_scheduler_renderStringify(v0)+i0+root_effect_scheduler_renderStringify(v1)+i1+root_effect_scheduler_renderStringify(v2)+i2+root_effect_scheduler_renderStringify(v3)+i3+root_effect_scheduler_renderStringify(v4)+i4+root_effect_scheduler_renderStringify(v5)+i5+root_effect_scheduler_renderStringify(v6)+i6+root_effect_scheduler_renderStringify(v7)+suffix:NO_CHANGE}function ɵɵtextInterpolate(v0){return ɵɵtextInterpolate1("",v0),ɵɵtextInterpolate}function ɵɵtextInterpolate1(prefix,v0,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation1(lView,prefix,v0,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate1}function ɵɵtextInterpolate2(prefix,v0,i0,v1,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation2(lView,prefix,v0,i0,v1,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate2}function ɵɵtextInterpolate3(prefix,v0,i0,v1,i1,v2,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation3(lView,prefix,v0,i0,v1,i1,v2,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate3}function ɵɵtextInterpolate4(prefix,v0,i0,v1,i1,v2,i2,v3,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation4(lView,prefix,v0,i0,v1,i1,v2,i2,v3,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate4}function ɵɵtextInterpolate5(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation5(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate5}function ɵɵtextInterpolate6(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation6(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate6}function ɵɵtextInterpolate7(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation7(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate7}function ɵɵtextInterpolate8(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix){const lView=root_effect_scheduler_getLView(),interpolated=interpolation8(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate8}function ɵɵtextInterpolateV(values){const lView=root_effect_scheduler_getLView(),interpolated=interpolationV(lView,values);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolateV}function textBindingInternal(lView,index,value){ngDevMode&&assertString(value,"Value should be a string"),ngDevMode&&assertNotSame(value,NO_CHANGE,"value should not be NO_CHANGE"),ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,index);const element=getNativeByIndex(index,lView);ngDevMode&&root_effect_scheduler_assertDefined(element,"native element should exist"),updateTextNode(lView[11],element,value)}function ɵɵtwoWayProperty(propName,value,sanitizer){isWritableSignal(value)&&(value=value());const lView=root_effect_scheduler_getLView(),bindingIndex=root_effect_scheduler_nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=root_effect_scheduler_getSelectedTNode();setPropertyAndInputs(tNode,lView,propName,value,lView[11],sanitizer),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵtwoWayProperty}function ɵɵtwoWayBindingSet(target,value){const canWrite=isWritableSignal(target);return canWrite&&target.set(value),canWrite}function ɵɵtwoWayListener(eventName,listenerFn){const lView=root_effect_scheduler_getLView(),tView=getTView(),tNode=root_effect_scheduler_getCurrentTNode();return listenerInternal(tView,lView,lView[11],tNode,eventName,listenerFn),ɵɵtwoWayListener}const UNINITIALIZED_LET={};function ɵɵdeclareLet(index){const tView=getTView(),lView=root_effect_scheduler_getLView(),adjustedIndex=index+27;return setCurrentTNode(getOrCreateTNode(tView,adjustedIndex,128,null,null),!1),store(tView,lView,adjustedIndex,UNINITIALIZED_LET),ɵɵdeclareLet}function ɵɵstoreLet(value){debug_node_performanceMarkFeature("NgLet");return store(getTView(),root_effect_scheduler_getLView(),getSelectedIndex(),value),value}function ɵɵreadContextLet(index){const value=load(getContextLView(),27+index);if(value===UNINITIALIZED_LET)throw new root_effect_scheduler_RuntimeError(314,ngDevMode&&"Attempting to access a @let declaration whose value is not available yet");return value}function ɵɵattachSourceLocations(templatePath,locations){const tView=getTView(),lView=root_effect_scheduler_getLView(),renderer=lView[11];for(const[index,offset,line,column]of locations){const tNode=root_effect_scheduler_getTNode(tView,index+27);ngDevMode&&assertTNodeType(tNode,2);const node=getNativeByIndex(index+27,lView);if(!node.hasAttribute("data-ng-source-location")){const attributeValue=`${templatePath}@o:${offset},l:${line},c:${column}`;renderer.setAttribute(node,"data-ng-source-location",attributeValue)}}}function ɵɵinterpolate(v0){return bindingUpdated(root_effect_scheduler_getLView(),root_effect_scheduler_nextBindingIndex(),v0)?root_effect_scheduler_renderStringify(v0):NO_CHANGE}function ɵɵinterpolate1(prefix,v0,suffix=""){return interpolation1(root_effect_scheduler_getLView(),prefix,v0,suffix)}function ɵɵinterpolate2(prefix,v0,i0,v1,suffix=""){return interpolation2(root_effect_scheduler_getLView(),prefix,v0,i0,v1,suffix)}function ɵɵinterpolate3(prefix,v0,i0,v1,i1,v2,suffix=""){return interpolation3(root_effect_scheduler_getLView(),prefix,v0,i0,v1,i1,v2,suffix)}function ɵɵinterpolate4(prefix,v0,i0,v1,i1,v2,i2,v3,suffix=""){return interpolation4(root_effect_scheduler_getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,suffix)}function ɵɵinterpolate5(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix=""){return interpolation5(root_effect_scheduler_getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix)}function ɵɵinterpolate6(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix=""){return interpolation6(root_effect_scheduler_getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix)}function ɵɵinterpolate7(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix=""){return interpolation7(root_effect_scheduler_getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix)}function ɵɵinterpolate8(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix=""){return interpolation8(root_effect_scheduler_getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix)}function ɵɵinterpolateV(values){return interpolationV(root_effect_scheduler_getLView(),values)}function resolveProvider(provider,tInjectables,lInjectablesBlueprint,isComponent,isViewProvider){if(provider=resolveForwardRef(provider),Array.isArray(provider))for(let i=0;i<provider.length;i++)resolveProvider(provider[i],tInjectables,lInjectablesBlueprint,isComponent,isViewProvider);else{const tView=getTView(),lView=root_effect_scheduler_getLView(),tNode=root_effect_scheduler_getCurrentTNode();let token=isTypeProvider(provider)?provider:resolveForwardRef(provider.provide);const providerFactory=providerToFactory(provider);if(ngDevMode){runInInjectorProfilerContext(new NodeInjector(tNode,lView),token,()=>{emitProviderConfiguredEvent(provider,isViewProvider)})}const beginIndex=1048575&tNode.providerIndexes,endIndex=tNode.directiveStart,cptViewProvidersCount=tNode.providerIndexes>>20;if(isTypeProvider(provider)||!provider.multi){const factory=new NodeInjectorFactory(providerFactory,isViewProvider,ɵɵdirectiveInject,ngDevMode?providerName(provider):null),existingFactoryIndex=indexOf(token,tInjectables,isViewProvider?beginIndex:beginIndex+cptViewProvidersCount,endIndex);-1===existingFactoryIndex?(diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,token),registerDestroyHooksIfSupported(tView,provider,tInjectables.length),tInjectables.push(token),tNode.directiveStart++,tNode.directiveEnd++,isViewProvider&&(tNode.providerIndexes+=1048576),lInjectablesBlueprint.push(factory),lView.push(factory)):(lInjectablesBlueprint[existingFactoryIndex]=factory,lView[existingFactoryIndex]=factory)}else{const existingProvidersFactoryIndex=indexOf(token,tInjectables,beginIndex+cptViewProvidersCount,endIndex),existingViewProvidersFactoryIndex=indexOf(token,tInjectables,beginIndex,beginIndex+cptViewProvidersCount),doesProvidersFactoryExist=existingProvidersFactoryIndex>=0&&lInjectablesBlueprint[existingProvidersFactoryIndex],doesViewProvidersFactoryExist=existingViewProvidersFactoryIndex>=0&&lInjectablesBlueprint[existingViewProvidersFactoryIndex];if(isViewProvider&&!doesViewProvidersFactoryExist||!isViewProvider&&!doesProvidersFactoryExist){diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,token);const factory=function multiFactory(factoryFn,index,isViewProvider,isComponent,f,provider){const factory=new NodeInjectorFactory(factoryFn,isViewProvider,ɵɵdirectiveInject,ngDevMode?providerName(provider):null);return factory.multi=[],factory.index=index,factory.componentProviders=0,multiFactoryAdd(factory,f,isComponent&&!isViewProvider),factory}(isViewProvider?multiViewProvidersFactoryResolver:multiProvidersFactoryResolver,lInjectablesBlueprint.length,isViewProvider,isComponent,providerFactory,provider);!isViewProvider&&doesViewProvidersFactoryExist&&(lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory=factory),registerDestroyHooksIfSupported(tView,provider,tInjectables.length,0),tInjectables.push(token),tNode.directiveStart++,tNode.directiveEnd++,isViewProvider&&(tNode.providerIndexes+=1048576),lInjectablesBlueprint.push(factory),lView.push(factory)}else{const indexInFactory=multiFactoryAdd(lInjectablesBlueprint[isViewProvider?existingViewProvidersFactoryIndex:existingProvidersFactoryIndex],providerFactory,!isViewProvider&&isComponent);registerDestroyHooksIfSupported(tView,provider,existingProvidersFactoryIndex>-1?existingProvidersFactoryIndex:existingViewProvidersFactoryIndex,indexInFactory)}!isViewProvider&&isComponent&&doesViewProvidersFactoryExist&&lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++}}}function registerDestroyHooksIfSupported(tView,provider,contextIndex,indexInFactory){const providerIsTypeProvider=isTypeProvider(provider),providerIsClassProvider=isClassProvider(provider);if(providerIsTypeProvider||providerIsClassProvider){const ngOnDestroy=(providerIsClassProvider?resolveForwardRef(provider.useClass):provider).prototype.ngOnDestroy;if(ngOnDestroy){const hooks=tView.destroyHooks||(tView.destroyHooks=[]);if(!providerIsTypeProvider&&provider.multi){ngDevMode&&root_effect_scheduler_assertDefined(indexInFactory,"indexInFactory when registering multi factory destroy hook");const existingCallbacksIndex=hooks.indexOf(contextIndex);-1===existingCallbacksIndex?hooks.push(contextIndex,[indexInFactory,ngOnDestroy]):hooks[existingCallbacksIndex+1].push(indexInFactory,ngOnDestroy)}else hooks.push(contextIndex,ngOnDestroy)}}}function multiFactoryAdd(multiFactory,factory,isComponentProvider){return isComponentProvider&&multiFactory.componentProviders++,multiFactory.multi.push(factory)-1}function indexOf(item,arr,begin,end){for(let i=begin;i<end;i++)if(arr[i]===item)return i;return-1}function multiProvidersFactoryResolver(_,flags,tData,lData,tNode){return multiResolve(this.multi,[])}function multiViewProvidersFactoryResolver(_,_flags,_tData,lView,tNode){const factories=this.multi;let result;if(this.providerFactory){const componentCount=this.providerFactory.componentProviders,multiProviders=getNodeInjectable(lView,lView[1],this.providerFactory.index,tNode);result=multiProviders.slice(0,componentCount),multiResolve(factories,result);for(let i=componentCount;i<multiProviders.length;i++)result.push(multiProviders[i])}else result=[],multiResolve(factories,result);return result}function multiResolve(factories,result){for(let i=0;i<factories.length;i++){const factory=factories[i];result.push(factory())}return result}function providerName(provider){return Array.isArray(provider)?null:isTypeProvider(provider)?provider.name:isClassProvider(provider)?provider.provide instanceof InjectionToken?`('${provider.provide.toString()}':${provider.useClass.name})`:provider.useClass.name:provider.provide instanceof InjectionToken?provider.provide.toString():"string"==typeof provider.provide?provider.provide:null}function ɵɵProvidersFeature(providers,viewProviders=[]){return definition=>{definition.providersResolver=(def,processProvidersFn)=>function providersResolver(def,providers,viewProviders){const tView=getTView();if(tView.firstCreatePass){const isComponent=isComponentDef(def);resolveProvider(viewProviders,tView.data,tView.blueprint,isComponent,!0),resolveProvider(providers,tView.data,tView.blueprint,isComponent,!1)}}(def,processProvidersFn?processProvidersFn(providers):providers,viewProviders)}}function ɵɵExternalStylesFeature(styleUrls){return definition=>{styleUrls.length<1||(definition.getExternalStyles=encapsulationId=>styleUrls.map(value=>value+"?ngcomp"+(encapsulationId?"="+encodeURIComponent(encapsulationId):"")+"&e="+definition.encapsulation))}}function ɵɵsetComponentScope(type,directives,pipes){const def=type.ɵcmp;def.directiveDefs=extractDefListOrFactory(directives,extractDirectiveDef),def.pipeDefs=extractDefListOrFactory(pipes,getPipeDef)}function ɵɵsetNgModuleScope(type,scope){return noSideEffects(()=>{const ngModuleDef=getNgModuleDefOrThrow(type);ngModuleDef.declarations=convertToTypeArray(scope.declarations||EMPTY_ARRAY),ngModuleDef.imports=convertToTypeArray(scope.imports||EMPTY_ARRAY),ngModuleDef.exports=convertToTypeArray(scope.exports||EMPTY_ARRAY),scope.bootstrap&&(ngModuleDef.bootstrap=convertToTypeArray(scope.bootstrap)),depsTracker.registerNgModule(type,scope)})}function convertToTypeArray(values){if("function"==typeof values)return values;const flattenValues=flatten(values);return flattenValues.some(isForwardRef)?()=>flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders):flattenValues.map(maybeUnwrapModuleWithProviders)}function maybeUnwrapModuleWithProviders(value){return isModuleWithProviders(value)?value.ngModule:value}function ɵɵpureFunction0(slotOffset,pureFn,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=root_effect_scheduler_getLView();return lView[bindingIndex]===NO_CHANGE?updateBinding(lView,bindingIndex,thisArg?pureFn.call(thisArg):pureFn()):getBinding(lView,bindingIndex)}function ɵɵpureFunction1(slotOffset,pureFn,exp,thisArg){return pureFunction1Internal(root_effect_scheduler_getLView(),getBindingRoot(),slotOffset,pureFn,exp,thisArg)}function ɵɵpureFunction2(slotOffset,pureFn,exp1,exp2,thisArg){return pureFunction2Internal(root_effect_scheduler_getLView(),getBindingRoot(),slotOffset,pureFn,exp1,exp2,thisArg)}function ɵɵpureFunction3(slotOffset,pureFn,exp1,exp2,exp3,thisArg){return pureFunction3Internal(root_effect_scheduler_getLView(),getBindingRoot(),slotOffset,pureFn,exp1,exp2,exp3,thisArg)}function ɵɵpureFunction4(slotOffset,pureFn,exp1,exp2,exp3,exp4,thisArg){return pureFunction4Internal(root_effect_scheduler_getLView(),getBindingRoot(),slotOffset,pureFn,exp1,exp2,exp3,exp4,thisArg)}function ɵɵpureFunction5(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=root_effect_scheduler_getLView(),different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated(lView,bindingIndex+4,exp5)||different?updateBinding(lView,bindingIndex+5,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5):pureFn(exp1,exp2,exp3,exp4,exp5)):getBinding(lView,bindingIndex+5)}function ɵɵpureFunction6(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,exp6,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=root_effect_scheduler_getLView(),different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated2(lView,bindingIndex+4,exp5,exp6)||different?updateBinding(lView,bindingIndex+6,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5,exp6):pureFn(exp1,exp2,exp3,exp4,exp5,exp6)):getBinding(lView,bindingIndex+6)}function ɵɵpureFunction7(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,exp6,exp7,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=root_effect_scheduler_getLView();let different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated3(lView,bindingIndex+4,exp5,exp6,exp7)||different?updateBinding(lView,bindingIndex+7,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5,exp6,exp7):pureFn(exp1,exp2,exp3,exp4,exp5,exp6,exp7)):getBinding(lView,bindingIndex+7)}function ɵɵpureFunction8(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,exp6,exp7,exp8,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=root_effect_scheduler_getLView(),different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated4(lView,bindingIndex+4,exp5,exp6,exp7,exp8)||different?updateBinding(lView,bindingIndex+8,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5,exp6,exp7,exp8):pureFn(exp1,exp2,exp3,exp4,exp5,exp6,exp7,exp8)):getBinding(lView,bindingIndex+8)}function ɵɵpureFunctionV(slotOffset,pureFn,exps,thisArg){return pureFunctionVInternal(root_effect_scheduler_getLView(),getBindingRoot(),slotOffset,pureFn,exps,thisArg)}function getPureFunctionReturnValue(lView,returnValueIndex){ngDevMode&&root_effect_scheduler_assertIndexInRange(lView,returnValueIndex);const lastReturnValue=lView[returnValueIndex];return lastReturnValue===NO_CHANGE?void 0:lastReturnValue}function pureFunction1Internal(lView,bindingRoot,slotOffset,pureFn,exp,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated(lView,bindingIndex,exp)?updateBinding(lView,bindingIndex+1,thisArg?pureFn.call(thisArg,exp):pureFn(exp)):getPureFunctionReturnValue(lView,bindingIndex+1)}function pureFunction2Internal(lView,bindingRoot,slotOffset,pureFn,exp1,exp2,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated2(lView,bindingIndex,exp1,exp2)?updateBinding(lView,bindingIndex+2,thisArg?pureFn.call(thisArg,exp1,exp2):pureFn(exp1,exp2)):getPureFunctionReturnValue(lView,bindingIndex+2)}function pureFunction3Internal(lView,bindingRoot,slotOffset,pureFn,exp1,exp2,exp3,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated3(lView,bindingIndex,exp1,exp2,exp3)?updateBinding(lView,bindingIndex+3,thisArg?pureFn.call(thisArg,exp1,exp2,exp3):pureFn(exp1,exp2,exp3)):getPureFunctionReturnValue(lView,bindingIndex+3)}function pureFunction4Internal(lView,bindingRoot,slotOffset,pureFn,exp1,exp2,exp3,exp4,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4)?updateBinding(lView,bindingIndex+4,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4):pureFn(exp1,exp2,exp3,exp4)):getPureFunctionReturnValue(lView,bindingIndex+4)}function pureFunctionVInternal(lView,bindingRoot,slotOffset,pureFn,exps,thisArg){let bindingIndex=bindingRoot+slotOffset,different=!1;for(let i=0;i<exps.length;i++)bindingUpdated(lView,bindingIndex++,exps[i])&&(different=!0);return different?updateBinding(lView,bindingIndex,pureFn.apply(thisArg,exps)):getPureFunctionReturnValue(lView,bindingIndex)}function ɵɵpipe(index,pipeName){const tView=getTView();let pipeDef;const adjustedIndex=index+27;tView.firstCreatePass?(pipeDef=function debug_node_getPipeDef(name,registry){if(registry){if(ngDevMode){registry.filter(pipe=>pipe.name===name).length>1&&console.warn(root_effect_scheduler_formatRuntimeError(313,function getMultipleMatchingPipesMessage(name){const lView=root_effect_scheduler_getLView(),context=lView[15][8],hostIsStandalone=isHostComponentStandalone(lView),componentInfoMessage=context?` in the '${context.constructor.name}' component`:"",errorMessage=`Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${"check "+(hostIsStandalone?"'@Component.imports' of this component":"the imports of this module")}`;return errorMessage}(name)))}for(let i=registry.length-1;i>=0;i--){const pipeDef=registry[i];if(name===pipeDef.name)return pipeDef}}if(ngDevMode)throw new root_effect_scheduler_RuntimeError(-302,function getPipeNotFoundErrorMessage(name){const lView=root_effect_scheduler_getLView(),context=lView[15][8],hostIsStandalone=isHostComponentStandalone(lView),componentInfoMessage=context?` in the '${context.constructor.name}' component`:"",errorMessage=`The pipe '${name}' could not be found${componentInfoMessage}. ${"Verify that it is "+(hostIsStandalone?"included in the '@Component.imports' of this component":"declared or imported in this module")}`;return errorMessage}(name));return}(pipeName,tView.pipeRegistry),tView.data[adjustedIndex]=pipeDef,pipeDef.onDestroy&&(tView.destroyHooks??=[]).push(adjustedIndex,pipeDef.onDestroy)):pipeDef=tView.data[adjustedIndex];const pipeFactory=pipeDef.factory||(pipeDef.factory=getFactoryDef(pipeDef.type,!0));let previousInjectorProfilerContext;ngDevMode&&(previousInjectorProfilerContext=setInjectorProfilerContext({injector:new NodeInjector(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView()),token:pipeDef.type}));const previousInjectImplementation=setInjectImplementation(ɵɵdirectiveInject);try{const previousIncludeViewProviders=setIncludeViewProviders(!1),pipeInstance=pipeFactory();return setIncludeViewProviders(previousIncludeViewProviders),store(tView,root_effect_scheduler_getLView(),adjustedIndex,pipeInstance),pipeInstance}finally{setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(previousInjectorProfilerContext)}}function ɵɵpipeBind1(index,offset,v1){const adjustedIndex=index+27,lView=root_effect_scheduler_getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction1Internal(lView,getBindingRoot(),offset,pipeInstance.transform,v1,pipeInstance):pipeInstance.transform(v1)}function ɵɵpipeBind2(index,slotOffset,v1,v2){const adjustedIndex=index+27,lView=root_effect_scheduler_getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction2Internal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,v1,v2,pipeInstance):pipeInstance.transform(v1,v2)}function ɵɵpipeBind3(index,slotOffset,v1,v2,v3){const adjustedIndex=index+27,lView=root_effect_scheduler_getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction3Internal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,v1,v2,v3,pipeInstance):pipeInstance.transform(v1,v2,v3)}function ɵɵpipeBind4(index,slotOffset,v1,v2,v3,v4){const adjustedIndex=index+27,lView=root_effect_scheduler_getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction4Internal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,v1,v2,v3,v4,pipeInstance):pipeInstance.transform(v1,v2,v3,v4)}function ɵɵpipeBindV(index,slotOffset,values){const adjustedIndex=index+27,lView=root_effect_scheduler_getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunctionVInternal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,values,pipeInstance):pipeInstance.transform.apply(pipeInstance,values)}function isPure(lView,index){return lView[1].data[index].pure}function ɵɵtemplateRefExtractor(tNode,lView){return createTemplateRef(tNode,lView)}function ɵɵgetComponentDepsFactory(type,rawImports){return()=>{try{return depsTracker.getComponentDependencies(type,rawImports).dependencies}catch(e){throw console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`,e),e}}}function ɵsetClassDebugInfo(type,debugInfo){const def=root_effect_scheduler_getComponentDef(type);null!==def&&(def.debugInfo=debugInfo)}function ɵɵgetReplaceMetadataURL(id,timestamp,base){const url=`./@ng/component?c=${id}&t=${encodeURIComponent(timestamp)}`;return new URL(url,base).href}function ɵɵreplaceMetadata(type,applyMetadata,namespaces,locals,importMeta=null,id=null){ngDevMode&&debug_node_assertComponentDef(type);const currentDef=root_effect_scheduler_getComponentDef(type);applyMetadata.apply(null,[type,namespaces,...locals]);const{newDef,oldDef}=function mergeWithExistingDefinition(currentDef,newDef){const clone={...currentDef},replacement=Object.assign(currentDef,newDef,{directiveDefs:clone.directiveDefs,pipeDefs:clone.pipeDefs,setInput:clone.setInput,type:clone.type});return ngDevMode&&root_effect_scheduler_assertEqual(replacement,currentDef,"Expected definition to be merged in place"),{newDef:replacement,oldDef:clone}}(currentDef,root_effect_scheduler_getComponentDef(type));if(type[NG_COMP_DEF]=newDef,oldDef.tView){const trackedViews=function getTrackedLViews(){return TRACKED_LVIEWS}().values();for(const root of trackedViews)root_effect_scheduler_isRootView(root)&&null===root[3]&&recreateMatchingLViews(importMeta,id,newDef,oldDef,root)}}function recreateMatchingLViews(importMeta,id,newDef,oldDef,rootLView){ngDevMode&&root_effect_scheduler_assertDefined(oldDef.tView,"Expected a component definition that has been instantiated at least once");const tView=rootLView[1];if(tView===oldDef.tView)return ngDevMode&&debug_node_assertComponentDef(oldDef.type),void function recreateLView(importMeta,id,newDef,oldDef,lView){const instance=lView[8];let host=lView[0];const parentLView=lView[3];ngDevMode&&assertLView(parentLView);const tNode=lView[5];ngDevMode&&assertTNodeType(tNode,2),ngDevMode&&root_effect_scheduler_assertNotEqual(newDef,oldDef,"Expected different component definition");const zone=lView[9].get(debug_node_NgZone,null),recreate=()=>{if(oldDef.encapsulation===ViewEncapsulation.ShadowDom){const newHost=host.cloneNode(!1);host.replaceWith(newHost),host=newHost}const newTView=getOrCreateComponentTView(newDef),newLView=createLView(parentLView,newTView,instance,getInitialLViewFlagsFromDef(newDef),host,tNode,null,null,null,null,null);!function replaceLViewInTree(parentLView,oldLView,newLView,index){for(let i=27;i<parentLView[1].bindingStartIndex;i++){const current=parentLView[i];if((root_effect_scheduler_isLView(current)||root_effect_scheduler_isLContainer(current))&&current[4]===oldLView){current[4]=newLView;break}}parentLView[12]===oldLView&&(parentLView[12]=newLView);parentLView[13]===oldLView&&(parentLView[13]=newLView);newLView[4]=oldLView[4],oldLView[4]=null,parentLView[index]=newLView}(parentLView,lView,newLView,tNode.index),destroyLView(lView[1],lView);const rendererFactory=lView[10].rendererFactory;!function clearRendererCache(factory,def){factory.componentReplaced?.(def.id)}(rendererFactory,oldDef),newLView[11]=rendererFactory.createRenderer(host,newDef),removeViewFromDOM(lView[1],lView),function resetProjectionState(tNode){if(null!==tNode.projection){for(const current of tNode.projection)debug_node_isTNodeShape(current)&&(current.projectionNext=null,current.flags&=-3);tNode.projection=null}}(tNode),renderView(newTView,newLView,instance),refreshView(newTView,newLView,newTView.template,instance)};null===zone?executeWithInvalidateFallback(importMeta,id,recreate):zone.run(()=>executeWithInvalidateFallback(importMeta,id,recreate))}(importMeta,id,newDef,oldDef,rootLView);for(let i=27;i<tView.bindingStartIndex;i++){const current=rootLView[i];if(root_effect_scheduler_isLContainer(current)){root_effect_scheduler_isLView(current[0])&&recreateMatchingLViews(importMeta,id,newDef,oldDef,current[0]);for(let j=10;j<current.length;j++)recreateMatchingLViews(importMeta,id,newDef,oldDef,current[j])}else root_effect_scheduler_isLView(current)&&recreateMatchingLViews(importMeta,id,newDef,oldDef,current)}}function executeWithInvalidateFallback(importMeta,id,callback){try{callback()}catch(e){const error=e;if(null!==id&&error.message){const toLog=error.message+(error.stack?"\n"+error.stack:"");importMeta?.hot?.send?.("angular:invalidate",{id,message:toLog,error:!0})}throw e}}const debug_node_angularCoreEnv={ɵɵanimateEnter,ɵɵanimateEnterListener,ɵɵanimateLeave,ɵɵanimateLeaveListener,ɵɵattribute,ɵɵdefineComponent,ɵɵdefineDirective,ɵɵdefineInjectable,ɵɵdefineInjector,ɵɵdefineNgModule,ɵɵdefinePipe,ɵɵdirectiveInject,ɵɵgetInheritedFactory,ɵɵinject,ɵɵinjectAttribute,ɵɵinvalidFactory,ɵɵinvalidFactoryDep,ɵɵtemplateRefExtractor,ɵɵresetView,ɵɵHostDirectivesFeature,ɵɵNgOnChangesFeature,ɵɵProvidersFeature,ɵɵCopyDefinitionFeature,ɵɵInheritDefinitionFeature,ɵɵExternalStylesFeature,ɵɵnextContext,ɵɵnamespaceHTML,ɵɵnamespaceMathML,ɵɵnamespaceSVG,ɵɵenableBindings,ɵɵdisableBindings,ɵɵelementStart,ɵɵelementEnd,ɵɵelement,ɵɵelementContainerStart,ɵɵelementContainerEnd,ɵɵdomElement,ɵɵdomElementStart,ɵɵdomElementEnd,ɵɵdomElementContainer,ɵɵdomElementContainerStart,ɵɵdomElementContainerEnd,ɵɵdomTemplate,ɵɵdomListener,ɵɵelementContainer,ɵɵpureFunction0,ɵɵpureFunction1,ɵɵpureFunction2,ɵɵpureFunction3,ɵɵpureFunction4,ɵɵpureFunction5,ɵɵpureFunction6,ɵɵpureFunction7,ɵɵpureFunction8,ɵɵpureFunctionV,ɵɵgetCurrentView,ɵɵrestoreView,ɵɵlistener,ɵɵprojection,ɵɵsyntheticHostProperty,ɵɵsyntheticHostListener,ɵɵpipeBind1,ɵɵpipeBind2,ɵɵpipeBind3,ɵɵpipeBind4,ɵɵpipeBindV,ɵɵprojectionDef,ɵɵdomProperty,ɵɵariaProperty,ɵɵproperty,ɵɵpipe,ɵɵqueryRefresh,ɵɵqueryAdvance,ɵɵviewQuery,ɵɵviewQuerySignal,ɵɵloadQuery,ɵɵcontentQuery,ɵɵcontentQuerySignal,ɵɵreference,ɵɵclassMap,ɵɵstyleMap,ɵɵstyleProp,ɵɵclassProp,ɵɵadvance,ɵɵtemplate,ɵɵconditional,ɵɵconditionalCreate,ɵɵconditionalBranchCreate,ɵɵdefer,ɵɵdeferWhen,ɵɵdeferOnIdle,ɵɵdeferOnImmediate,ɵɵdeferOnTimer,ɵɵdeferOnHover,ɵɵdeferOnInteraction,ɵɵdeferOnViewport,ɵɵdeferPrefetchWhen,ɵɵdeferPrefetchOnIdle,ɵɵdeferPrefetchOnImmediate,ɵɵdeferPrefetchOnTimer,ɵɵdeferPrefetchOnHover,ɵɵdeferPrefetchOnInteraction,ɵɵdeferPrefetchOnViewport,ɵɵdeferHydrateWhen,ɵɵdeferHydrateNever,ɵɵdeferHydrateOnIdle,ɵɵdeferHydrateOnImmediate,ɵɵdeferHydrateOnTimer,ɵɵdeferHydrateOnHover,ɵɵdeferHydrateOnInteraction,ɵɵdeferHydrateOnViewport,ɵɵdeferEnableTimerScheduling,ɵɵrepeater,ɵɵrepeaterCreate,ɵɵrepeaterTrackByIndex,ɵɵrepeaterTrackByIdentity,ɵɵcomponentInstance,ɵɵtext,ɵɵtextInterpolate,ɵɵtextInterpolate1,ɵɵtextInterpolate2,ɵɵtextInterpolate3,ɵɵtextInterpolate4,ɵɵtextInterpolate5,ɵɵtextInterpolate6,ɵɵtextInterpolate7,ɵɵtextInterpolate8,ɵɵtextInterpolateV,ɵɵi18n,ɵɵi18nAttributes,ɵɵi18nExp,ɵɵi18nStart,ɵɵi18nEnd,ɵɵi18nApply,ɵɵi18nPostprocess,ɵɵresolveWindow,ɵɵresolveDocument,ɵɵresolveBody,ɵɵsetComponentScope,ɵɵsetNgModuleScope,ɵɵregisterNgModuleType:registerNgModuleType,ɵɵgetComponentDepsFactory,ɵsetClassDebugInfo,ɵɵdeclareLet,ɵɵstoreLet,ɵɵreadContextLet,ɵɵattachSourceLocations,ɵɵinterpolate,ɵɵinterpolate1,ɵɵinterpolate2,ɵɵinterpolate3,ɵɵinterpolate4,ɵɵinterpolate5,ɵɵinterpolate6,ɵɵinterpolate7,ɵɵinterpolate8,ɵɵinterpolateV,ɵɵsanitizeHtml,ɵɵsanitizeStyle,ɵɵsanitizeResourceUrl,ɵɵsanitizeScript,ɵɵsanitizeUrl,ɵɵsanitizeUrlOrResourceUrl,ɵɵtrustConstantHtml,ɵɵtrustConstantResourceUrl,ɵɵvalidateIframeAttribute,forwardRef,resolveForwardRef,ɵɵtwoWayProperty,ɵɵtwoWayBindingSet,ɵɵtwoWayListener,ɵɵreplaceMetadata,ɵɵgetReplaceMetadataURL};let jitOptions=null;const moduleQueue=[];let flushingModuleQueue=!1;function isResolvedDeclaration(declaration){return Array.isArray(declaration)?declaration.every(isResolvedDeclaration):!!resolveForwardRef(declaration)}function compileNgModule(moduleType,ngModule={}){!function compileNgModuleDefs(moduleType,ngModule,allowDuplicateDeclarationsInRoot=!1){ngDevMode&&root_effect_scheduler_assertDefined(moduleType,"Required value moduleType"),ngDevMode&&root_effect_scheduler_assertDefined(ngModule,"Required value ngModule");const declarations=flatten(ngModule.declarations||EMPTY_ARRAY);let ngModuleDef=null;Object.defineProperty(moduleType,NG_MOD_DEF,{configurable:!0,get:()=>{if(null===ngModuleDef){if(ngDevMode&&ngModule.imports&&ngModule.imports.indexOf(moduleType)>-1)throw new Error(`'${root_effect_scheduler_stringifyForError(moduleType)}' module can't import itself`);const compiler=debug_node_getCompilerFacade({usage:0,kind:"NgModule",type:moduleType});ngModuleDef=compiler.compileNgModule(debug_node_angularCoreEnv,`ng:///${moduleType.name}/ɵmod.js`,{type:moduleType,bootstrap:flatten(ngModule.bootstrap||EMPTY_ARRAY).map(resolveForwardRef),declarations:declarations.map(resolveForwardRef),imports:flatten(ngModule.imports||EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),exports:flatten(ngModule.exports||EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),schemas:ngModule.schemas?flatten(ngModule.schemas):null,id:ngModule.id||null}),ngModuleDef.schemas||(ngModuleDef.schemas=[])}return ngModuleDef}});let ngFactoryDef=null;Object.defineProperty(moduleType,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const compiler=debug_node_getCompilerFacade({usage:0,kind:"NgModule",type:moduleType});ngFactoryDef=compiler.compileFactory(debug_node_angularCoreEnv,`ng:///${moduleType.name}/ɵfac.js`,{name:moduleType.name,type:moduleType,deps:reflectDependencies(moduleType),target:compiler.FactoryTarget.NgModule,typeArgumentCount:0})}return ngFactoryDef},configurable:!!ngDevMode});let ngInjectorDef=null;Object.defineProperty(moduleType,NG_INJ_DEF,{get:()=>{if(null===ngInjectorDef){ngDevMode&&verifySemanticsOfNgModuleDef(moduleType,allowDuplicateDeclarationsInRoot);const meta={name:moduleType.name,type:moduleType,providers:ngModule.providers||EMPTY_ARRAY,imports:[(ngModule.imports||EMPTY_ARRAY).map(resolveForwardRef),(ngModule.exports||EMPTY_ARRAY).map(resolveForwardRef)]},compiler=debug_node_getCompilerFacade({usage:0,kind:"NgModule",type:moduleType});ngInjectorDef=compiler.compileInjector(debug_node_angularCoreEnv,`ng:///${moduleType.name}/ɵinj.js`,meta)}return ngInjectorDef},configurable:!!ngDevMode})}(moduleType,ngModule),void 0!==ngModule.id&&registerNgModuleType(moduleType,ngModule.id),function enqueueModuleForDelayedScoping(moduleType,ngModule){moduleQueue.push({moduleType,ngModule})}(moduleType,ngModule)}function verifySemanticsOfNgModuleDef(moduleType,allowDuplicateDeclarationsInRoot,importingModule){if(verifiedNgModule.get(moduleType))return;if(isStandalone(moduleType))return;let ngModuleDef;if(verifiedNgModule.set(moduleType,!0),moduleType=resolveForwardRef(moduleType),importingModule){if(ngModuleDef=getNgModuleDef(moduleType),!ngModuleDef)throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`)}else ngModuleDef=getNgModuleDefOrThrow(moduleType);const errors=[],declarations=maybeUnwrapFn(ngModuleDef.declarations),imports=maybeUnwrapFn(ngModuleDef.imports);flatten(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt=>{verifySemanticsOfNgModuleImport(modOrStandaloneCmpt,moduleType),verifySemanticsOfNgModuleDef(modOrStandaloneCmpt,!1,moduleType)});const exports=maybeUnwrapFn(ngModuleDef.exports);declarations.forEach(function verifyDeclarationsHaveDefinitions(type){type=resolveForwardRef(type);root_effect_scheduler_getComponentDef(type)||getDirectiveDef(type)||getPipeDef(type)||errors.push(`Unexpected value '${root_effect_scheduler_stringifyForError(type)}' declared by the module '${root_effect_scheduler_stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`)}),declarations.forEach(function verifyDirectivesHaveSelector(type){const def=getDirectiveDef(type=resolveForwardRef(type));!root_effect_scheduler_getComponentDef(type)&&def&&0==def.selectors.length&&errors.push(`Directive ${root_effect_scheduler_stringifyForError(type)} has no selector, please add it!`)}),declarations.forEach(declarationType=>function verifyNotStandalone(type,moduleType){const def=root_effect_scheduler_getComponentDef(type=resolveForwardRef(type))||getDirectiveDef(type)||getPipeDef(type);if(def?.standalone){const location=`"${root_effect_scheduler_stringifyForError(moduleType)}" NgModule`;errors.push(function generateStandaloneInDeclarationsError(type,location){return`Unexpected "${root_effect_scheduler_stringifyForError(type)}" found in the "declarations" array of the ${location}, "${root_effect_scheduler_stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`}(type,location))}}(declarationType,moduleType));const combinedDeclarations=[...declarations.map(resolveForwardRef),...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];exports.forEach(function verifyExportsAreDeclaredOrReExported(type){const kind=(root_effect_scheduler_getComponentDef(type=resolveForwardRef(type))?"component":getDirectiveDef(type)&&"directive")||getPipeDef(type)&&"pipe";kind&&-1===combinedDeclarations.lastIndexOf(type)&&errors.push(`Can't export ${kind} ${root_effect_scheduler_stringifyForError(type)} from ${root_effect_scheduler_stringifyForError(moduleType)} as it was neither declared nor imported!`)}),declarations.forEach(decl=>function verifyDeclarationIsUnique(type,suppressErrors){type=resolveForwardRef(type);const existingModule=ownerNgModule.get(type);if(existingModule&&existingModule!==moduleType){if(!suppressErrors){const modules=[existingModule,moduleType].map(root_effect_scheduler_stringifyForError).sort();errors.push(`Type ${root_effect_scheduler_stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! Please consider moving ${root_effect_scheduler_stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. You can also create a new NgModule that exports and includes ${root_effect_scheduler_stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`)}}else ownerNgModule.set(type,moduleType)}(decl,allowDuplicateDeclarationsInRoot));const ngModule=function getAnnotation(type,name){let annotation=null;return collect(type.__annotations__),collect(type.decorators),annotation;function collect(annotations){annotations&&annotations.forEach(readAnnotation)}function readAnnotation(decorator){if(!annotation){if(Object.getPrototypeOf(decorator).ngMetadataName==name)annotation=decorator;else if(decorator.type){Object.getPrototypeOf(decorator.type).ngMetadataName==name&&(annotation=decorator.args[0])}}}}(moduleType,"NgModule");if(ngModule&&(ngModule.imports&&flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod=>{verifySemanticsOfNgModuleImport(mod,moduleType),verifySemanticsOfNgModuleDef(mod,!1,moduleType)}),ngModule.bootstrap&&deepForEach(ngModule.bootstrap,function verifyCorrectBootstrapType(type){root_effect_scheduler_getComponentDef(type=resolveForwardRef(type))||errors.push(`${root_effect_scheduler_stringifyForError(type)} cannot be used as an entry component.`);isStandalone(type)&&errors.push(`The \`${root_effect_scheduler_stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`)}),ngModule.bootstrap&&deepForEach(ngModule.bootstrap,function verifyComponentIsPartOfNgModule(type){type=resolveForwardRef(type);ownerNgModule.get(type)||isStandalone(type)||errors.push(`Component ${root_effect_scheduler_stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`)})),errors.length)throw new Error(errors.join("\n"));function verifySemanticsOfNgModuleImport(type,importingModule){const directiveDef=root_effect_scheduler_getComponentDef(type=resolveForwardRef(type))||getDirectiveDef(type);if(null!==directiveDef&&!directiveDef.standalone)throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);const pipeDef=getPipeDef(type);if(null!==pipeDef&&!pipeDef.standalone)throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`)}}function unwrapModuleWithProvidersImports(typeOrWithProviders){return(typeOrWithProviders=resolveForwardRef(typeOrWithProviders)).ngModule||typeOrWithProviders}let ownerNgModule=new WeakMap,verifiedNgModule=new WeakMap;function computeCombinedExports(type){const ngModuleDef=getNgModuleDef(type=resolveForwardRef(type));return null===ngModuleDef?[type]:flatten(maybeUnwrapFn(ngModuleDef.exports).map(type=>getNgModuleDef(type)?(verifySemanticsOfNgModuleDef(type,!1),computeCombinedExports(type)):type))}function setScopeOnDeclaredComponents(moduleType,ngModule){const declarations=flatten(ngModule.declarations||EMPTY_ARRAY),transitiveScopes=transitiveScopesFor(moduleType);declarations.forEach(declaration=>{if((declaration=resolveForwardRef(declaration)).hasOwnProperty(NG_COMP_DEF)){patchComponentDefWithScope(root_effect_scheduler_getComponentDef(declaration),transitiveScopes)}else declaration.hasOwnProperty(NG_DIR_DEF)||declaration.hasOwnProperty(NG_PIPE_DEF)||(declaration.ngSelectorScope=moduleType)})}function patchComponentDefWithScope(componentDef,transitiveScopes){componentDef.directiveDefs=()=>Array.from(transitiveScopes.compilation.directives).map(dir=>dir.hasOwnProperty(NG_COMP_DEF)?root_effect_scheduler_getComponentDef(dir):getDirectiveDef(dir)).filter(def=>!!def),componentDef.pipeDefs=()=>Array.from(transitiveScopes.compilation.pipes).map(pipe=>getPipeDef(pipe)),componentDef.schemas=transitiveScopes.schemas,componentDef.tView=null}function transitiveScopesFor(type){if(isNgModule(type)){const scope=depsTracker.getNgModuleScope(type);return{schemas:getNgModuleDefOrThrow(type).schemas||null,...scope}}if(isStandalone(type)){if(null!==(root_effect_scheduler_getComponentDef(type)||getDirectiveDef(type)))return{schemas:null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set([type]),pipes:new Set}};if(null!==getPipeDef(type))return{schemas:null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set,pipes:new Set([type])}}}throw new Error(`${type.name} does not have a module def (ɵmod property)`)}function expandModuleWithProviders(value){return isModuleWithProviders(value)?value.ngModule:value}let compilationDepth=0;function compileComponent(type,metadata){("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode();let ngComponentDef=null;!function maybeQueueResolutionOfComponentResources(type,metadata){componentNeedsResolution(metadata)&&(componentResourceResolutionQueue.set(type,metadata),componentDefPendingResolution.add(type))}(type,metadata),addDirectiveFactoryDef(type,metadata),Object.defineProperty(type,NG_COMP_DEF,{get:()=>{if(null===ngComponentDef){const compiler=debug_node_getCompilerFacade({usage:0,kind:"component",type});if(componentNeedsResolution(metadata)){const error=[`Component '${type.name}' is not resolved:`];throw metadata.templateUrl&&error.push(` - templateUrl: ${metadata.templateUrl}`),metadata.styleUrls&&metadata.styleUrls.length&&error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`),metadata.styleUrl&&error.push(` - styleUrl: ${metadata.styleUrl}`),error.push("Did you run and wait for 'resolveComponentResources()'?"),new Error(error.join("\n"))}const options=function getJitOptions(){return jitOptions}();let preserveWhitespaces=metadata.preserveWhitespaces;void 0===preserveWhitespaces&&(preserveWhitespaces=null!==options&&void 0!==options.preserveWhitespaces&&options.preserveWhitespaces);let encapsulation=metadata.encapsulation;void 0===encapsulation&&(encapsulation=null!==options&&void 0!==options.defaultEncapsulation?options.defaultEncapsulation:ViewEncapsulation.Emulated);const templateUrl=metadata.templateUrl||`ng:///${type.name}/template.html`,baseMeta=directiveMetadata(type,metadata),meta={...baseMeta,typeSourceSpan:compiler.createParseSourceSpan("Component",type.name,templateUrl),template:metadata.template||"",preserveWhitespaces,styles:"string"==typeof metadata.styles?[metadata.styles]:metadata.styles||EMPTY_ARRAY,animations:metadata.animations,declarations:[],changeDetection:metadata.changeDetection,encapsulation,interpolation:metadata.interpolation,viewProviders:metadata.viewProviders||null,hasDirectiveDependencies:!baseMeta.isStandalone||null!=metadata.imports&&metadata.imports.length>0};compilationDepth++;try{if(meta.usesInheritance&&addDirectiveDefToUndecoratedParents(type),ngComponentDef=compiler.compileComponent(debug_node_angularCoreEnv,templateUrl,meta),meta.isStandalone){const imports=flatten(metadata.imports||EMPTY_ARRAY),{directiveDefs,pipeDefs}=function getStandaloneDefFunctions(type,imports){const directiveDefs=()=>{if(ngDevMode)for(const rawDep of imports)verifyStandaloneImport(rawDep,type);if(!isComponent(type))return[];return[...depsTracker.getStandaloneComponentScope(type,imports).compilation.directives].map(p=>root_effect_scheduler_getComponentDef(p)||getDirectiveDef(p)).filter(d=>null!==d)},pipeDefs=()=>{if(ngDevMode)for(const rawDep of imports)verifyStandaloneImport(rawDep,type);if(!isComponent(type))return[];return[...depsTracker.getStandaloneComponentScope(type,imports).compilation.pipes].map(p=>getPipeDef(p)).filter(d=>null!==d)};return{directiveDefs,pipeDefs}}(type,imports);ngComponentDef.directiveDefs=directiveDefs,ngComponentDef.pipeDefs=pipeDefs,ngComponentDef.dependencies=()=>imports.map(resolveForwardRef)}}finally{compilationDepth--}if(0===compilationDepth&&function flushModuleScopingQueueAsMuchAsPossible(){if(!flushingModuleQueue){flushingModuleQueue=!0;try{for(let i=moduleQueue.length-1;i>=0;i--){const{moduleType,ngModule}=moduleQueue[i];ngModule.declarations&&ngModule.declarations.every(isResolvedDeclaration)&&(moduleQueue.splice(i,1),setScopeOnDeclaredComponents(moduleType,ngModule))}}finally{flushingModuleQueue=!1}}}(),function hasSelectorScope(component){return void 0!==component.ngSelectorScope}(type)){const scopes=transitiveScopesFor(type.ngSelectorScope);patchComponentDefWithScope(ngComponentDef,scopes)}if(metadata.schemas){if(!meta.isStandalone)throw new Error(`The 'schemas' was specified for the ${root_effect_scheduler_stringifyForError(type)} but is only valid on a component that is standalone.`);ngComponentDef.schemas=metadata.schemas}else meta.isStandalone&&(ngComponentDef.schemas=[])}return ngComponentDef},set:def=>{ngComponentDef=def},configurable:!!ngDevMode})}function compileDirective(type,directive){let ngDirectiveDef=null;addDirectiveFactoryDef(type,directive||{}),Object.defineProperty(type,NG_DIR_DEF,{get:()=>{if(null===ngDirectiveDef){const meta=getDirectiveMetadata(type,directive||{}),compiler=debug_node_getCompilerFacade({usage:0,kind:"directive",type});ngDirectiveDef=compiler.compileDirective(debug_node_angularCoreEnv,meta.sourceMapUrl,meta.metadata)}return ngDirectiveDef},configurable:!!ngDevMode})}function getDirectiveMetadata(type,metadata){const name=type&&type.name,sourceMapUrl=`ng:///${name}/ɵdir.js`,compiler=debug_node_getCompilerFacade({usage:0,kind:"directive",type}),facade=directiveMetadata(type,metadata);return facade.typeSourceSpan=compiler.createParseSourceSpan("Directive",name,sourceMapUrl),facade.usesInheritance&&addDirectiveDefToUndecoratedParents(type),{metadata:facade,sourceMapUrl}}function addDirectiveFactoryDef(type,metadata){let ngFactoryDef=null;Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const meta=getDirectiveMetadata(type,metadata),compiler=debug_node_getCompilerFacade({usage:0,kind:"directive",type});ngFactoryDef=compiler.compileFactory(debug_node_angularCoreEnv,`ng:///${type.name}/ɵfac.js`,{name:meta.metadata.name,type:meta.metadata.type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Directive})}return ngFactoryDef},configurable:!!ngDevMode})}function extendsDirectlyFromObject(type){return Object.getPrototypeOf(type.prototype)===Object.prototype}function directiveMetadata(type,metadata){const reflect=getReflect(),propMetadata=reflect.ownPropMetadata(type);return{name:type.name,type,selector:void 0!==metadata.selector?metadata.selector:null,host:metadata.host||EMPTY_OBJ,propMetadata,inputs:metadata.inputs||EMPTY_ARRAY,outputs:metadata.outputs||EMPTY_ARRAY,queries:extractQueriesMetadata(type,propMetadata,isContentQuery),lifecycle:{usesOnChanges:reflect.hasLifecycleHook(type,"ngOnChanges")},typeSourceSpan:null,usesInheritance:!extendsDirectlyFromObject(type),exportAs:(exportAs=metadata.exportAs,void 0===exportAs?null:splitByComma(exportAs)),providers:metadata.providers||null,viewQueries:extractQueriesMetadata(type,propMetadata,isViewQuery),isStandalone:void 0===metadata.standalone||!!metadata.standalone,isSignal:!!metadata.signals,hostDirectives:metadata.hostDirectives?.map(directive=>"function"==typeof directive?{directive}:directive)||null};var exportAs}function addDirectiveDefToUndecoratedParents(type){const objPrototype=Object.prototype;let parent=Object.getPrototypeOf(type.prototype).constructor;for(;parent&&parent!==objPrototype;)getDirectiveDef(parent)||root_effect_scheduler_getComponentDef(parent)||!shouldAddAbstractDirective(parent)||compileDirective(parent,null),parent=Object.getPrototypeOf(parent)}function convertToR3QueryMetadata(propertyName,ann){return{propertyName,predicate:(selector=ann.selector,"string"==typeof selector?splitByComma(selector):resolveForwardRef(selector)),descendants:ann.descendants,first:ann.first,read:ann.read?ann.read:null,static:!!ann.static,emitDistinctChangesOnly:!!ann.emitDistinctChangesOnly,isSignal:!!ann.isSignal};var selector}function extractQueriesMetadata(type,propMetadata,isQueryAnn){const queriesMeta=[];for(const field in propMetadata)if(propMetadata.hasOwnProperty(field)){const annotations=propMetadata[field];annotations.forEach(ann=>{if(isQueryAnn(ann)){if(!ann.selector)throw new Error(`Can't construct a query for the property "${field}" of "${root_effect_scheduler_stringifyForError(type)}" since the query selector wasn't defined.`);if(annotations.some(isInputAnnotation))throw new Error("Cannot combine @Input decorators with query decorators");queriesMeta.push(convertToR3QueryMetadata(field,ann))}})}return queriesMeta}function isContentQuery(value){const name=value.ngMetadataName;return"ContentChild"===name||"ContentChildren"===name}function isViewQuery(value){const name=value.ngMetadataName;return"ViewChild"===name||"ViewChildren"===name}function isInputAnnotation(value){return"Input"===value.ngMetadataName}function splitByComma(value){return value.split(",").map(piece=>piece.trim())}const LIFECYCLE_HOOKS=["ngOnChanges","ngOnInit","ngOnDestroy","ngDoCheck","ngAfterViewInit","ngAfterViewChecked","ngAfterContentInit","ngAfterContentChecked"];function shouldAddAbstractDirective(type){const reflect=getReflect();if(LIFECYCLE_HOOKS.some(hookName=>reflect.hasLifecycleHook(type,hookName)))return!0;const propMetadata=reflect.propMetadata(type);for(const field in propMetadata){const annotations=propMetadata[field];for(let i=0;i<annotations.length;i++){const current=annotations[i],metadataName=current.ngMetadataName;if(isInputAnnotation(current)||isContentQuery(current)||isViewQuery(current)||"Output"===metadataName||"HostBinding"===metadataName||"HostListener"===metadataName)return!0}}return!1}function getPipeMetadata(type,meta){return{type,name:type.name,pipeName:meta.name,pure:void 0===meta.pure||meta.pure,isStandalone:void 0===meta.standalone||!!meta.standalone}}const Directive=makeDecorator("Directive",(dir={})=>dir,void 0,0,(type,meta)=>compileDirective(type,meta)),Input=(makeDecorator("Component",(c={})=>({changeDetection:ChangeDetectionStrategy.Default,...c}),Directive,0,(type,meta)=>compileComponent(type,meta)),makeDecorator("Pipe",p=>({pure:!0,...p}),void 0,0,(type,meta)=>function compilePipe(type,meta){let ngPipeDef=null,ngFactoryDef=null;Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const metadata=getPipeMetadata(type,meta),compiler=debug_node_getCompilerFacade({usage:0,kind:"pipe",type:metadata.type});ngFactoryDef=compiler.compileFactory(debug_node_angularCoreEnv,`ng:///${metadata.name}/ɵfac.js`,{name:metadata.name,type:metadata.type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Pipe})}return ngFactoryDef},configurable:!!ngDevMode}),Object.defineProperty(type,NG_PIPE_DEF,{get:()=>{if(null===ngPipeDef){const metadata=getPipeMetadata(type,meta),compiler=debug_node_getCompilerFacade({usage:0,kind:"pipe",type:metadata.type});ngPipeDef=compiler.compilePipe(debug_node_angularCoreEnv,`ng:///${metadata.name}/ɵpipe.js`,metadata)}return ngPipeDef},configurable:!!ngDevMode})}(type,meta)),makePropDecorator("Input",arg=>arg?"string"==typeof arg?{alias:arg}:arg:{})),Output=makePropDecorator("Output",alias=>({alias})),NgModule=(makePropDecorator("HostBinding",hostPropertyName=>({hostPropertyName})),makePropDecorator("HostListener",(eventName,args)=>({eventName,args})),makeDecorator("NgModule",ngModule=>ngModule,void 0,0,(type,meta)=>compileNgModule(type,meta)));class ModuleWithComponentFactories{ngModuleFactory;componentFactories;constructor(ngModuleFactory,componentFactories){this.ngModuleFactory=ngModuleFactory,this.componentFactories=componentFactories}}class Compiler{compileModuleSync(moduleType){return new debug_node_NgModuleFactory(moduleType)}compileModuleAsync(moduleType){return Promise.resolve(this.compileModuleSync(moduleType))}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=maybeUnwrapFn(getNgModuleDef(moduleType).declarations).reduce((factories,declaration)=>{const componentDef=root_effect_scheduler_getComponentDef(declaration);return componentDef&&factories.push(new debug_node_ComponentFactory(componentDef)),factories},[]);return new ModuleWithComponentFactories(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType))}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){}static ɵfac=function Compiler_Factory(__ngFactoryType__){return new(__ngFactoryType__||Compiler)};static ɵprov=ɵɵdefineInjectable({token:Compiler,factory:Compiler.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(Compiler,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);const COMPILER_OPTIONS=new InjectionToken(ngDevMode?"compilerOptions":"");class NgZoneChangeDetectionScheduler{zone=root_effect_scheduler_inject(debug_node_NgZone);changeDetectionScheduler=root_effect_scheduler_inject(root_effect_scheduler_ChangeDetectionScheduler);applicationRef=root_effect_scheduler_inject(debug_node_ApplicationRef);applicationErrorHandler=root_effect_scheduler_inject(INTERNAL_APPLICATION_ERROR_HANDLER);_onMicrotaskEmptySubscription;initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{try{this.applicationRef.dirtyFlags|=1,this.applicationRef._tick()}catch(e){this.applicationErrorHandler(e)}})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static ɵfac=function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgZoneChangeDetectionScheduler)};static ɵprov=ɵɵdefineInjectable({token:NgZoneChangeDetectionScheduler,factory:NgZoneChangeDetectionScheduler.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgZoneChangeDetectionScheduler,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);const PROVIDED_NG_ZONE=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"provideZoneChangeDetection token":"",{factory:()=>!1});function debug_node_internalProvideZoneChangeDetection({ngZoneFactory,ignoreChangesOutsideZone,scheduleInRootZone}){return ngZoneFactory??=()=>new debug_node_NgZone({...getNgZoneOptions(),scheduleInRootZone}),[{provide:debug_node_NgZone,useFactory:ngZoneFactory},{provide:root_effect_scheduler_ENVIRONMENT_INITIALIZER,multi:!0,useFactory:()=>{const ngZoneChangeDetectionScheduler=root_effect_scheduler_inject(NgZoneChangeDetectionScheduler,{optional:!0});if(("undefined"==typeof ngDevMode||ngDevMode)&&null===ngZoneChangeDetectionScheduler)throw new root_effect_scheduler_RuntimeError(402,"A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.");return()=>ngZoneChangeDetectionScheduler.initialize()}},{provide:root_effect_scheduler_ENVIRONMENT_INITIALIZER,multi:!0,useFactory:()=>{const service=root_effect_scheduler_inject(ZoneStablePendingTask);return()=>{service.initialize()}}},!0===ignoreChangesOutsideZone?{provide:ZONELESS_SCHEDULER_DISABLED,useValue:!0}:[],{provide:root_effect_scheduler_SCHEDULE_IN_ROOT_ZONE,useValue:scheduleInRootZone??SCHEDULE_IN_ROOT_ZONE_DEFAULT},{provide:INTERNAL_APPLICATION_ERROR_HANDLER,useFactory:()=>{const zone=root_effect_scheduler_inject(debug_node_NgZone),injector=root_effect_scheduler_inject(EnvironmentInjector);let userErrorHandler;return e=>{zone.runOutsideAngular(()=>{injector.destroyed&&!userErrorHandler?setTimeout(()=>{throw e}):(userErrorHandler??=injector.get(root_effect_scheduler_ErrorHandler),userErrorHandler.handleError(e))})}}}]}function getNgZoneOptions(options){return{enableLongStackTrace:"undefined"!=typeof ngDevMode&&!!ngDevMode,shouldCoalesceEventChangeDetection:options?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:options?.runCoalescing??!1}}class ZoneStablePendingTask{subscription=new Subscription.yU;initialized=!1;zone=root_effect_scheduler_inject(debug_node_NgZone);pendingTasks=root_effect_scheduler_inject(PendingTasksInternal);initialize(){if(this.initialized)return;this.initialized=!0;let task=null;this.zone.isStable||this.zone.hasPendingMacrotasks||this.zone.hasPendingMicrotasks||(task=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{debug_node_NgZone.assertNotInAngularZone(),queueMicrotask(()=>{null===task||this.zone.hasPendingMacrotasks||this.zone.hasPendingMicrotasks||(this.pendingTasks.remove(task),task=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{debug_node_NgZone.assertInAngularZone(),task??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static ɵfac=function ZoneStablePendingTask_Factory(__ngFactoryType__){return new(__ngFactoryType__||ZoneStablePendingTask)};static ɵprov=ɵɵdefineInjectable({token:ZoneStablePendingTask,factory:ZoneStablePendingTask.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ZoneStablePendingTask,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);let consecutiveMicrotaskNotifications=0,stackFromLastFewNotifications=[];class debug_node_ChangeDetectionSchedulerImpl{applicationErrorHandler=root_effect_scheduler_inject(INTERNAL_APPLICATION_ERROR_HANDLER);appRef=root_effect_scheduler_inject(debug_node_ApplicationRef);taskService=root_effect_scheduler_inject(PendingTasksInternal);ngZone=root_effect_scheduler_inject(debug_node_NgZone);zonelessEnabled=root_effect_scheduler_inject(root_effect_scheduler_ZONELESS_ENABLED);tracing=root_effect_scheduler_inject(debug_node_TracingService,{optional:!0});disableScheduling=root_effect_scheduler_inject(ZONELESS_SCHEDULER_DISABLED,{optional:!0})??!1;zoneIsDefined="undefined"!=typeof Zone&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new Subscription.yU;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get("isAngularZone_ID"):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(root_effect_scheduler_inject(root_effect_scheduler_SCHEDULE_IN_ROOT_ZONE,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof NoopNgZone||!this.zoneIsDefined)}notify(source){if(!this.zonelessEnabled&&5===source)return;let force=!1;switch(source){case 0:this.appRef.dirtyFlags|=2;break;case 3:case 2:case 4:case 5:case 1:this.appRef.dirtyFlags|=4;break;case 6:case 13:this.appRef.dirtyFlags|=2,force=!0;break;case 12:this.appRef.dirtyFlags|=16,force=!0;break;case 11:force=!0;break;default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick(force))return;("undefined"==typeof ngDevMode||ngDevMode)&&(this.useMicrotaskScheduler?function trackMicrotaskNotificationForDebugging(){if(consecutiveMicrotaskNotifications++,100-consecutiveMicrotaskNotifications<5){const stack=(new Error).stack;stack&&stackFromLastFewNotifications.push(stack)}if(100===consecutiveMicrotaskNotifications)throw new root_effect_scheduler_RuntimeError(103,"Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n"+stackFromLastFewNotifications.join("\n"))}():(consecutiveMicrotaskNotifications=0,stackFromLastFewNotifications.length=0));const scheduleCallback=this.useMicrotaskScheduler?scheduleCallbackWithMicrotask:scheduleCallbackWithRafRace;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>scheduleCallback(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>scheduleCallback(()=>this.tick()))}shouldScheduleTick(force){return!(this.disableScheduling&&!force||this.appRef.destroyed)&&(null===this.pendingRenderTaskId&&!this.runningTick&&!this.appRef._runningTick&&!(!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get("isAngularZone_ID"+this.angularZoneId)))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(0===this.appRef.dirtyFlags)return void this.cleanup();!this.zonelessEnabled&&7&this.appRef.dirtyFlags&&(this.appRef.dirtyFlags|=1);const task=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(e){this.taskService.remove(task),this.applicationErrorHandler(e)}finally{this.cleanup()}this.useMicrotaskScheduler=!0,scheduleCallbackWithMicrotask(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(task)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,null!==this.pendingRenderTaskId){const taskId=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(taskId)}}static ɵfac=function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__){return new(__ngFactoryType__||debug_node_ChangeDetectionSchedulerImpl)};static ɵprov=ɵɵdefineInjectable({token:debug_node_ChangeDetectionSchedulerImpl,factory:debug_node_ChangeDetectionSchedulerImpl.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(debug_node_ChangeDetectionSchedulerImpl,[{type:Injectable,args:[{providedIn:"root"}]}],()=>[],null);const LOCALE_ID=new InjectionToken(ngDevMode?"LocaleId":"",{providedIn:"root",factory:()=>root_effect_scheduler_inject(LOCALE_ID,{optional:!0,skipSelf:!0})||function getGlobalLocale(){return"undefined"!=typeof ngI18nClosureMode&&ngI18nClosureMode&&"undefined"!=typeof goog&&"en"!==goog.LOCALE?goog.LOCALE:"undefined"!=typeof $localize&&$localize.locale||"en-US"}()});new InjectionToken(ngDevMode?"DefaultCurrencyCode":"",{providedIn:"root",factory:()=>"USD"}),new InjectionToken(ngDevMode?"Translations":""),new InjectionToken(ngDevMode?"TranslationsFormat":"");var MissingTranslationStrategy;!function(MissingTranslationStrategy){MissingTranslationStrategy[MissingTranslationStrategy.Error=0]="Error",MissingTranslationStrategy[MissingTranslationStrategy.Warning=1]="Warning",MissingTranslationStrategy[MissingTranslationStrategy.Ignore=2]="Ignore"}(MissingTranslationStrategy||(MissingTranslationStrategy={}));class resource_OutputEmitterRef{destroyed=!1;listeners=null;errorHandler=root_effect_scheduler_inject(root_effect_scheduler_ErrorHandler,{optional:!0});destroyRef=root_effect_scheduler_inject(DestroyRef);constructor(){this.destroyRef.onDestroy(()=>{this.destroyed=!0,this.listeners=null})}subscribe(callback){if(this.destroyed)throw new root_effect_scheduler_RuntimeError(953,ngDevMode&&"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");return(this.listeners??=[]).push(callback),{unsubscribe:()=>{const idx=this.listeners?.indexOf(callback);void 0!==idx&&-1!==idx&&this.listeners?.splice(idx,1)}}}emit(value){if(this.destroyed)return void console.warn(root_effect_scheduler_formatRuntimeError(953,ngDevMode&&"Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed."));if(null===this.listeners)return;const previousConsumer=setActiveConsumer(null);try{for(const listenerFn of this.listeners)try{listenerFn(value)}catch(err){this.errorHandler?.handleError(err)}}finally{setActiveConsumer(previousConsumer)}}}function resource_untracked(nonReactiveReadsFn){return function untracked(nonReactiveReadsFn){const prevConsumer=setActiveConsumer(null);try{return nonReactiveReadsFn()}finally{setActiveConsumer(prevConsumer)}}(nonReactiveReadsFn)}function computed(computation,options){const getter=createComputed(computation,options?.equal);return ngDevMode&&(getter.toString=()=>`[Computed: ${getter()}]`,getter[SIGNAL].debugName=options?.debugName),getter}Error;Error;const REQUIRED_UNSET_VALUE=Symbol("InputSignalNode#UNSET"),INPUT_SIGNAL_NODE=(()=>({...SIGNAL_NODE,transformFn:void 0,applyValueToInputSignal(node,value){signalSetFn(node,value)}}))();function createInputSignal(initialValue,options){const node=Object.create(INPUT_SIGNAL_NODE);function inputValueFn(){if(producerAccessed(node),node.value===REQUIRED_UNSET_VALUE){let message=null;if(ngDevMode){const name=options?.debugName??options?.alias;message=`Input${name?` "${name}"`:""} is required but no value is available yet.`}throw new root_effect_scheduler_RuntimeError(-950,message)}return node.value}return node.value=initialValue,node.transformFn=options?.transform,inputValueFn[SIGNAL]=node,ngDevMode&&(inputValueFn.toString=()=>`[Input Signal: ${inputValueFn()}]`,node.debugName=options?.debugName),inputValueFn}var FactoryTarget,R3TemplateDependencyKind,core_ViewEncapsulation;!function(FactoryTarget){FactoryTarget[FactoryTarget.Directive=0]="Directive",FactoryTarget[FactoryTarget.Component=1]="Component",FactoryTarget[FactoryTarget.Injectable=2]="Injectable",FactoryTarget[FactoryTarget.Pipe=3]="Pipe",FactoryTarget[FactoryTarget.NgModule=4]="NgModule"}(FactoryTarget||(FactoryTarget={})),function(R3TemplateDependencyKind){R3TemplateDependencyKind[R3TemplateDependencyKind.Directive=0]="Directive",R3TemplateDependencyKind[R3TemplateDependencyKind.Pipe=1]="Pipe",R3TemplateDependencyKind[R3TemplateDependencyKind.NgModule=2]="NgModule"}(R3TemplateDependencyKind||(R3TemplateDependencyKind={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(core_ViewEncapsulation||(core_ViewEncapsulation={}));function inputFunction(initialValue,opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(input),createInputSignal(initialValue,opts)}function inputRequiredFunction(opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(input),createInputSignal(REQUIRED_UNSET_VALUE,opts)}new InjectionToken(ngDevMode?"HOST_TAG_NAME":"").__NG_ELEMENT_ID__=flags=>{const tNode=root_effect_scheduler_getCurrentTNode();if(null===tNode)throw new root_effect_scheduler_RuntimeError(204,ngDevMode&&"HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");if(2&tNode.type)return tNode.value;if(8&flags)return null;throw new root_effect_scheduler_RuntimeError(204,ngDevMode&&`HOST_TAG_NAME was used on ${function getDevModeNodeName(tNode){return 8&tNode.type?"an <ng-container>":4&tNode.type?"an <ng-template>":128&tNode.type?"an @let declaration":"a node"}(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`)};const input=(inputFunction.required=inputRequiredFunction,inputFunction);function viewChildFn(locator,opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(viewChild),createSingleResultOptionalQuerySignalFn(opts)}function viewChildRequiredFn(locator,opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(viewChild),createSingleResultRequiredQuerySignalFn(opts)}const viewChild=(viewChildFn.required=viewChildRequiredFn,viewChildFn);function contentChildFn(locator,opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(contentChild),createSingleResultOptionalQuerySignalFn(opts)}function contentChildRequiredFn(locator,opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(contentChildren),createSingleResultRequiredQuerySignalFn(opts)}const contentChild=(contentChildFn.required=contentChildRequiredFn,contentChildFn);function contentChildren(locator,opts){return function debug_node_createMultiResultQuerySignalFn(opts){return createQuerySignalFn(!1,!1,opts)}(opts)}function createModelSignal(initialValue,opts){const node=Object.create(INPUT_SIGNAL_NODE),emitterRef=new resource_OutputEmitterRef;function getter(){return producerAccessed(node),assertModelSet(node.value),node.value}return node.value=initialValue,getter[SIGNAL]=node,getter.asReadonly=signalAsReadonlyFn.bind(getter),getter.set=newValue=>{node.equal(node.value,newValue)||(signalSetFn(node,newValue),emitterRef.emit(newValue))},getter.update=updateFn=>{assertModelSet(node.value),getter.set(updateFn(node.value))},getter.subscribe=emitterRef.subscribe.bind(emitterRef),getter.destroyRef=emitterRef.destroyRef,ngDevMode&&(getter.toString=()=>`[Model Signal: ${getter()}]`,node.debugName=opts?.debugName),getter}function assertModelSet(value){if(value===REQUIRED_UNSET_VALUE)throw new root_effect_scheduler_RuntimeError(952,ngDevMode&&"Model is required but no value is available yet.")}function modelFunction(initialValue,opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(model),createModelSignal(initialValue,opts)}function modelRequiredFunction(opts){return ngDevMode&&root_effect_scheduler_assertInInjectionContext(model),createModelSignal(REQUIRED_UNSET_VALUE,opts)}const model=(modelFunction.required=modelRequiredFunction,modelFunction);class Query{}makePropDecorator("ContentChildren",(selector,opts={})=>({selector,first:!1,isViewQuery:!1,descendants:!1,emitDistinctChangesOnly:true,...opts}),Query),makePropDecorator("ContentChild",(selector,opts={})=>({selector,first:!0,isViewQuery:!1,descendants:!0,...opts}),Query),makePropDecorator("ViewChildren",(selector,opts={})=>({selector,first:!1,isViewQuery:!0,descendants:!0,emitDistinctChangesOnly:true,...opts}),Query),makePropDecorator("ViewChild",(selector,opts)=>({selector,first:!0,isViewQuery:!0,descendants:!0,...opts}),Query);function compileNgModuleFactory(injector,options,moduleType){ngDevMode&&function assertNgModuleType(actual,msg="Type passed in is not NgModuleType, it does not have 'ɵmod' property."){getNgModuleDef(actual)||throwError(msg)}(moduleType);const moduleFactory=new debug_node_NgModuleFactory(moduleType);if("undefined"!=typeof ngJitMode&&!ngJitMode)return Promise.resolve(moduleFactory);const compilerOptions=injector.get(COMPILER_OPTIONS,[]).concat(options);if(function setJitOptions(options){if(null!==jitOptions){if(options.defaultEncapsulation!==jitOptions.defaultEncapsulation)return void(ngDevMode&&console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set."));if(options.preserveWhitespaces!==jitOptions.preserveWhitespaces)return void(ngDevMode&&console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set."))}jitOptions=options}({defaultEncapsulation:_lastDefined(compilerOptions.map(opts=>opts.defaultEncapsulation)),preserveWhitespaces:_lastDefined(compilerOptions.map(opts=>opts.preserveWhitespaces))}),function isComponentResourceResolutionQueueEmpty(){return 0===componentResourceResolutionQueue.size}())return Promise.resolve(moduleFactory);const compilerProviders=compilerOptions.flatMap(option=>option.providers??[]);if(0===compilerProviders.length)return Promise.resolve(moduleFactory);const compiler=debug_node_getCompilerFacade({usage:0,kind:"NgModule",type:moduleType}),resourceLoader=root_effect_scheduler_Injector.create({providers:compilerProviders}).get(compiler.ResourceLoader);return resolveComponentResources(url=>Promise.resolve(resourceLoader.get(url))).then(()=>moduleFactory)}function _lastDefined(args){for(let i=args.length-1;i>=0;i--)if(void 0!==args[i])return args[i]}class ImagePerformanceWarning{window=null;observer=null;options=root_effect_scheduler_inject(IMAGE_CONFIG);lcpImageUrl;start(){if("undefined"!=typeof ngServerMode&&ngServerMode||"undefined"==typeof PerformanceObserver||this.options?.disableImageSizeWarning&&this.options?.disableImageLazyLoadWarning)return;this.observer=this.initPerformanceObserver();const doc=debug_node_getDocument(),win=doc.defaultView;if(win){this.window=win;const waitToScan=()=>{setTimeout(this.scanImages.bind(this),200)},setup=()=>{"complete"===doc.readyState?waitToScan():this.window?.addEventListener("load",waitToScan,{once:!0})};"undefined"!=typeof Zone?Zone.root.run(()=>setup()):setup()}}ngOnDestroy(){this.observer?.disconnect()}initPerformanceObserver(){if("undefined"==typeof PerformanceObserver)return null;const observer=new PerformanceObserver(entryList=>{const entries=entryList.getEntries();if(0===entries.length)return;const lcpElement=entries[entries.length-1],imgSrc=lcpElement.element?.src??"";imgSrc.startsWith("data:")||imgSrc.startsWith("blob:")||(this.lcpImageUrl=imgSrc)});return observer.observe({type:"largest-contentful-paint",buffered:!0}),observer}scanImages(){const images=debug_node_getDocument().querySelectorAll("img");let lcpElementFound,lcpElementLoadedCorrectly=!1;for(let index=0;index<images.length;index++){const image=images[index];image&&(this.options?.disableImageSizeWarning||!image.getAttribute("ng-img")&&this.isOversized(image)&&logOversizedImageWarning(image.src),!this.options?.disableImageLazyLoadWarning&&this.lcpImageUrl&&image.src===this.lcpImageUrl&&(lcpElementFound=!0,("lazy"!==image.loading||image.getAttribute("ng-img"))&&(lcpElementLoadedCorrectly=!0)))}lcpElementFound&&!lcpElementLoadedCorrectly&&this.lcpImageUrl&&!this.options?.disableImageLazyLoadWarning&&function logLazyLCPWarning(src){console.warn(root_effect_scheduler_formatRuntimeError(-913,`An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`))}(this.lcpImageUrl)}isOversized(image){if(!this.window)return!1;const imageSource=(image.src||"").toLowerCase();if([".svg"].some(extension=>imageSource.endsWith(extension)))return!1;const computedStyle=this.window.getComputedStyle(image);let renderedWidth=parseFloat(computedStyle.getPropertyValue("width")),renderedHeight=parseFloat(computedStyle.getPropertyValue("height"));const boxSizing=computedStyle.getPropertyValue("box-sizing");if("cover"===computedStyle.getPropertyValue("object-fit"))return!1;if("border-box"===boxSizing){const paddingTop=computedStyle.getPropertyValue("padding-top"),paddingRight=computedStyle.getPropertyValue("padding-right"),paddingBottom=computedStyle.getPropertyValue("padding-bottom"),paddingLeft=computedStyle.getPropertyValue("padding-left");renderedWidth-=parseFloat(paddingRight)+parseFloat(paddingLeft),renderedHeight-=parseFloat(paddingTop)+parseFloat(paddingBottom)}const intrinsicWidth=image.naturalWidth,intrinsicHeight=image.naturalHeight,recommendedWidth=this.window.devicePixelRatio*renderedWidth,recommendedHeight=this.window.devicePixelRatio*renderedHeight;return intrinsicWidth-recommendedWidth>=1200||intrinsicHeight-recommendedHeight>=1200}static ɵfac=function ImagePerformanceWarning_Factory(__ngFactoryType__){return new(__ngFactoryType__||ImagePerformanceWarning)};static ɵprov=ɵɵdefineInjectable({token:ImagePerformanceWarning,factory:ImagePerformanceWarning.ɵfac,providedIn:"root"})}function logOversizedImageWarning(src){console.warn(root_effect_scheduler_formatRuntimeError(-913,`An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`))}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ImagePerformanceWarning,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);const PLATFORM_DESTROY_LISTENERS=new InjectionToken(ngDevMode?"PlatformDestroyListeners":""),ENABLE_ROOT_COMPONENT_BOOTSTRAP=new InjectionToken(ngDevMode?"ENABLE_ROOT_COMPONENT_BOOTSTRAP":"");function isApplicationBootstrapConfig(config){return!config.moduleRef}function bootstrap(config){const envInjector=isApplicationBootstrapConfig(config)?config.r3Injector:config.moduleRef.injector,ngZone=envInjector.get(debug_node_NgZone);return ngZone.run(()=>{isApplicationBootstrapConfig(config)?config.r3Injector.resolveInjectorInitializers():config.moduleRef.resolveInjectorInitializers();const exceptionHandler=envInjector.get(INTERNAL_APPLICATION_ERROR_HANDLER);if(("undefined"==typeof ngDevMode||ngDevMode)&&envInjector.get(root_effect_scheduler_PROVIDED_ZONELESS)&&envInjector.get(PROVIDED_NG_ZONE))throw new root_effect_scheduler_RuntimeError(408,"Invalid change detection configuration: provideZoneChangeDetection and provideZonelessChangeDetection cannot be used together.");let onErrorSubscription;if(ngZone.runOutsideAngular(()=>{onErrorSubscription=ngZone.onError.subscribe({next:exceptionHandler})}),isApplicationBootstrapConfig(config)){const destroyListener=()=>envInjector.destroy(),onPlatformDestroyListeners=config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);onPlatformDestroyListeners.add(destroyListener),envInjector.onDestroy(()=>{onErrorSubscription.unsubscribe(),onPlatformDestroyListeners.delete(destroyListener)})}else{const destroyListener=()=>config.moduleRef.destroy(),onPlatformDestroyListeners=config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);onPlatformDestroyListeners.add(destroyListener),config.moduleRef.onDestroy(()=>{remove(config.allPlatformModules,config.moduleRef),onErrorSubscription.unsubscribe(),onPlatformDestroyListeners.delete(destroyListener)})}return function _callAndReportToErrorHandler(errorHandler,ngZone,callback){try{const result=callback();return isPromise(result)?result.catch(e=>{throw ngZone.runOutsideAngular(()=>errorHandler(e)),e}):result}catch(e){throw ngZone.runOutsideAngular(()=>errorHandler(e)),e}}(exceptionHandler,ngZone,()=>{const pendingTasks=envInjector.get(PendingTasksInternal),taskId=pendingTasks.add(),initStatus=envInjector.get(ApplicationInitStatus);return initStatus.runInitializers(),initStatus.donePromise.then(()=>{!function setLocaleId(localeId){ngDevMode&&root_effect_scheduler_assertDefined(localeId,"Expected localeId to be defined"),"string"==typeof localeId&&(LOCALE_ID$1=localeId.toLowerCase().replace(/_/g,"-"))}(envInjector.get(LOCALE_ID,"en-US")||"en-US");if(!envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP,!0))return isApplicationBootstrapConfig(config)?envInjector.get(debug_node_ApplicationRef):(config.allPlatformModules.push(config.moduleRef),config.moduleRef);if("undefined"==typeof ngDevMode||ngDevMode){envInjector.get(ImagePerformanceWarning).start()}if(isApplicationBootstrapConfig(config)){const appRef=envInjector.get(debug_node_ApplicationRef);return void 0!==config.rootComponent&&appRef.bootstrap(config.rootComponent),appRef}return moduleBootstrapImpl?.(config.moduleRef,config.allPlatformModules),config.moduleRef}).finally(()=>{pendingTasks.remove(taskId)})})})}let moduleBootstrapImpl;function setModuleBootstrapImpl(){moduleBootstrapImpl=_moduleDoBootstrap}function _moduleDoBootstrap(moduleRef,allPlatformModules){const appRef=moduleRef.injector.get(debug_node_ApplicationRef);if(moduleRef._bootstrapComponents.length>0)moduleRef._bootstrapComponents.forEach(f=>appRef.bootstrap(f));else{if(!moduleRef.instance.ngDoBootstrap)throw new root_effect_scheduler_RuntimeError(-403,ngDevMode&&`The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);moduleRef.instance.ngDoBootstrap(appRef)}allPlatformModules.push(moduleRef)}class PlatformRef{_injector;_modules=[];_destroyListeners=[];_destroyed=!1;constructor(_injector){this._injector=_injector}bootstrapModuleFactory(moduleFactory,options){const scheduleInRootZone=options?.scheduleInRootZone,ignoreChangesOutsideZone=options?.ignoreChangesOutsideZone,allAppProviders=[debug_node_internalProvideZoneChangeDetection({ngZoneFactory:()=>function getNgZone(ngZoneToUse="zone.js",options){return"noop"===ngZoneToUse?new NoopNgZone:"zone.js"===ngZoneToUse?new debug_node_NgZone(options):ngZoneToUse}(options?.ngZone,{...getNgZoneOptions({eventCoalescing:options?.ngZoneEventCoalescing,runCoalescing:options?.ngZoneRunCoalescing}),scheduleInRootZone}),ignoreChangesOutsideZone}),{provide:root_effect_scheduler_ChangeDetectionScheduler,useExisting:debug_node_ChangeDetectionSchedulerImpl},root_effect_scheduler_errorHandlerEnvironmentInitializer],moduleRef=function createNgModuleRefWithProviders(moduleType,parentInjector,additionalProviders){return new NgModuleRef(moduleType,parentInjector,additionalProviders,!1)}(moduleFactory.moduleType,this.injector,allAppProviders);return setModuleBootstrapImpl(),bootstrap({moduleRef,allPlatformModules:this._modules,platformInjector:this.injector})}bootstrapModule(moduleType,compilerOptions=[]){const options=optionsReducer({},compilerOptions);return setModuleBootstrapImpl(),compileNgModuleFactory(this.injector,options,moduleType).then(moduleFactory=>this.bootstrapModuleFactory(moduleFactory,options))}onDestroy(callback){this._destroyListeners.push(callback)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new root_effect_scheduler_RuntimeError(404,ngDevMode&&"The platform has already been destroyed!");this._modules.slice().forEach(module=>module.destroy()),this._destroyListeners.forEach(listener=>listener());const destroyListeners=this._injector.get(PLATFORM_DESTROY_LISTENERS,null);destroyListeners&&(destroyListeners.forEach(listener=>listener()),destroyListeners.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}static ɵfac=function PlatformRef_Factory(__ngFactoryType__){return new(__ngFactoryType__||PlatformRef)(ɵɵinject(root_effect_scheduler_Injector))};static ɵprov=ɵɵdefineInjectable({token:PlatformRef,factory:PlatformRef.ɵfac,providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(PlatformRef,[{type:Injectable,args:[{providedIn:"platform"}]}],()=>[{type:root_effect_scheduler_Injector}],null);let _platformInjector=null;function createPlatform(injector){if(getPlatform())throw new root_effect_scheduler_RuntimeError(400,ngDevMode&&"There can be only one platform. Destroy the previous one to create a new one.");!function debug_node_publishDefaultGlobalUtils(){ngDevMode&&publishDefaultGlobalUtils$1()}(),debug_node_publishSignalConfiguration(),_platformInjector="undefined"!=typeof ngServerMode&&ngServerMode?null:injector;const platform=injector.get(PlatformRef);return runPlatformInitializers(injector),platform}function createPlatformInjector(providers=[],name){return root_effect_scheduler_Injector.create({name,providers:[{provide:INJECTOR_SCOPE,useValue:"platform"},{provide:PLATFORM_DESTROY_LISTENERS,useValue:new Set([()=>_platformInjector=null])},...providers]})}function getPlatform(){return"undefined"!=typeof ngServerMode&&ngServerMode?null:_platformInjector?.get(PlatformRef)??null}function runPlatformInitializers(injector){const inits=injector.get(debug_node_PLATFORM_INITIALIZER,null);runInInjectionContext(injector,()=>{inits?.forEach(init=>init())})}class ChangeDetectorRef{static __NG_ELEMENT_ID__=injectChangeDetectorRef}function injectChangeDetectorRef(flags){return function createViewRef(tNode,lView,isPipe){if(root_effect_scheduler_isComponentHost(tNode)&&!isPipe){const componentView=root_effect_scheduler_getComponentLViewByIndex(tNode.index,lView);return new ViewRef(componentView,componentView)}if(175&tNode.type){const hostComponentView=lView[15];return new ViewRef(hostComponentView,lView)}return null}(root_effect_scheduler_getCurrentTNode(),root_effect_scheduler_getLView(),!(16&~flags))}class DefaultIterableDifferFactory{constructor(){}supports(obj){return isListLikeIterable(obj)}create(trackByFn){return new DefaultIterableDiffer(trackByFn)}}const trackByIdentity=(index,item)=>item;class DefaultIterableDiffer{length=0;collection;_linkedRecords=null;_unlinkedRecords=null;_previousItHead=null;_itHead=null;_itTail=null;_additionsHead=null;_additionsTail=null;_movesHead=null;_movesTail=null;_removalsHead=null;_removalsTail=null;_identityChangesHead=null;_identityChangesTail=null;_trackByFn;constructor(trackByFn){this._trackByFn=trackByFn||trackByIdentity}forEachItem(fn){let record;for(record=this._itHead;null!==record;record=record._next)fn(record)}forEachOperation(fn){let nextIt=this._itHead,nextRemove=this._removalsHead,addRemoveOffset=0,moveOffsets=null;for(;nextIt||nextRemove;){const record=!nextRemove||nextIt&&nextIt.currentIndex<getPreviousIndex(nextRemove,addRemoveOffset,moveOffsets)?nextIt:nextRemove,adjPreviousIndex=getPreviousIndex(record,addRemoveOffset,moveOffsets),currentIndex=record.currentIndex;if(record===nextRemove)addRemoveOffset--,nextRemove=nextRemove._nextRemoved;else if(nextIt=nextIt._next,null==record.previousIndex)addRemoveOffset++;else{moveOffsets||(moveOffsets=[]);const localMovePreviousIndex=adjPreviousIndex-addRemoveOffset,localCurrentIndex=currentIndex-addRemoveOffset;if(localMovePreviousIndex!=localCurrentIndex){for(let i=0;i<localMovePreviousIndex;i++){const offset=i<moveOffsets.length?moveOffsets[i]:moveOffsets[i]=0,index=offset+i;localCurrentIndex<=index&&index<localMovePreviousIndex&&(moveOffsets[i]=offset+1)}moveOffsets[record.previousIndex]=localCurrentIndex-localMovePreviousIndex}}adjPreviousIndex!==currentIndex&&fn(record,adjPreviousIndex,currentIndex)}}forEachPreviousItem(fn){let record;for(record=this._previousItHead;null!==record;record=record._nextPrevious)fn(record)}forEachAddedItem(fn){let record;for(record=this._additionsHead;null!==record;record=record._nextAdded)fn(record)}forEachMovedItem(fn){let record;for(record=this._movesHead;null!==record;record=record._nextMoved)fn(record)}forEachRemovedItem(fn){let record;for(record=this._removalsHead;null!==record;record=record._nextRemoved)fn(record)}forEachIdentityChange(fn){let record;for(record=this._identityChangesHead;null!==record;record=record._nextIdentityChange)fn(record)}diff(collection){if(null==collection&&(collection=[]),!isListLikeIterable(collection))throw new root_effect_scheduler_RuntimeError(900,ngDevMode&&`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);return this.check(collection)?this:null}onDestroy(){}check(collection){this._reset();let index,item,itemTrackBy,record=this._itHead,mayBeDirty=!1;if(Array.isArray(collection)){this.length=collection.length;for(let index=0;index<this.length;index++)item=collection[index],itemTrackBy=this._trackByFn(index,item),null!==record&&Object.is(record.trackById,itemTrackBy)?(mayBeDirty&&(record=this._verifyReinsertion(record,item,itemTrackBy,index)),Object.is(record.item,item)||this._addIdentityChange(record,item)):(record=this._mismatch(record,item,itemTrackBy,index),mayBeDirty=!0),record=record._next}else index=0,function iterateListLike(obj,fn){if(Array.isArray(obj))for(let i=0;i<obj.length;i++)fn(obj[i]);else{const iterator=obj[Symbol.iterator]();let item;for(;!(item=iterator.next()).done;)fn(item.value)}}(collection,item=>{itemTrackBy=this._trackByFn(index,item),null!==record&&Object.is(record.trackById,itemTrackBy)?(mayBeDirty&&(record=this._verifyReinsertion(record,item,itemTrackBy,index)),Object.is(record.item,item)||this._addIdentityChange(record,item)):(record=this._mismatch(record,item,itemTrackBy,index),mayBeDirty=!0),record=record._next,index++}),this.length=index;return this._truncate(record),this.collection=collection,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let record;for(record=this._previousItHead=this._itHead;null!==record;record=record._next)record._nextPrevious=record._next;for(record=this._additionsHead;null!==record;record=record._nextAdded)record.previousIndex=record.currentIndex;for(this._additionsHead=this._additionsTail=null,record=this._movesHead;null!==record;record=record._nextMoved)record.previousIndex=record.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(record,item,itemTrackBy,index){let previousRecord;return null===record?previousRecord=this._itTail:(previousRecord=record._prev,this._remove(record)),null!==(record=null===this._unlinkedRecords?null:this._unlinkedRecords.get(itemTrackBy,null))?(Object.is(record.item,item)||this._addIdentityChange(record,item),this._reinsertAfter(record,previousRecord,index)):null!==(record=null===this._linkedRecords?null:this._linkedRecords.get(itemTrackBy,index))?(Object.is(record.item,item)||this._addIdentityChange(record,item),this._moveAfter(record,previousRecord,index)):record=this._addAfter(new IterableChangeRecord_(item,itemTrackBy),previousRecord,index),record}_verifyReinsertion(record,item,itemTrackBy,index){let reinsertRecord=null===this._unlinkedRecords?null:this._unlinkedRecords.get(itemTrackBy,null);return null!==reinsertRecord?record=this._reinsertAfter(reinsertRecord,record._prev,index):record.currentIndex!=index&&(record.currentIndex=index,this._addToMoves(record,index)),record}_truncate(record){for(;null!==record;){const nextRecord=record._next;this._addToRemovals(this._unlink(record)),record=nextRecord}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(record,prevRecord,index){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(record);const prev=record._prevRemoved,next=record._nextRemoved;return null===prev?this._removalsHead=next:prev._nextRemoved=next,null===next?this._removalsTail=prev:next._prevRemoved=prev,this._insertAfter(record,prevRecord,index),this._addToMoves(record,index),record}_moveAfter(record,prevRecord,index){return this._unlink(record),this._insertAfter(record,prevRecord,index),this._addToMoves(record,index),record}_addAfter(record,prevRecord,index){return this._insertAfter(record,prevRecord,index),null===this._additionsTail?this._additionsTail=this._additionsHead=record:this._additionsTail=this._additionsTail._nextAdded=record,record}_insertAfter(record,prevRecord,index){const next=null===prevRecord?this._itHead:prevRecord._next;return record._next=next,record._prev=prevRecord,null===next?this._itTail=record:next._prev=record,null===prevRecord?this._itHead=record:prevRecord._next=record,null===this._linkedRecords&&(this._linkedRecords=new _DuplicateMap),this._linkedRecords.put(record),record.currentIndex=index,record}_remove(record){return this._addToRemovals(this._unlink(record))}_unlink(record){null!==this._linkedRecords&&this._linkedRecords.remove(record);const prev=record._prev,next=record._next;return null===prev?this._itHead=next:prev._next=next,null===next?this._itTail=prev:next._prev=prev,record}_addToMoves(record,toIndex){return record.previousIndex===toIndex||(null===this._movesTail?this._movesTail=this._movesHead=record:this._movesTail=this._movesTail._nextMoved=record),record}_addToRemovals(record){return null===this._unlinkedRecords&&(this._unlinkedRecords=new _DuplicateMap),this._unlinkedRecords.put(record),record.currentIndex=null,record._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=record,record._prevRemoved=null):(record._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=record),record}_addIdentityChange(record,item){return record.item=item,null===this._identityChangesTail?this._identityChangesTail=this._identityChangesHead=record:this._identityChangesTail=this._identityChangesTail._nextIdentityChange=record,record}}class IterableChangeRecord_{item;trackById;currentIndex=null;previousIndex=null;_nextPrevious=null;_prev=null;_next=null;_prevDup=null;_nextDup=null;_prevRemoved=null;_nextRemoved=null;_nextAdded=null;_nextMoved=null;_nextIdentityChange=null;constructor(item,trackById){this.item=item,this.trackById=trackById}}class _DuplicateItemRecordList{_head=null;_tail=null;add(record){null===this._head?(this._head=this._tail=record,record._nextDup=null,record._prevDup=null):(this._tail._nextDup=record,record._prevDup=this._tail,record._nextDup=null,this._tail=record)}get(trackById,atOrAfterIndex){let record;for(record=this._head;null!==record;record=record._nextDup)if((null===atOrAfterIndex||atOrAfterIndex<=record.currentIndex)&&Object.is(record.trackById,trackById))return record;return null}remove(record){const prev=record._prevDup,next=record._nextDup;return null===prev?this._head=next:prev._nextDup=next,null===next?this._tail=prev:next._prevDup=prev,null===this._head}}class _DuplicateMap{map=new Map;put(record){const key=record.trackById;let duplicates=this.map.get(key);duplicates||(duplicates=new _DuplicateItemRecordList,this.map.set(key,duplicates)),duplicates.add(record)}get(trackById,atOrAfterIndex){const key=trackById,recordList=this.map.get(key);return recordList?recordList.get(trackById,atOrAfterIndex):null}remove(record){const key=record.trackById;return this.map.get(key).remove(record)&&this.map.delete(key),record}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function getPreviousIndex(item,addRemoveOffset,moveOffsets){const previousIndex=item.previousIndex;if(null===previousIndex)return previousIndex;let moveOffset=0;return moveOffsets&&previousIndex<moveOffsets.length&&(moveOffset=moveOffsets[previousIndex]),previousIndex+addRemoveOffset+moveOffset}class DefaultKeyValueDifferFactory{constructor(){}supports(obj){return obj instanceof Map||isJsObject(obj)}create(){return new DefaultKeyValueDiffer}}class DefaultKeyValueDiffer{_records=new Map;_mapHead=null;_appendAfter=null;_previousMapHead=null;_changesHead=null;_changesTail=null;_additionsHead=null;_additionsTail=null;_removalsHead=null;_removalsTail=null;get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(fn){let record;for(record=this._mapHead;null!==record;record=record._next)fn(record)}forEachPreviousItem(fn){let record;for(record=this._previousMapHead;null!==record;record=record._nextPrevious)fn(record)}forEachChangedItem(fn){let record;for(record=this._changesHead;null!==record;record=record._nextChanged)fn(record)}forEachAddedItem(fn){let record;for(record=this._additionsHead;null!==record;record=record._nextAdded)fn(record)}forEachRemovedItem(fn){let record;for(record=this._removalsHead;null!==record;record=record._nextRemoved)fn(record)}diff(map){if(map){if(!(map instanceof Map||isJsObject(map)))throw new root_effect_scheduler_RuntimeError(900,ngDevMode&&`Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`)}else map=new Map;return this.check(map)?this:null}onDestroy(){}check(map){this._reset();let insertBefore=this._mapHead;if(this._appendAfter=null,this._forEach(map,(value,key)=>{if(insertBefore&&insertBefore.key===key)this._maybeAddToChanges(insertBefore,value),this._appendAfter=insertBefore,insertBefore=insertBefore._next;else{const record=this._getOrCreateRecordForKey(key,value);insertBefore=this._insertBeforeOrAppend(insertBefore,record)}}),insertBefore){insertBefore._prev&&(insertBefore._prev._next=null),this._removalsHead=insertBefore;for(let record=insertBefore;null!==record;record=record._nextRemoved)record===this._mapHead&&(this._mapHead=null),this._records.delete(record.key),record._nextRemoved=record._next,record.previousValue=record.currentValue,record.currentValue=null,record._prev=null,record._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(before,record){if(before){const prev=before._prev;return record._next=before,record._prev=prev,before._prev=record,prev&&(prev._next=record),before===this._mapHead&&(this._mapHead=record),this._appendAfter=before,before}return this._appendAfter?(this._appendAfter._next=record,record._prev=this._appendAfter):this._mapHead=record,this._appendAfter=record,null}_getOrCreateRecordForKey(key,value){if(this._records.has(key)){const record=this._records.get(key);this._maybeAddToChanges(record,value);const prev=record._prev,next=record._next;return prev&&(prev._next=next),next&&(next._prev=prev),record._next=null,record._prev=null,record}const record=new KeyValueChangeRecord_(key);return this._records.set(key,record),record.currentValue=value,this._addToAdditions(record),record}_reset(){if(this.isDirty){let record;for(this._previousMapHead=this._mapHead,record=this._previousMapHead;null!==record;record=record._next)record._nextPrevious=record._next;for(record=this._changesHead;null!==record;record=record._nextChanged)record.previousValue=record.currentValue;for(record=this._additionsHead;null!=record;record=record._nextAdded)record.previousValue=record.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(record,newValue){Object.is(newValue,record.currentValue)||(record.previousValue=record.currentValue,record.currentValue=newValue,this._addToChanges(record))}_addToAdditions(record){null===this._additionsHead?this._additionsHead=this._additionsTail=record:(this._additionsTail._nextAdded=record,this._additionsTail=record)}_addToChanges(record){null===this._changesHead?this._changesHead=this._changesTail=record:(this._changesTail._nextChanged=record,this._changesTail=record)}_forEach(obj,fn){obj instanceof Map?obj.forEach(fn):Object.keys(obj).forEach(k=>fn(obj[k],k))}}class KeyValueChangeRecord_{key;previousValue=null;currentValue=null;_nextPrevious=null;_next=null;_prev=null;_nextAdded=null;_nextRemoved=null;_nextChanged=null;constructor(key){this.key=key}}function defaultIterableDiffersFactory(){return new IterableDiffers([new DefaultIterableDifferFactory])}class IterableDiffers{factories;static ɵprov=ɵɵdefineInjectable({token:IterableDiffers,providedIn:"root",factory:defaultIterableDiffersFactory});constructor(factories){this.factories=factories}static create(factories,parent){if(null!=parent){const copied=parent.factories.slice();factories=factories.concat(copied)}return new IterableDiffers(factories)}static extend(factories){return{provide:IterableDiffers,useFactory:()=>{const parent=root_effect_scheduler_inject(IterableDiffers,{optional:!0,skipSelf:!0});return IterableDiffers.create(factories,parent||defaultIterableDiffersFactory())}}}find(iterable){const factory=this.factories.find(f=>f.supports(iterable));if(null!=factory)return factory;throw new root_effect_scheduler_RuntimeError(901,ngDevMode&&`Cannot find a differ supporting object '${iterable}' of type '${function getTypeNameForDebugging(type){return type.name||typeof type}(iterable)}'`)}}function defaultKeyValueDiffersFactory(){return new KeyValueDiffers([new DefaultKeyValueDifferFactory])}class KeyValueDiffers{static ɵprov=ɵɵdefineInjectable({token:KeyValueDiffers,providedIn:"root",factory:defaultKeyValueDiffersFactory});factories;constructor(factories){this.factories=factories}static create(factories,parent){if(parent){const copied=parent.factories.slice();factories=factories.concat(copied)}return new KeyValueDiffers(factories)}static extend(factories){return{provide:KeyValueDiffers,useFactory:()=>{const parent=root_effect_scheduler_inject(KeyValueDiffers,{optional:!0,skipSelf:!0});return KeyValueDiffers.create(factories,parent||defaultKeyValueDiffersFactory())}}}find(kv){const factory=this.factories.find(f=>f.supports(kv));if(factory)return factory;throw new root_effect_scheduler_RuntimeError(901,ngDevMode&&`Cannot find a differ supporting object '${kv}'`)}}const keyValDiff=[new DefaultKeyValueDifferFactory],iterableDiff=[new DefaultIterableDifferFactory];new IterableDiffers(iterableDiff),new KeyValueDiffers(keyValDiff),function createPlatformFactory(parentPlatformFactory,name,providers=[]){const desc=`Platform: ${name}`,marker=new InjectionToken(desc);return(extraProviders=[])=>{let platform=getPlatform();if(!platform){const platformProviders=[...providers,...extraProviders,{provide:marker,useValue:!0}];platform=parentPlatformFactory?.(platformProviders)??createPlatform(createPlatformInjector(platformProviders,desc))}return"undefined"!=typeof ngServerMode&&ngServerMode?platform:function assertPlatform(requiredToken){const platform=getPlatform();if(!platform)throw new root_effect_scheduler_RuntimeError(-401,ngDevMode&&"No platform exists!");if(("undefined"==typeof ngDevMode||ngDevMode)&&!platform.injector.get(requiredToken,null))throw new root_effect_scheduler_RuntimeError(400,"A platform with a different configuration has been created. Please destroy it first.");return platform}(marker)}}(null,"core",[]);class ApplicationModule{constructor(appRef){}static ɵfac=function ApplicationModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||ApplicationModule)(ɵɵinject(debug_node_ApplicationRef))};static ɵmod=ɵɵdefineNgModule({type:ApplicationModule});static ɵinj=ɵɵdefineInjector({})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ApplicationModule,[{type:NgModule}],()=>[{type:debug_node_ApplicationRef}],null);new WeakSet;function booleanAttribute(value){return"boolean"==typeof value?value:null!=value&&"false"!==value}new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"REQUEST":"",{providedIn:"platform",factory:()=>null}),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"RESPONSE_INIT":"",{providedIn:"platform",factory:()=>null}),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"REQUEST_CONTEXT":"",{providedIn:"platform",factory:()=>null});let _DOM=null;function getDOM(){return _DOM}class PlatformLocation{historyGo(relativePosition){throw new Error(ngDevMode?"Not implemented":"")}static ɵfac=function PlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||PlatformLocation)};static ɵprov=ɵɵdefineInjectable({token:PlatformLocation,factory:()=>root_effect_scheduler_inject(BrowserPlatformLocation),providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(PlatformLocation,[{type:Injectable,args:[{providedIn:"platform",useFactory:()=>root_effect_scheduler_inject(BrowserPlatformLocation)}]}],null,null);new InjectionToken(ngDevMode?"Location Initialized":"");class BrowserPlatformLocation extends PlatformLocation{_location;_history;_doc=root_effect_scheduler_inject(DOCUMENT);constructor(){super(),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return getDOM().getBaseHref(this._doc)}onPopState(fn){const window=getDOM().getGlobalEventTarget(this._doc,"window");return window.addEventListener("popstate",fn,!1),()=>window.removeEventListener("popstate",fn)}onHashChange(fn){const window=getDOM().getGlobalEventTarget(this._doc,"window");return window.addEventListener("hashchange",fn,!1),()=>window.removeEventListener("hashchange",fn)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(newPath){this._location.pathname=newPath}pushState(state,title,url){this._history.pushState(state,title,url)}replaceState(state,title,url){this._history.replaceState(state,title,url)}forward(){this._history.forward()}back(){this._history.back()}historyGo(relativePosition=0){this._history.go(relativePosition)}getState(){return this._history.state}static ɵfac=function BrowserPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||BrowserPlatformLocation)};static ɵprov=ɵɵdefineInjectable({token:BrowserPlatformLocation,factory:()=>new BrowserPlatformLocation,providedIn:"platform"})}function joinWithSlash(start,end){return start?end?start.endsWith("/")?end.startsWith("/")?start+end.slice(1):start+end:end.startsWith("/")?start+end:`${start}/${end}`:start:end}function stripTrailingSlash(url){const pathEndIdx=url.search(/#|\?|$/);return"/"===url[pathEndIdx-1]?url.slice(0,pathEndIdx-1)+url.slice(pathEndIdx):url}function normalizeQueryParams(params){return params&&"?"!==params[0]?`?${params}`:params}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(BrowserPlatformLocation,[{type:Injectable,args:[{providedIn:"platform",useFactory:()=>new BrowserPlatformLocation}]}],()=>[],null);class LocationStrategy{historyGo(relativePosition){throw new Error(ngDevMode?"Not implemented":"")}static ɵfac=function LocationStrategy_Factory(__ngFactoryType__){return new(__ngFactoryType__||LocationStrategy)};static ɵprov=ɵɵdefineInjectable({token:LocationStrategy,factory:()=>root_effect_scheduler_inject(PathLocationStrategy),providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(LocationStrategy,[{type:Injectable,args:[{providedIn:"root",useFactory:()=>root_effect_scheduler_inject(PathLocationStrategy)}]}],null,null);const APP_BASE_HREF=new InjectionToken(ngDevMode?"appBaseHref":"");class PathLocationStrategy extends LocationStrategy{_platformLocation;_baseHref;_removeListenerFns=[];constructor(_platformLocation,href){super(),this._platformLocation=_platformLocation,this._baseHref=href??this._platformLocation.getBaseHrefFromDOM()??root_effect_scheduler_inject(DOCUMENT).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(fn){this._removeListenerFns.push(this._platformLocation.onPopState(fn),this._platformLocation.onHashChange(fn))}getBaseHref(){return this._baseHref}prepareExternalUrl(internal){return joinWithSlash(this._baseHref,internal)}path(includeHash=!1){const pathname=this._platformLocation.pathname+normalizeQueryParams(this._platformLocation.search),hash=this._platformLocation.hash;return hash&&includeHash?`${pathname}${hash}`:pathname}pushState(state,title,url,queryParams){const externalUrl=this.prepareExternalUrl(url+normalizeQueryParams(queryParams));this._platformLocation.pushState(state,title,externalUrl)}replaceState(state,title,url,queryParams){const externalUrl=this.prepareExternalUrl(url+normalizeQueryParams(queryParams));this._platformLocation.replaceState(state,title,externalUrl)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(relativePosition=0){this._platformLocation.historyGo?.(relativePosition)}static ɵfac=function PathLocationStrategy_Factory(__ngFactoryType__){return new(__ngFactoryType__||PathLocationStrategy)(ɵɵinject(PlatformLocation),ɵɵinject(APP_BASE_HREF,8))};static ɵprov=ɵɵdefineInjectable({token:PathLocationStrategy,factory:PathLocationStrategy.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(PathLocationStrategy,[{type:Injectable,args:[{providedIn:"root"}]}],()=>[{type:PlatformLocation},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[APP_BASE_HREF]}]}],null);class Location{_subject=new Subject.B;_basePath;_locationStrategy;_urlChangeListeners=[];_urlChangeSubscription=null;constructor(locationStrategy){this._locationStrategy=locationStrategy;const baseHref=this._locationStrategy.getBaseHref();this._basePath=function _stripOrigin(baseHref){const isAbsoluteUrl=new RegExp("^(https?:)?//").test(baseHref);if(isAbsoluteUrl){const[,pathname]=baseHref.split(/\/\/[^\/]+/);return pathname}return baseHref}(stripTrailingSlash(_stripIndexHtml(baseHref))),this._locationStrategy.onPopState(ev=>{this._subject.next({url:this.path(!0),pop:!0,state:ev.state,type:ev.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(includeHash=!1){return this.normalize(this._locationStrategy.path(includeHash))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(path,query=""){return this.path()==this.normalize(path+normalizeQueryParams(query))}normalize(url){return Location.stripTrailingSlash(function _stripBasePath(basePath,url){if(!basePath||!url.startsWith(basePath))return url;const strippedUrl=url.substring(basePath.length);if(""===strippedUrl||["/",";","?","#"].includes(strippedUrl[0]))return strippedUrl;return url}(this._basePath,_stripIndexHtml(url)))}prepareExternalUrl(url){return url&&"/"!==url[0]&&(url="/"+url),this._locationStrategy.prepareExternalUrl(url)}go(path,query="",state=null){this._locationStrategy.pushState(state,"",path,query),this._notifyUrlChangeListeners(this.prepareExternalUrl(path+normalizeQueryParams(query)),state)}replaceState(path,query="",state=null){this._locationStrategy.replaceState(state,"",path,query),this._notifyUrlChangeListeners(this.prepareExternalUrl(path+normalizeQueryParams(query)),state)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(relativePosition=0){this._locationStrategy.historyGo?.(relativePosition)}onUrlChange(fn){return this._urlChangeListeners.push(fn),this._urlChangeSubscription??=this.subscribe(v=>{this._notifyUrlChangeListeners(v.url,v.state)}),()=>{const fnIndex=this._urlChangeListeners.indexOf(fn);this._urlChangeListeners.splice(fnIndex,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(url="",state){this._urlChangeListeners.forEach(fn=>fn(url,state))}subscribe(onNext,onThrow,onReturn){return this._subject.subscribe({next:onNext,error:onThrow??void 0,complete:onReturn??void 0})}static normalizeQueryParams=normalizeQueryParams;static joinWithSlash=joinWithSlash;static stripTrailingSlash=stripTrailingSlash;static ɵfac=function Location_Factory(__ngFactoryType__){return new(__ngFactoryType__||Location)(ɵɵinject(LocationStrategy))};static ɵprov=ɵɵdefineInjectable({token:Location,factory:()=>createLocation(),providedIn:"root"})}function createLocation(){return new Location(ɵɵinject(LocationStrategy))}function _stripIndexHtml(url){return url.replace(/\/index.html$/,"")}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(Location,[{type:Injectable,args:[{providedIn:"root",useFactory:createLocation}]}],()=>[{type:LocationStrategy}],null);var from=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/observable/from.js"),isArray=Array.isArray,getPrototypeOf=Object.getPrototypeOf,objectProto=Object.prototype,getKeys=Object.keys;function argsArgArrayOrObject(args){if(1===args.length){var first_1=args[0];if(isArray(first_1))return{args:first_1,keys:null};if(function isPOJO(obj){return obj&&"object"==typeof obj&&getPrototypeOf(obj)===objectProto}(first_1)){var keys=getKeys(first_1);return{args:keys.map(function(key){return first_1[key]}),keys}}}return{args,keys:null}}var innerFrom=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js"),util_args=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/util/args.js"),OperatorSubscriber=__webpack_require__("../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js"),tslib_es6=__webpack_require__("../../node_modules/tslib/tslib.es6.mjs"),mapOneOrManyArgs_isArray=Array.isArray;function mapOneOrManyArgs(fn){return(0,map.T)(function(args){return function callOrApply(fn,args){return mapOneOrManyArgs_isArray(args)?fn.apply(void 0,(0,tslib_es6.fX)([],(0,tslib_es6.zs)(args))):fn(args)}(fn,args)})}class BaseControlValueAccessor{_renderer;_elementRef;onChange=_=>{};onTouched=()=>{};constructor(_renderer,_elementRef){this._renderer=_renderer,this._elementRef=_elementRef}setProperty(key,value){this._renderer.setProperty(this._elementRef.nativeElement,key,value)}registerOnTouched(fn){this.onTouched=fn}registerOnChange(fn){this.onChange=fn}setDisabledState(isDisabled){this.setProperty("disabled",isDisabled)}static ɵfac=function BaseControlValueAccessor_Factory(__ngFactoryType__){return new(__ngFactoryType__||BaseControlValueAccessor)(ɵɵdirectiveInject(Renderer2),ɵɵdirectiveInject(ElementRef))};static ɵdir=ɵɵdefineDirective({type:BaseControlValueAccessor})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(BaseControlValueAccessor,[{type:Directive}],()=>[{type:Renderer2},{type:ElementRef}],null);class BuiltInControlValueAccessor extends BaseControlValueAccessor{static ɵfac=(()=>{let ɵBuiltInControlValueAccessor_BaseFactory;return function BuiltInControlValueAccessor_Factory(__ngFactoryType__){return(ɵBuiltInControlValueAccessor_BaseFactory||(ɵBuiltInControlValueAccessor_BaseFactory=ɵɵgetInheritedFactory(BuiltInControlValueAccessor)))(__ngFactoryType__||BuiltInControlValueAccessor)}})();static ɵdir=ɵɵdefineDirective({type:BuiltInControlValueAccessor,features:[ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(BuiltInControlValueAccessor,[{type:Directive}],null,null);const NG_VALUE_ACCESSOR=new InjectionToken(ngDevMode?"NgValueAccessor":""),CHECKBOX_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>CheckboxControlValueAccessor),multi:!0};class CheckboxControlValueAccessor extends BuiltInControlValueAccessor{writeValue(value){this.setProperty("checked",value)}static ɵfac=(()=>{let ɵCheckboxControlValueAccessor_BaseFactory;return function CheckboxControlValueAccessor_Factory(__ngFactoryType__){return(ɵCheckboxControlValueAccessor_BaseFactory||(ɵCheckboxControlValueAccessor_BaseFactory=ɵɵgetInheritedFactory(CheckboxControlValueAccessor)))(__ngFactoryType__||CheckboxControlValueAccessor)}})();static ɵdir=ɵɵdefineDirective({type:CheckboxControlValueAccessor,selectors:[["input","type","checkbox","formControlName",""],["input","type","checkbox","formControl",""],["input","type","checkbox","ngModel",""]],hostBindings:function CheckboxControlValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("change",function CheckboxControlValueAccessor_change_HostBindingHandler($event){return ctx.onChange($event.target.checked)})("blur",function CheckboxControlValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})},standalone:!1,features:[ɵɵProvidersFeature([CHECKBOX_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(CheckboxControlValueAccessor,[{type:Directive,args:[{selector:"input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",host:{"(change)":"onChange($any($event.target).checked)","(blur)":"onTouched()"},providers:[CHECKBOX_VALUE_ACCESSOR],standalone:!1}]}],null,null);const DEFAULT_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>DefaultValueAccessor),multi:!0};const COMPOSITION_BUFFER_MODE=new InjectionToken(ngDevMode?"CompositionEventMode":"");class DefaultValueAccessor extends BaseControlValueAccessor{_compositionMode;_composing=!1;constructor(renderer,elementRef,_compositionMode){super(renderer,elementRef),this._compositionMode=_compositionMode,null==this._compositionMode&&(this._compositionMode=!function _isAndroid(){const userAgent=getDOM()?getDOM().getUserAgent():"";return/android (\d+)/.test(userAgent.toLowerCase())}())}writeValue(value){const normalizedValue=null==value?"":value;this.setProperty("value",normalizedValue)}_handleInput(value){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(value)}_compositionStart(){this._composing=!0}_compositionEnd(value){this._composing=!1,this._compositionMode&&this.onChange(value)}static ɵfac=function DefaultValueAccessor_Factory(__ngFactoryType__){return new(__ngFactoryType__||DefaultValueAccessor)(ɵɵdirectiveInject(Renderer2),ɵɵdirectiveInject(ElementRef),ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE,8))};static ɵdir=ɵɵdefineDirective({type:DefaultValueAccessor,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function DefaultValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("input",function DefaultValueAccessor_input_HostBindingHandler($event){return ctx._handleInput($event.target.value)})("blur",function DefaultValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})("compositionstart",function DefaultValueAccessor_compositionstart_HostBindingHandler(){return ctx._compositionStart()})("compositionend",function DefaultValueAccessor_compositionend_HostBindingHandler($event){return ctx._compositionEnd($event.target.value)})},standalone:!1,features:[ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}function isEmptyInputValue(value){return null==value||0===lengthOrSize(value)}function lengthOrSize(value){return null==value?null:Array.isArray(value)||"string"==typeof value?value.length:value instanceof Set?value.size:null}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(DefaultValueAccessor,[{type:Directive,args:[{selector:"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",host:{"(input)":"_handleInput($any($event.target).value)","(blur)":"onTouched()","(compositionstart)":"_compositionStart()","(compositionend)":"_compositionEnd($any($event.target).value)"},providers:[DEFAULT_VALUE_ACCESSOR],standalone:!1}]}],()=>[{type:Renderer2},{type:ElementRef},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[COMPOSITION_BUFFER_MODE]}]}],null);const NG_VALIDATORS=new InjectionToken(ngDevMode?"NgValidators":""),NG_ASYNC_VALIDATORS=new InjectionToken(ngDevMode?"NgAsyncValidators":""),EMAIL_REGEXP=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;function minValidator(min){return control=>{if(null==control.value||null==min)return null;const value=parseFloat(control.value);return!isNaN(value)&&value<min?{min:{min,actual:control.value}}:null}}function maxValidator(max){return control=>{if(null==control.value||null==max)return null;const value=parseFloat(control.value);return!isNaN(value)&&value>max?{max:{max,actual:control.value}}:null}}function requiredValidator(control){return isEmptyInputValue(control.value)?{required:!0}:null}function requiredTrueValidator(control){return!0===control.value?null:{required:!0}}function emailValidator(control){return isEmptyInputValue(control.value)||EMAIL_REGEXP.test(control.value)?null:{email:!0}}function minLengthValidator(minLength){return control=>{const length=control.value?.length??lengthOrSize(control.value);return null===length||0===length?null:length<minLength?{minlength:{requiredLength:minLength,actualLength:length}}:null}}function maxLengthValidator(maxLength){return control=>{const length=control.value?.length??lengthOrSize(control.value);return null!==length&&length>maxLength?{maxlength:{requiredLength:maxLength,actualLength:length}}:null}}function patternValidator(pattern){if(!pattern)return nullValidator;let regex,regexStr;return"string"==typeof pattern?(regexStr="","^"!==pattern.charAt(0)&&(regexStr+="^"),regexStr+=pattern,"$"!==pattern.charAt(pattern.length-1)&&(regexStr+="$"),regex=new RegExp(regexStr)):(regexStr=pattern.toString(),regex=pattern),control=>{if(isEmptyInputValue(control.value))return null;const value=control.value;return regex.test(value)?null:{pattern:{requiredPattern:regexStr,actualValue:value}}}}function nullValidator(control){return null}function isPresent(o){return null!=o}function toObservable(value){const obs=isPromise(value)?(0,from.H)(value):value;if(("undefined"==typeof ngDevMode||ngDevMode)&&!isSubscribable(obs)){let errorMessage="Expected async validator to return Promise or Observable.";throw"object"==typeof value&&(errorMessage+=" Are you using a synchronous validator where an async validator is expected?"),new root_effect_scheduler_RuntimeError(-1101,errorMessage)}return obs}function mergeErrors(arrayOfErrors){let res={};return arrayOfErrors.forEach(errors=>{res=null!=errors?{...res,...errors}:res}),0===Object.keys(res).length?null:res}function executeValidators(control,validators){return validators.map(validator=>validator(control))}function normalizeValidators(validators){return validators.map(validator=>function isValidatorFn(validator){return!validator.validate}(validator)?validator:c=>validator.validate(c))}function compose(validators){if(!validators)return null;const presentValidators=validators.filter(isPresent);return 0==presentValidators.length?null:function(control){return mergeErrors(executeValidators(control,presentValidators))}}function composeValidators(validators){return null!=validators?compose(normalizeValidators(validators)):null}function composeAsync(validators){if(!validators)return null;const presentValidators=validators.filter(isPresent);return 0==presentValidators.length?null:function(control){return function forkJoin(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];var resultSelector=(0,util_args.ms)(args),_a=argsArgArrayOrObject(args),sources=_a.args,keys=_a.keys,result=new Observable.c(function(subscriber){var length=sources.length;if(length)for(var values=new Array(length),remainingCompletions=length,remainingEmissions=length,_loop_1=function(sourceIndex){var hasValue=!1;(0,innerFrom.Tg)(sources[sourceIndex]).subscribe((0,OperatorSubscriber._)(subscriber,function(value){hasValue||(hasValue=!0,remainingEmissions--),values[sourceIndex]=value},function(){return remainingCompletions--},void 0,function(){remainingCompletions&&hasValue||(remainingEmissions||subscriber.next(keys?function createObject(keys,values){return keys.reduce(function(result,key,i){return result[key]=values[i],result},{})}(keys,values):values),subscriber.complete())}))},sourceIndex=0;sourceIndex<length;sourceIndex++)_loop_1(sourceIndex);else subscriber.complete()});return resultSelector?result.pipe(mapOneOrManyArgs(resultSelector)):result}(executeValidators(control,presentValidators).map(toObservable)).pipe((0,map.T)(mergeErrors))}}function composeAsyncValidators(validators){return null!=validators?composeAsync(normalizeValidators(validators)):null}function mergeValidators(controlValidators,dirValidator){return null===controlValidators?[dirValidator]:Array.isArray(controlValidators)?[...controlValidators,dirValidator]:[controlValidators,dirValidator]}function getControlValidators(control){return control._rawValidators}function getControlAsyncValidators(control){return control._rawAsyncValidators}function makeValidatorsArray(validators){return validators?Array.isArray(validators)?validators:[validators]:[]}function hasValidator(validators,validator){return Array.isArray(validators)?validators.includes(validator):validators===validator}function addValidators(validators,currentValidators){const current=makeValidatorsArray(currentValidators);return makeValidatorsArray(validators).forEach(v=>{hasValidator(current,v)||current.push(v)}),current}function removeValidators(validators,currentValidators){return makeValidatorsArray(currentValidators).filter(v=>!hasValidator(validators,v))}class AbstractControlDirective{get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_composedValidatorFn;_composedAsyncValidatorFn;_rawValidators=[];_rawAsyncValidators=[];_setValidators(validators){this._rawValidators=validators||[],this._composedValidatorFn=composeValidators(this._rawValidators)}_setAsyncValidators(validators){this._rawAsyncValidators=validators||[],this._composedAsyncValidatorFn=composeAsyncValidators(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_onDestroyCallbacks=[];_registerOnDestroy(fn){this._onDestroyCallbacks.push(fn)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(fn=>fn()),this._onDestroyCallbacks=[]}reset(value=void 0){this.control&&this.control.reset(value)}hasError(errorCode,path){return!!this.control&&this.control.hasError(errorCode,path)}getError(errorCode,path){return this.control?this.control.getError(errorCode,path):null}}class ControlContainer extends AbstractControlDirective{name;get formDirective(){return null}get path(){return null}}class NgControl extends AbstractControlDirective{_parent=null;name=null;valueAccessor=null}class AbstractControlStatus{_cd;constructor(cd){this._cd=cd}get isTouched(){return this._cd?.control?._touched?.(),!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return this._cd?.control?._pristine?.(),!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return this._cd?.control?._status?.(),!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return this._cd?._submitted?.(),!!this._cd?.submitted}}const ngControlStatusHost={"[class.ng-untouched]":"isUntouched","[class.ng-touched]":"isTouched","[class.ng-pristine]":"isPristine","[class.ng-dirty]":"isDirty","[class.ng-valid]":"isValid","[class.ng-invalid]":"isInvalid","[class.ng-pending]":"isPending"},ngGroupStatusHost={...ngControlStatusHost,"[class.ng-submitted]":"isSubmitted"};class NgControlStatus extends AbstractControlStatus{constructor(cd){super(cd)}static ɵfac=function NgControlStatus_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgControlStatus)(ɵɵdirectiveInject(NgControl,2))};static ɵdir=ɵɵdefineDirective({type:NgControlStatus,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function NgControlStatus_HostBindings(rf,ctx){2&rf&&ɵɵclassProp("ng-untouched",ctx.isUntouched)("ng-touched",ctx.isTouched)("ng-pristine",ctx.isPristine)("ng-dirty",ctx.isDirty)("ng-valid",ctx.isValid)("ng-invalid",ctx.isInvalid)("ng-pending",ctx.isPending)},standalone:!1,features:[ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgControlStatus,[{type:Directive,args:[{selector:"[formControlName],[ngModel],[formControl]",host:ngControlStatusHost,standalone:!1}]}],()=>[{type:NgControl,decorators:[{type:Self}]}],null);class NgControlStatusGroup extends AbstractControlStatus{constructor(cd){super(cd)}static ɵfac=function NgControlStatusGroup_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgControlStatusGroup)(ɵɵdirectiveInject(ControlContainer,10))};static ɵdir=ɵɵdefineDirective({type:NgControlStatusGroup,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:16,hostBindings:function NgControlStatusGroup_HostBindings(rf,ctx){2&rf&&ɵɵclassProp("ng-untouched",ctx.isUntouched)("ng-touched",ctx.isTouched)("ng-pristine",ctx.isPristine)("ng-dirty",ctx.isDirty)("ng-valid",ctx.isValid)("ng-invalid",ctx.isInvalid)("ng-pending",ctx.isPending)("ng-submitted",ctx.isSubmitted)},standalone:!1,features:[ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgControlStatusGroup,[{type:Directive,args:[{selector:"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",host:ngGroupStatusHost,standalone:!1}]}],()=>[{type:ControlContainer,decorators:[{type:Optional},{type:Self}]}],null);const formControlNameExample='\n  <div [formGroup]="myGroup">\n    <input formControlName="firstName">\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      firstName: new FormControl()\n  });',formGroupNameExample='\n  <div [formGroup]="myGroup">\n      <div formGroupName="person">\n        <input formControlName="firstName">\n      </div>\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      person: new FormGroup({ firstName: new FormControl() })\n  });',ngModelGroupExample='\n  <form>\n      <div ngModelGroup="person">\n        <input [(ngModel)]="person.name" name="firstName">\n      </div>\n  </form>';const disabledAttrWarning="\n  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n  you. We recommend using this approach to avoid 'changed after checked' errors.\n\n  Example:\n  // Specify the `disabled` property at control creation time:\n  form = new FormGroup({\n    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n    last: new FormControl('Drew', Validators.required)\n  });\n\n  // Controls can also be enabled/disabled after creation:\n  form.get('first')?.enable();\n  form.get('last')?.disable();\n";function describeKey(isFormGroup,key){return isFormGroup?`with name: '${key}'`:`at index: ${key}`}class ControlEvent{}class ValueChangeEvent extends ControlEvent{value;source;constructor(value,source){super(),this.value=value,this.source=source}}class PristineChangeEvent extends ControlEvent{pristine;source;constructor(pristine,source){super(),this.pristine=pristine,this.source=source}}class TouchedChangeEvent extends ControlEvent{touched;source;constructor(touched,source){super(),this.touched=touched,this.source=source}}class StatusChangeEvent extends ControlEvent{status;source;constructor(status,source){super(),this.status=status,this.source=source}}class FormSubmittedEvent extends ControlEvent{source;constructor(source){super(),this.source=source}}class FormResetEvent extends ControlEvent{source;constructor(source){super(),this.source=source}}function pickValidators(validatorOrOpts){return(isOptionsObj(validatorOrOpts)?validatorOrOpts.validators:validatorOrOpts)||null}function pickAsyncValidators(asyncValidator,validatorOrOpts){return("undefined"==typeof ngDevMode||ngDevMode)&&isOptionsObj(validatorOrOpts)&&asyncValidator&&console.warn("\n  It looks like you're constructing using a FormControl with both an options argument and an\n  async validators argument. Mixing these arguments will cause your async validators to be dropped.\n  You should either put all your validators in the options object, or in separate validators\n  arguments. For example:\n\n  // Using validators arguments\n  fc = new FormControl(42, Validators.required, myAsyncValidator);\n\n  // Using AbstractControlOptions\n  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});\n\n  // Do NOT mix them: async validators will be dropped!\n  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);\n"),(isOptionsObj(validatorOrOpts)?validatorOrOpts.asyncValidators:asyncValidator)||null}function isOptionsObj(validatorOrOpts){return null!=validatorOrOpts&&!Array.isArray(validatorOrOpts)&&"object"==typeof validatorOrOpts}function assertControlPresent(parent,isGroup,key){const controls=parent.controls;if(!(isGroup?Object.keys(controls):controls).length)throw new root_effect_scheduler_RuntimeError(1e3,"undefined"==typeof ngDevMode||ngDevMode?function noControlsError(isFormGroup){return`\n    There are no form controls registered with this ${isFormGroup?"group":"array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `}(isGroup):"");if(!controls[key])throw new root_effect_scheduler_RuntimeError(1001,"undefined"==typeof ngDevMode||ngDevMode?function missingControlError(isFormGroup,key){return`Cannot find form control ${describeKey(isFormGroup,key)}`}(isGroup,key):"")}function assertAllValuesPresent(control,isGroup,value){control._forEachChild((_,key)=>{if(void 0===value[key])throw new root_effect_scheduler_RuntimeError(1002,"undefined"==typeof ngDevMode||ngDevMode?function missingControlValueError(isFormGroup,key){return`Must supply a value for form control ${describeKey(isFormGroup,key)}`}(isGroup,key):"")})}class AbstractControl{_pendingDirty=!1;_hasOwnPendingAsyncValidator=null;_pendingTouched=!1;_onCollectionChange=()=>{};_updateOn;_parent=null;_asyncValidationSubscription;_composedValidatorFn;_composedAsyncValidatorFn;_rawValidators;_rawAsyncValidators;value;constructor(validators,asyncValidators){this._assignValidators(validators),this._assignAsyncValidators(asyncValidators)}get validator(){return this._composedValidatorFn}set validator(validatorFn){this._rawValidators=this._composedValidatorFn=validatorFn}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(asyncValidatorFn){this._rawAsyncValidators=this._composedAsyncValidatorFn=asyncValidatorFn}get parent(){return this._parent}get status(){return resource_untracked(this.statusReactive)}set status(v){resource_untracked(()=>this.statusReactive.set(v))}_status=computed(()=>this.statusReactive(),...ngDevMode?[{debugName:"_status"}]:[]);statusReactive=root_effect_scheduler_signal(void 0,...ngDevMode?[{debugName:"statusReactive"}]:[]);get valid(){return"VALID"===this.status}get invalid(){return"INVALID"===this.status}get pending(){return"PENDING"==this.status}get disabled(){return"DISABLED"===this.status}get enabled(){return"DISABLED"!==this.status}errors;get pristine(){return resource_untracked(this.pristineReactive)}set pristine(v){resource_untracked(()=>this.pristineReactive.set(v))}_pristine=computed(()=>this.pristineReactive(),...ngDevMode?[{debugName:"_pristine"}]:[]);pristineReactive=root_effect_scheduler_signal(!0,...ngDevMode?[{debugName:"pristineReactive"}]:[]);get dirty(){return!this.pristine}get touched(){return resource_untracked(this.touchedReactive)}set touched(v){resource_untracked(()=>this.touchedReactive.set(v))}_touched=computed(()=>this.touchedReactive(),...ngDevMode?[{debugName:"_touched"}]:[]);touchedReactive=root_effect_scheduler_signal(!1,...ngDevMode?[{debugName:"touchedReactive"}]:[]);get untouched(){return!this.touched}_events=new Subject.B;events=this._events.asObservable();valueChanges;statusChanges;get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(validators){this._assignValidators(validators)}setAsyncValidators(validators){this._assignAsyncValidators(validators)}addValidators(validators){this.setValidators(addValidators(validators,this._rawValidators))}addAsyncValidators(validators){this.setAsyncValidators(addValidators(validators,this._rawAsyncValidators))}removeValidators(validators){this.setValidators(removeValidators(validators,this._rawValidators))}removeAsyncValidators(validators){this.setAsyncValidators(removeValidators(validators,this._rawAsyncValidators))}hasValidator(validator){return hasValidator(this._rawValidators,validator)}hasAsyncValidator(validator){return hasValidator(this._rawAsyncValidators,validator)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(opts={}){const changed=!1===this.touched;this.touched=!0;const sourceControl=opts.sourceControl??this;this._parent&&!opts.onlySelf&&this._parent.markAsTouched({...opts,sourceControl}),changed&&!1!==opts.emitEvent&&this._events.next(new TouchedChangeEvent(!0,sourceControl))}markAllAsDirty(opts={}){this.markAsDirty({onlySelf:!0,emitEvent:opts.emitEvent,sourceControl:this}),this._forEachChild(control=>control.markAllAsDirty(opts))}markAllAsTouched(opts={}){this.markAsTouched({onlySelf:!0,emitEvent:opts.emitEvent,sourceControl:this}),this._forEachChild(control=>control.markAllAsTouched(opts))}markAsUntouched(opts={}){const changed=!0===this.touched;this.touched=!1,this._pendingTouched=!1;const sourceControl=opts.sourceControl??this;this._forEachChild(control=>{control.markAsUntouched({onlySelf:!0,emitEvent:opts.emitEvent,sourceControl})}),this._parent&&!opts.onlySelf&&this._parent._updateTouched(opts,sourceControl),changed&&!1!==opts.emitEvent&&this._events.next(new TouchedChangeEvent(!1,sourceControl))}markAsDirty(opts={}){const changed=!0===this.pristine;this.pristine=!1;const sourceControl=opts.sourceControl??this;this._parent&&!opts.onlySelf&&this._parent.markAsDirty({...opts,sourceControl}),changed&&!1!==opts.emitEvent&&this._events.next(new PristineChangeEvent(!1,sourceControl))}markAsPristine(opts={}){const changed=!1===this.pristine;this.pristine=!0,this._pendingDirty=!1;const sourceControl=opts.sourceControl??this;this._forEachChild(control=>{control.markAsPristine({onlySelf:!0,emitEvent:opts.emitEvent})}),this._parent&&!opts.onlySelf&&this._parent._updatePristine(opts,sourceControl),changed&&!1!==opts.emitEvent&&this._events.next(new PristineChangeEvent(!0,sourceControl))}markAsPending(opts={}){this.status="PENDING";const sourceControl=opts.sourceControl??this;!1!==opts.emitEvent&&(this._events.next(new StatusChangeEvent(this.status,sourceControl)),this.statusChanges.emit(this.status)),this._parent&&!opts.onlySelf&&this._parent.markAsPending({...opts,sourceControl})}disable(opts={}){const skipPristineCheck=this._parentMarkedDirty(opts.onlySelf);this.status="DISABLED",this.errors=null,this._forEachChild(control=>{control.disable({...opts,onlySelf:!0})}),this._updateValue();const sourceControl=opts.sourceControl??this;!1!==opts.emitEvent&&(this._events.next(new ValueChangeEvent(this.value,sourceControl)),this._events.next(new StatusChangeEvent(this.status,sourceControl)),this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...opts,skipPristineCheck},this),this._onDisabledChange.forEach(changeFn=>changeFn(!0))}enable(opts={}){const skipPristineCheck=this._parentMarkedDirty(opts.onlySelf);this.status="VALID",this._forEachChild(control=>{control.enable({...opts,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:opts.emitEvent}),this._updateAncestors({...opts,skipPristineCheck},this),this._onDisabledChange.forEach(changeFn=>changeFn(!1))}_updateAncestors(opts,sourceControl){this._parent&&!opts.onlySelf&&(this._parent.updateValueAndValidity(opts),opts.skipPristineCheck||this._parent._updatePristine({},sourceControl),this._parent._updateTouched({},sourceControl))}setParent(parent){this._parent=parent}getRawValue(){return this.value}updateValueAndValidity(opts={}){if(this._setInitialStatus(),this._updateValue(),this.enabled){const shouldHaveEmitted=this._cancelExistingSubscription();this.errors=this._runValidator(),this.status=this._calculateStatus(),"VALID"!==this.status&&"PENDING"!==this.status||this._runAsyncValidator(shouldHaveEmitted,opts.emitEvent)}const sourceControl=opts.sourceControl??this;!1!==opts.emitEvent&&(this._events.next(new ValueChangeEvent(this.value,sourceControl)),this._events.next(new StatusChangeEvent(this.status,sourceControl)),this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!opts.onlySelf&&this._parent.updateValueAndValidity({...opts,sourceControl})}_updateTreeValidity(opts={emitEvent:!0}){this._forEachChild(ctrl=>ctrl._updateTreeValidity(opts)),this.updateValueAndValidity({onlySelf:!0,emitEvent:opts.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?"DISABLED":"VALID"}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(shouldHaveEmitted,emitEvent){if(this.asyncValidator){this.status="PENDING",this._hasOwnPendingAsyncValidator={emitEvent:!1!==emitEvent,shouldHaveEmitted:!1!==shouldHaveEmitted};const obs=toObservable(this.asyncValidator(this));this._asyncValidationSubscription=obs.subscribe(errors=>{this._hasOwnPendingAsyncValidator=null,this.setErrors(errors,{emitEvent,shouldHaveEmitted})})}}_cancelExistingSubscription(){if(this._asyncValidationSubscription){this._asyncValidationSubscription.unsubscribe();const shouldHaveEmitted=(this._hasOwnPendingAsyncValidator?.emitEvent||this._hasOwnPendingAsyncValidator?.shouldHaveEmitted)??!1;return this._hasOwnPendingAsyncValidator=null,shouldHaveEmitted}return!1}setErrors(errors,opts={}){this.errors=errors,this._updateControlsErrors(!1!==opts.emitEvent,this,opts.shouldHaveEmitted)}get(path){let currPath=path;return null==currPath?null:(Array.isArray(currPath)||(currPath=currPath.split(".")),0===currPath.length?null:currPath.reduce((control,name)=>control&&control._find(name),this))}getError(errorCode,path){const control=path?this.get(path):this;return control&&control.errors?control.errors[errorCode]:null}hasError(errorCode,path){return!!this.getError(errorCode,path)}get root(){let x=this;for(;x._parent;)x=x._parent;return x}_updateControlsErrors(emitEvent,changedControl,shouldHaveEmitted){this.status=this._calculateStatus(),emitEvent&&this.statusChanges.emit(this.status),(emitEvent||shouldHaveEmitted)&&this._events.next(new StatusChangeEvent(this.status,changedControl)),this._parent&&this._parent._updateControlsErrors(emitEvent,changedControl,shouldHaveEmitted)}_initObservables(){this.valueChanges=new EventEmitter,this.statusChanges=new EventEmitter}_calculateStatus(){return this._allControlsDisabled()?"DISABLED":this.errors?"INVALID":this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus("PENDING")?"PENDING":this._anyControlsHaveStatus("INVALID")?"INVALID":"VALID"}_anyControlsHaveStatus(status){return this._anyControls(control=>control.status===status)}_anyControlsDirty(){return this._anyControls(control=>control.dirty)}_anyControlsTouched(){return this._anyControls(control=>control.touched)}_updatePristine(opts,changedControl){const newPristine=!this._anyControlsDirty(),changed=this.pristine!==newPristine;this.pristine=newPristine,this._parent&&!opts.onlySelf&&this._parent._updatePristine(opts,changedControl),changed&&this._events.next(new PristineChangeEvent(this.pristine,changedControl))}_updateTouched(opts={},changedControl){this.touched=this._anyControlsTouched(),this._events.next(new TouchedChangeEvent(this.touched,changedControl)),this._parent&&!opts.onlySelf&&this._parent._updateTouched(opts,changedControl)}_onDisabledChange=[];_registerOnCollectionChange(fn){this._onCollectionChange=fn}_setUpdateStrategy(opts){isOptionsObj(opts)&&null!=opts.updateOn&&(this._updateOn=opts.updateOn)}_parentMarkedDirty(onlySelf){const parentDirty=this._parent&&this._parent.dirty;return!onlySelf&&!!parentDirty&&!this._parent._anyControlsDirty()}_find(name){return null}_assignValidators(validators){this._rawValidators=Array.isArray(validators)?validators.slice():validators,this._composedValidatorFn=function coerceToValidator(validator){return Array.isArray(validator)?composeValidators(validator):validator||null}(this._rawValidators)}_assignAsyncValidators(validators){this._rawAsyncValidators=Array.isArray(validators)?validators.slice():validators,this._composedAsyncValidatorFn=function coerceToAsyncValidator(asyncValidator){return Array.isArray(asyncValidator)?composeAsyncValidators(asyncValidator):asyncValidator||null}(this._rawAsyncValidators)}}class FormGroup extends AbstractControl{constructor(controls,validatorOrOpts,asyncValidator){super(pickValidators(validatorOrOpts),pickAsyncValidators(asyncValidator,validatorOrOpts)),("undefined"==typeof ngDevMode||ngDevMode)&&function validateFormGroupControls(controls){const invalidKeys=Object.keys(controls).filter(key=>key.includes("."));invalidKeys.length>0&&console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`)}(controls),this.controls=controls,this._initObservables(),this._setUpdateStrategy(validatorOrOpts),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}controls;registerControl(name,control){return this.controls[name]?this.controls[name]:(this.controls[name]=control,control.setParent(this),control._registerOnCollectionChange(this._onCollectionChange),control)}addControl(name,control,options={}){this.registerControl(name,control),this.updateValueAndValidity({emitEvent:options.emitEvent}),this._onCollectionChange()}removeControl(name,options={}){this.controls[name]&&this.controls[name]._registerOnCollectionChange(()=>{}),delete this.controls[name],this.updateValueAndValidity({emitEvent:options.emitEvent}),this._onCollectionChange()}setControl(name,control,options={}){this.controls[name]&&this.controls[name]._registerOnCollectionChange(()=>{}),delete this.controls[name],control&&this.registerControl(name,control),this.updateValueAndValidity({emitEvent:options.emitEvent}),this._onCollectionChange()}contains(controlName){return this.controls.hasOwnProperty(controlName)&&this.controls[controlName].enabled}setValue(value,options={}){assertAllValuesPresent(this,!0,value),Object.keys(value).forEach(name=>{assertControlPresent(this,!0,name),this.controls[name].setValue(value[name],{onlySelf:!0,emitEvent:options.emitEvent})}),this.updateValueAndValidity(options)}patchValue(value,options={}){null!=value&&(Object.keys(value).forEach(name=>{const control=this.controls[name];control&&control.patchValue(value[name],{onlySelf:!0,emitEvent:options.emitEvent})}),this.updateValueAndValidity(options))}reset(value={},options={}){this._forEachChild((control,name)=>{control.reset(value?value[name]:null,{onlySelf:!0,emitEvent:options.emitEvent})}),this._updatePristine(options,this),this._updateTouched(options,this),this.updateValueAndValidity(options),!1!==options?.emitEvent&&this._events.next(new FormResetEvent(this))}getRawValue(){return this._reduceChildren({},(acc,control,name)=>(acc[name]=control.getRawValue(),acc))}_syncPendingControls(){let subtreeUpdated=this._reduceChildren(!1,(updated,child)=>!!child._syncPendingControls()||updated);return subtreeUpdated&&this.updateValueAndValidity({onlySelf:!0}),subtreeUpdated}_forEachChild(cb){Object.keys(this.controls).forEach(key=>{const control=this.controls[key];control&&cb(control,key)})}_setUpControls(){this._forEachChild(control=>{control.setParent(this),control._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(condition){for(const[controlName,control]of Object.entries(this.controls))if(this.contains(controlName)&&condition(control))return!0;return!1}_reduceValue(){return this._reduceChildren({},(acc,control,name)=>((control.enabled||this.disabled)&&(acc[name]=control.value),acc))}_reduceChildren(initValue,fn){let res=initValue;return this._forEachChild((control,name)=>{res=fn(res,control,name)}),res}_allControlsDisabled(){for(const controlName of Object.keys(this.controls))if(this.controls[controlName].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(name){return this.controls.hasOwnProperty(name)?this.controls[name]:null}}class FormRecord extends FormGroup{}const CALL_SET_DISABLED_STATE=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"CallSetDisabledState":"",{providedIn:"root",factory:()=>setDisabledStateDefault}),setDisabledStateDefault="always";function controlPath(name,parent){return[...parent.path,name]}function setUpControl(control,dir,callSetDisabledState=setDisabledStateDefault){("undefined"==typeof ngDevMode||ngDevMode)&&(control||_throwError(dir,"Cannot find control with"),dir.valueAccessor||function _throwMissingValueAccessorError(dir){const loc=_describeControlLocation(dir);throw new root_effect_scheduler_RuntimeError(-1203,`No value accessor for form control ${loc}.`)}(dir)),setUpValidators(control,dir),dir.valueAccessor.writeValue(control.value),(control.disabled||"always"===callSetDisabledState)&&dir.valueAccessor.setDisabledState?.(control.disabled),function setUpViewChangePipeline(control,dir){dir.valueAccessor.registerOnChange(newValue=>{control._pendingValue=newValue,control._pendingChange=!0,control._pendingDirty=!0,"change"===control.updateOn&&updateControl(control,dir)})}(control,dir),function setUpModelChangePipeline(control,dir){const onChange=(newValue,emitModelEvent)=>{dir.valueAccessor.writeValue(newValue),emitModelEvent&&dir.viewToModelUpdate(newValue)};control.registerOnChange(onChange),dir._registerOnDestroy(()=>{control._unregisterOnChange(onChange)})}(control,dir),function setUpBlurPipeline(control,dir){dir.valueAccessor.registerOnTouched(()=>{control._pendingTouched=!0,"blur"===control.updateOn&&control._pendingChange&&updateControl(control,dir),"submit"!==control.updateOn&&control.markAsTouched()})}(control,dir),function setUpDisabledChangeHandler(control,dir){if(dir.valueAccessor.setDisabledState){const onDisabledChange=isDisabled=>{dir.valueAccessor.setDisabledState(isDisabled)};control.registerOnDisabledChange(onDisabledChange),dir._registerOnDestroy(()=>{control._unregisterOnDisabledChange(onDisabledChange)})}}(control,dir)}function cleanUpControl(control,dir,validateControlPresenceOnChange=!0){const noop=()=>{validateControlPresenceOnChange&&("undefined"==typeof ngDevMode||ngDevMode)&&function _noControlError(dir){return _throwError(dir,"There is no FormControl instance attached to form control element with")}(dir)};dir.valueAccessor&&(dir.valueAccessor.registerOnChange(noop),dir.valueAccessor.registerOnTouched(noop)),cleanUpValidators(control,dir),control&&(dir._invokeOnDestroyCallbacks(),control._registerOnCollectionChange(()=>{}))}function registerOnValidatorChange(validators,onChange){validators.forEach(validator=>{validator.registerOnValidatorChange&&validator.registerOnValidatorChange(onChange)})}function setUpValidators(control,dir){const validators=getControlValidators(control);null!==dir.validator?control.setValidators(mergeValidators(validators,dir.validator)):"function"==typeof validators&&control.setValidators([validators]);const asyncValidators=getControlAsyncValidators(control);null!==dir.asyncValidator?control.setAsyncValidators(mergeValidators(asyncValidators,dir.asyncValidator)):"function"==typeof asyncValidators&&control.setAsyncValidators([asyncValidators]);const onValidatorChange=()=>control.updateValueAndValidity();registerOnValidatorChange(dir._rawValidators,onValidatorChange),registerOnValidatorChange(dir._rawAsyncValidators,onValidatorChange)}function cleanUpValidators(control,dir){let isControlUpdated=!1;if(null!==control){if(null!==dir.validator){const validators=getControlValidators(control);if(Array.isArray(validators)&&validators.length>0){const updatedValidators=validators.filter(validator=>validator!==dir.validator);updatedValidators.length!==validators.length&&(isControlUpdated=!0,control.setValidators(updatedValidators))}}if(null!==dir.asyncValidator){const asyncValidators=getControlAsyncValidators(control);if(Array.isArray(asyncValidators)&&asyncValidators.length>0){const updatedAsyncValidators=asyncValidators.filter(asyncValidator=>asyncValidator!==dir.asyncValidator);updatedAsyncValidators.length!==asyncValidators.length&&(isControlUpdated=!0,control.setAsyncValidators(updatedAsyncValidators))}}}const noop=()=>{};return registerOnValidatorChange(dir._rawValidators,noop),registerOnValidatorChange(dir._rawAsyncValidators,noop),isControlUpdated}function updateControl(control,dir){control._pendingDirty&&control.markAsDirty(),control.setValue(control._pendingValue,{emitModelToViewChange:!1}),dir.viewToModelUpdate(control._pendingValue),control._pendingChange=!1}function setUpFormContainer(control,dir){null!=control||"undefined"!=typeof ngDevMode&&!ngDevMode||_throwError(dir,"Cannot find control with"),setUpValidators(control,dir)}function _throwError(dir,message){const messageEnd=_describeControlLocation(dir);throw new Error(`${message} ${messageEnd}`)}function _describeControlLocation(dir){const path=dir.path;return path&&path.length>1?`path: '${path.join(" -> ")}'`:path?.[0]?`name: '${path}'`:"unspecified name attribute"}function isPropertyUpdated(changes,viewModel){if(!changes.hasOwnProperty("model"))return!1;const change=changes.model;return!!change.isFirstChange()||!Object.is(viewModel,change.currentValue)}function syncPendingControls(form,directives){form._syncPendingControls(),directives.forEach(dir=>{const control=dir.control;"submit"===control.updateOn&&control._pendingChange&&(dir.viewToModelUpdate(control._pendingValue),control._pendingChange=!1)})}function selectValueAccessor(dir,valueAccessors){if(!valueAccessors)return null;let defaultAccessor,builtinAccessor,customAccessor;return Array.isArray(valueAccessors)||"undefined"!=typeof ngDevMode&&!ngDevMode||function _throwInvalidValueAccessorError(dir){const loc=_describeControlLocation(dir);throw new root_effect_scheduler_RuntimeError(1200,`Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`)}(dir),valueAccessors.forEach(v=>{v.constructor===DefaultValueAccessor?defaultAccessor=v:!function isBuiltInAccessor(valueAccessor){return Object.getPrototypeOf(valueAccessor.constructor)===BuiltInControlValueAccessor}(v)?(customAccessor&&("undefined"==typeof ngDevMode||ngDevMode)&&_throwError(dir,"More than one custom value accessor matches form control with"),customAccessor=v):(builtinAccessor&&("undefined"==typeof ngDevMode||ngDevMode)&&_throwError(dir,"More than one built-in value accessor matches form control with"),builtinAccessor=v)}),customAccessor||(builtinAccessor||(defaultAccessor||(("undefined"==typeof ngDevMode||ngDevMode)&&_throwError(dir,"No valid value accessor for form control with"),null)))}function _ngModelWarning(name,type,instance,warningConfig){"never"!==warningConfig&&((null!==warningConfig&&"once"!==warningConfig||type._ngModelWarningSentOnce)&&("always"!==warningConfig||instance._ngModelWarningSent)||(console.warn(function ngModelWarning(directiveName){return`\n  It looks like you're using ngModel on the same form field as ${directiveName}.\n  Support for using the ngModel input property and ngModelChange event with\n  reactive form directives has been deprecated in Angular v6 and will be removed\n  in a future version of Angular.\n\n  For more information on this, see our API docs here:\n  https://angular.io/api/forms/${"formControl"===directiveName?"FormControlDirective":"FormControlName"}#use-with-ngmodel\n  `}(name)),type._ngModelWarningSentOnce=!0,instance._ngModelWarningSent=!0))}const formDirectiveProvider$1={provide:ControlContainer,useExisting:forwardRef(()=>NgForm)},resolvedPromise$1=Promise.resolve();class NgForm extends ControlContainer{callSetDisabledState;get submitted(){return resource_untracked(this.submittedReactive)}_submitted=computed(()=>this.submittedReactive(),...ngDevMode?[{debugName:"_submitted"}]:[]);submittedReactive=root_effect_scheduler_signal(!1,...ngDevMode?[{debugName:"submittedReactive"}]:[]);_directives=new Set;form;ngSubmit=new EventEmitter;options;constructor(validators,asyncValidators,callSetDisabledState){super(),this.callSetDisabledState=callSetDisabledState,this.form=new FormGroup({},composeValidators(validators),composeAsyncValidators(asyncValidators))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(dir){resolvedPromise$1.then(()=>{const container=this._findContainer(dir.path);dir.control=container.registerControl(dir.name,dir.control),setUpControl(dir.control,dir,this.callSetDisabledState),dir.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(dir)})}getControl(dir){return this.form.get(dir.path)}removeControl(dir){resolvedPromise$1.then(()=>{const container=this._findContainer(dir.path);container&&container.removeControl(dir.name),this._directives.delete(dir)})}addFormGroup(dir){resolvedPromise$1.then(()=>{const container=this._findContainer(dir.path),group=new FormGroup({});setUpFormContainer(group,dir),container.registerControl(dir.name,group),group.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(dir){resolvedPromise$1.then(()=>{const container=this._findContainer(dir.path);container&&container.removeControl(dir.name)})}getFormGroup(dir){return this.form.get(dir.path)}updateModel(dir,value){resolvedPromise$1.then(()=>{this.form.get(dir.path).setValue(value)})}setValue(value){this.control.setValue(value)}onSubmit($event){return this.submittedReactive.set(!0),syncPendingControls(this.form,this._directives),this.ngSubmit.emit($event),this.form._events.next(new FormSubmittedEvent(this.control)),"dialog"===$event?.target?.method}onReset(){this.resetForm()}resetForm(value=void 0){this.form.reset(value),this.submittedReactive.set(!1)}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(path){return path.pop(),path.length?this.form.get(path):this.form}static ɵfac=function NgForm_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgForm)(ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10),ɵɵdirectiveInject(CALL_SET_DISABLED_STATE,8))};static ɵdir=ɵɵdefineDirective({type:NgForm,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function NgForm_HostBindings(rf,ctx){1&rf&&ɵɵlistener("submit",function NgForm_submit_HostBindingHandler($event){return ctx.onSubmit($event)})("reset",function NgForm_reset_HostBindingHandler(){return ctx.onReset()})},inputs:{options:[0,"ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],standalone:!1,features:[ɵɵProvidersFeature([formDirectiveProvider$1]),ɵɵInheritDefinitionFeature]})}function removeListItem(list,el){const index=list.indexOf(el);index>-1&&list.splice(index,1)}function isFormControlState(formState){return"object"==typeof formState&&null!==formState&&2===Object.keys(formState).length&&"value"in formState&&"disabled"in formState}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgForm,[{type:Directive,args:[{selector:"form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",providers:[formDirectiveProvider$1],host:{"(submit)":"onSubmit($event)","(reset)":"onReset()"},outputs:["ngSubmit"],exportAs:"ngForm",standalone:!1}]}],()=>[{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[CALL_SET_DISABLED_STATE]}]}],{options:[{type:Input,args:["ngFormOptions"]}]});const FormControl=class FormControl extends AbstractControl{defaultValue=null;_onChange=[];_pendingValue;_pendingChange=!1;constructor(formState=null,validatorOrOpts,asyncValidator){super(pickValidators(validatorOrOpts),pickAsyncValidators(asyncValidator,validatorOrOpts)),this._applyFormState(formState),this._setUpdateStrategy(validatorOrOpts),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),isOptionsObj(validatorOrOpts)&&(validatorOrOpts.nonNullable||validatorOrOpts.initialValueIsDefault)&&(isFormControlState(formState)?this.defaultValue=formState.value:this.defaultValue=formState)}setValue(value,options={}){this.value=this._pendingValue=value,this._onChange.length&&!1!==options.emitModelToViewChange&&this._onChange.forEach(changeFn=>changeFn(this.value,!1!==options.emitViewToModelChange)),this.updateValueAndValidity(options)}patchValue(value,options={}){this.setValue(value,options)}reset(formState=this.defaultValue,options={}){this._applyFormState(formState),this.markAsPristine(options),this.markAsUntouched(options),this.setValue(this.value,options),this._pendingChange=!1,!1!==options?.emitEvent&&this._events.next(new FormResetEvent(this))}_updateValue(){}_anyControls(condition){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(fn){this._onChange.push(fn)}_unregisterOnChange(fn){removeListItem(this._onChange,fn)}registerOnDisabledChange(fn){this._onDisabledChange.push(fn)}_unregisterOnDisabledChange(fn){removeListItem(this._onDisabledChange,fn)}_forEachChild(cb){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange))&&(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),!0)}_applyFormState(formState){isFormControlState(formState)?(this.value=this._pendingValue=formState.value,formState.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=formState}};class AbstractFormGroupDirective extends ControlContainer{_parent;ngOnInit(){this._checkParentType(),this.formDirective.addFormGroup(this)}ngOnDestroy(){this.formDirective&&this.formDirective.removeFormGroup(this)}get control(){return this.formDirective.getFormGroup(this)}get path(){return controlPath(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}static ɵfac=(()=>{let ɵAbstractFormGroupDirective_BaseFactory;return function AbstractFormGroupDirective_Factory(__ngFactoryType__){return(ɵAbstractFormGroupDirective_BaseFactory||(ɵAbstractFormGroupDirective_BaseFactory=ɵɵgetInheritedFactory(AbstractFormGroupDirective)))(__ngFactoryType__||AbstractFormGroupDirective)}})();static ɵdir=ɵɵdefineDirective({type:AbstractFormGroupDirective,standalone:!1,features:[ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(AbstractFormGroupDirective,[{type:Directive,args:[{standalone:!1}]}],null,null);const modelGroupProvider={provide:ControlContainer,useExisting:forwardRef(()=>NgModelGroup)};class NgModelGroup extends AbstractFormGroupDirective{name="";constructor(parent,validators,asyncValidators){super(),this._parent=parent,this._setValidators(validators),this._setAsyncValidators(asyncValidators)}_checkParentType(){if(!(this._parent instanceof NgModelGroup)&&!(this._parent instanceof NgForm)&&("undefined"==typeof ngDevMode||ngDevMode))throw function modelGroupParentException(){return new root_effect_scheduler_RuntimeError(1353,`\n    ngModelGroup cannot be used with a parent formGroup directive.\n\n    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n    ${ngModelGroupExample}`)}()}static ɵfac=function NgModelGroup_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgModelGroup)(ɵɵdirectiveInject(ControlContainer,5),ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10))};static ɵdir=ɵɵdefineDirective({type:NgModelGroup,selectors:[["","ngModelGroup",""]],inputs:{name:[0,"ngModelGroup","name"]},exportAs:["ngModelGroup"],standalone:!1,features:[ɵɵProvidersFeature([modelGroupProvider]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgModelGroup,[{type:Directive,args:[{selector:"[ngModelGroup]",providers:[modelGroupProvider],exportAs:"ngModelGroup",standalone:!1}]}],()=>[{type:ControlContainer,decorators:[{type:Host},{type:SkipSelf}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]}],{name:[{type:Input,args:["ngModelGroup"]}]});const formControlBinding$1={provide:NgControl,useExisting:forwardRef(()=>NgModel)},resolvedPromise=Promise.resolve();class NgModel extends NgControl{_changeDetectorRef;callSetDisabledState;control=new FormControl;static ngAcceptInputType_isDisabled;_registered=!1;viewModel;name="";isDisabled;model;options;update=new EventEmitter;constructor(parent,validators,asyncValidators,valueAccessors,_changeDetectorRef,callSetDisabledState){super(),this._changeDetectorRef=_changeDetectorRef,this.callSetDisabledState=callSetDisabledState,this._parent=parent,this._setValidators(validators),this._setAsyncValidators(asyncValidators),this.valueAccessor=selectValueAccessor(this,valueAccessors)}ngOnChanges(changes){if(this._checkForErrors(),!this._registered||"name"in changes){if(this._registered&&(this._checkName(),this.formDirective)){const oldName=changes.name.previousValue;this.formDirective.removeControl({name:oldName,path:this._getPath(oldName)})}this._setUpControl()}"isDisabled"in changes&&this._updateDisabled(changes),isPropertyUpdated(changes,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(newValue){this.viewModel=newValue,this.update.emit(newValue)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){setUpControl(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){"undefined"!=typeof ngDevMode&&!ngDevMode||this._isStandalone()||function checkParentType$1(parent){if(!(parent instanceof NgModelGroup)&&parent instanceof AbstractFormGroupDirective)throw function formGroupNameException(){return new root_effect_scheduler_RuntimeError(1351,`\n    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n    Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n    ${ngModelGroupExample}`)}();if(!(parent instanceof NgModelGroup||parent instanceof NgForm))throw function modelParentException(){return new root_effect_scheduler_RuntimeError(1350,`\n    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n    formGroup's partner directive "formControlName" instead.  Example:\n\n    ${formControlNameExample}\n\n    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n    Example:\n\n    \n  <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">\n  </div>\n`)}()}(this._parent),this._checkName()}_checkName(){if(this.options&&this.options.name&&(this.name=this.options.name),!this._isStandalone()&&!this.name&&("undefined"==typeof ngDevMode||ngDevMode))throw function missingNameException(){return new root_effect_scheduler_RuntimeError(1352,'If ngModel is used within a form tag, either the name attribute must be set or the form\n    control must be defined as \'standalone\' in ngModelOptions.\n\n    Example 1: <input [(ngModel)]="person.firstName" name="first">\n    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">')}()}_updateValue(value){resolvedPromise.then(()=>{this.control.setValue(value,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(changes){const disabledValue=changes.isDisabled.currentValue,isDisabled=0!==disabledValue&&booleanAttribute(disabledValue);resolvedPromise.then(()=>{isDisabled&&!this.control.disabled?this.control.disable():!isDisabled&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(controlName){return this._parent?controlPath(controlName,this._parent):[controlName]}static ɵfac=function NgModel_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgModel)(ɵɵdirectiveInject(ControlContainer,9),ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10),ɵɵdirectiveInject(NG_VALUE_ACCESSOR,10),ɵɵdirectiveInject(ChangeDetectorRef,8),ɵɵdirectiveInject(CALL_SET_DISABLED_STATE,8))};static ɵdir=ɵɵdefineDirective({type:NgModel,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:[0,"disabled","isDisabled"],model:[0,"ngModel","model"],options:[0,"ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],standalone:!1,features:[ɵɵProvidersFeature([formControlBinding$1]),ɵɵInheritDefinitionFeature,ɵɵNgOnChangesFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgModel,[{type:Directive,args:[{selector:"[ngModel]:not([formControlName]):not([formControl])",providers:[formControlBinding$1],exportAs:"ngModel",standalone:!1}]}],()=>[{type:ControlContainer,decorators:[{type:Optional},{type:Host}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALUE_ACCESSOR]}]},{type:ChangeDetectorRef,decorators:[{type:Optional},{type:Inject,args:[ChangeDetectorRef]}]},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[CALL_SET_DISABLED_STATE]}]}],{name:[{type:Input}],isDisabled:[{type:Input,args:["disabled"]}],model:[{type:Input,args:["ngModel"]}],options:[{type:Input,args:["ngModelOptions"]}],update:[{type:Output,args:["ngModelChange"]}]});class ɵNgNoValidate{static ɵfac=function ɵNgNoValidate_Factory(__ngFactoryType__){return new(__ngFactoryType__||ɵNgNoValidate)};static ɵdir=ɵɵdefineDirective({type:ɵNgNoValidate,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""],standalone:!1})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ɵNgNoValidate,[{type:Directive,args:[{selector:"form:not([ngNoForm]):not([ngNativeValidate])",host:{novalidate:""},standalone:!1}]}],null,null);const NUMBER_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>NumberValueAccessor),multi:!0};class NumberValueAccessor extends BuiltInControlValueAccessor{writeValue(value){const normalizedValue=null==value?"":value;this.setProperty("value",normalizedValue)}registerOnChange(fn){this.onChange=value=>{fn(""==value?null:parseFloat(value))}}static ɵfac=(()=>{let ɵNumberValueAccessor_BaseFactory;return function NumberValueAccessor_Factory(__ngFactoryType__){return(ɵNumberValueAccessor_BaseFactory||(ɵNumberValueAccessor_BaseFactory=ɵɵgetInheritedFactory(NumberValueAccessor)))(__ngFactoryType__||NumberValueAccessor)}})();static ɵdir=ɵɵdefineDirective({type:NumberValueAccessor,selectors:[["input","type","number","formControlName",""],["input","type","number","formControl",""],["input","type","number","ngModel",""]],hostBindings:function NumberValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("input",function NumberValueAccessor_input_HostBindingHandler($event){return ctx.onChange($event.target.value)})("blur",function NumberValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})},standalone:!1,features:[ɵɵProvidersFeature([NUMBER_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NumberValueAccessor,[{type:Directive,args:[{selector:"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",host:{"(input)":"onChange($any($event.target).value)","(blur)":"onTouched()"},providers:[NUMBER_VALUE_ACCESSOR],standalone:!1}]}],null,null);const RADIO_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>RadioControlValueAccessor),multi:!0};class RadioControlRegistry{_accessors=[];add(control,accessor){this._accessors.push([control,accessor])}remove(accessor){for(let i=this._accessors.length-1;i>=0;--i)if(this._accessors[i][1]===accessor)return void this._accessors.splice(i,1)}select(accessor){this._accessors.forEach(c=>{this._isSameGroup(c,accessor)&&c[1]!==accessor&&c[1].fireUncheck(accessor.value)})}_isSameGroup(controlPair,accessor){return!!controlPair[0].control&&(controlPair[0]._parent===accessor._control._parent&&controlPair[1].name===accessor.name)}static ɵfac=function RadioControlRegistry_Factory(__ngFactoryType__){return new(__ngFactoryType__||RadioControlRegistry)};static ɵprov=ɵɵdefineInjectable({token:RadioControlRegistry,factory:RadioControlRegistry.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(RadioControlRegistry,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);class RadioControlValueAccessor extends BuiltInControlValueAccessor{_registry;_injector;_state;_control;_fn;setDisabledStateFired=!1;onChange=()=>{};name;formControlName;value;callSetDisabledState=root_effect_scheduler_inject(CALL_SET_DISABLED_STATE,{optional:!0})??setDisabledStateDefault;constructor(renderer,elementRef,_registry,_injector){super(renderer,elementRef),this._registry=_registry,this._injector=_injector}ngOnInit(){this._control=this._injector.get(NgControl),this._checkName(),this._registry.add(this._control,this)}ngOnDestroy(){this._registry.remove(this)}writeValue(value){this._state=value===this.value,this.setProperty("checked",this._state)}registerOnChange(fn){this._fn=fn,this.onChange=()=>{fn(this.value),this._registry.select(this)}}setDisabledState(isDisabled){(this.setDisabledStateFired||isDisabled||"whenDisabledForLegacyCode"===this.callSetDisabledState)&&this.setProperty("disabled",isDisabled),this.setDisabledStateFired=!0}fireUncheck(value){this.writeValue(value)}_checkName(){this.name&&this.formControlName&&this.name!==this.formControlName&&("undefined"==typeof ngDevMode||ngDevMode)&&function throwNameError(){throw new root_effect_scheduler_RuntimeError(1202,'\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    ')}(),!this.name&&this.formControlName&&(this.name=this.formControlName)}static ɵfac=function RadioControlValueAccessor_Factory(__ngFactoryType__){return new(__ngFactoryType__||RadioControlValueAccessor)(ɵɵdirectiveInject(Renderer2),ɵɵdirectiveInject(ElementRef),ɵɵdirectiveInject(RadioControlRegistry),ɵɵdirectiveInject(root_effect_scheduler_Injector))};static ɵdir=ɵɵdefineDirective({type:RadioControlValueAccessor,selectors:[["input","type","radio","formControlName",""],["input","type","radio","formControl",""],["input","type","radio","ngModel",""]],hostBindings:function RadioControlValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("change",function RadioControlValueAccessor_change_HostBindingHandler(){return ctx.onChange()})("blur",function RadioControlValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})},inputs:{name:"name",formControlName:"formControlName",value:"value"},standalone:!1,features:[ɵɵProvidersFeature([RADIO_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(RadioControlValueAccessor,[{type:Directive,args:[{selector:"input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",host:{"(change)":"onChange()","(blur)":"onTouched()"},providers:[RADIO_VALUE_ACCESSOR],standalone:!1}]}],()=>[{type:Renderer2},{type:ElementRef},{type:RadioControlRegistry},{type:root_effect_scheduler_Injector}],{name:[{type:Input}],formControlName:[{type:Input}],value:[{type:Input}]});const RANGE_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>RangeValueAccessor),multi:!0};class RangeValueAccessor extends BuiltInControlValueAccessor{writeValue(value){this.setProperty("value",parseFloat(value))}registerOnChange(fn){this.onChange=value=>{fn(""==value?null:parseFloat(value))}}static ɵfac=(()=>{let ɵRangeValueAccessor_BaseFactory;return function RangeValueAccessor_Factory(__ngFactoryType__){return(ɵRangeValueAccessor_BaseFactory||(ɵRangeValueAccessor_BaseFactory=ɵɵgetInheritedFactory(RangeValueAccessor)))(__ngFactoryType__||RangeValueAccessor)}})();static ɵdir=ɵɵdefineDirective({type:RangeValueAccessor,selectors:[["input","type","range","formControlName",""],["input","type","range","formControl",""],["input","type","range","ngModel",""]],hostBindings:function RangeValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("change",function RangeValueAccessor_change_HostBindingHandler($event){return ctx.onChange($event.target.value)})("input",function RangeValueAccessor_input_HostBindingHandler($event){return ctx.onChange($event.target.value)})("blur",function RangeValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})},standalone:!1,features:[ɵɵProvidersFeature([RANGE_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(RangeValueAccessor,[{type:Directive,args:[{selector:"input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",host:{"(change)":"onChange($any($event.target).value)","(input)":"onChange($any($event.target).value)","(blur)":"onTouched()"},providers:[RANGE_VALUE_ACCESSOR],standalone:!1}]}],null,null);const NG_MODEL_WITH_FORM_CONTROL_WARNING=new InjectionToken(ngDevMode?"NgModelWithFormControlWarning":""),formControlBinding={provide:NgControl,useExisting:forwardRef(()=>FormControlDirective)};class FormControlDirective extends NgControl{_ngModelWarningConfig;callSetDisabledState;viewModel;form;set isDisabled(isDisabled){("undefined"==typeof ngDevMode||ngDevMode)&&console.warn(disabledAttrWarning)}model;update=new EventEmitter;static _ngModelWarningSentOnce=!1;_ngModelWarningSent=!1;constructor(validators,asyncValidators,valueAccessors,_ngModelWarningConfig,callSetDisabledState){super(),this._ngModelWarningConfig=_ngModelWarningConfig,this.callSetDisabledState=callSetDisabledState,this._setValidators(validators),this._setAsyncValidators(asyncValidators),this.valueAccessor=selectValueAccessor(this,valueAccessors)}ngOnChanges(changes){if(this._isControlChanged(changes)){const previousForm=changes.form.previousValue;previousForm&&cleanUpControl(previousForm,this,!1),setUpControl(this.form,this,this.callSetDisabledState),this.form.updateValueAndValidity({emitEvent:!1})}isPropertyUpdated(changes,this.viewModel)&&(("undefined"==typeof ngDevMode||ngDevMode)&&_ngModelWarning("formControl",FormControlDirective,this,this._ngModelWarningConfig),this.form.setValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.form&&cleanUpControl(this.form,this,!1)}get path(){return[]}get control(){return this.form}viewToModelUpdate(newValue){this.viewModel=newValue,this.update.emit(newValue)}_isControlChanged(changes){return changes.hasOwnProperty("form")}static ɵfac=function FormControlDirective_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormControlDirective)(ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10),ɵɵdirectiveInject(NG_VALUE_ACCESSOR,10),ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING,8),ɵɵdirectiveInject(CALL_SET_DISABLED_STATE,8))};static ɵdir=ɵɵdefineDirective({type:FormControlDirective,selectors:[["","formControl",""]],inputs:{form:[0,"formControl","form"],isDisabled:[0,"disabled","isDisabled"],model:[0,"ngModel","model"]},outputs:{update:"ngModelChange"},exportAs:["ngForm"],standalone:!1,features:[ɵɵProvidersFeature([formControlBinding]),ɵɵInheritDefinitionFeature,ɵɵNgOnChangesFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormControlDirective,[{type:Directive,args:[{selector:"[formControl]",providers:[formControlBinding],exportAs:"ngForm",standalone:!1}]}],()=>[{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALUE_ACCESSOR]}]},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[NG_MODEL_WITH_FORM_CONTROL_WARNING]}]},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[CALL_SET_DISABLED_STATE]}]}],{form:[{type:Input,args:["formControl"]}],isDisabled:[{type:Input,args:["disabled"]}],model:[{type:Input,args:["ngModel"]}],update:[{type:Output,args:["ngModelChange"]}]});const formDirectiveProvider={provide:ControlContainer,useExisting:forwardRef(()=>FormGroupDirective)};class FormGroupDirective extends ControlContainer{callSetDisabledState;get submitted(){return resource_untracked(this._submittedReactive)}set submitted(value){this._submittedReactive.set(value)}_submitted=computed(()=>this._submittedReactive(),...ngDevMode?[{debugName:"_submitted"}]:[]);_submittedReactive=root_effect_scheduler_signal(!1,...ngDevMode?[{debugName:"_submittedReactive"}]:[]);_oldForm;_onCollectionChange=()=>this._updateDomValue();directives=[];form=null;ngSubmit=new EventEmitter;constructor(validators,asyncValidators,callSetDisabledState){super(),this.callSetDisabledState=callSetDisabledState,this._setValidators(validators),this._setAsyncValidators(asyncValidators)}ngOnChanges(changes){if(("undefined"==typeof ngDevMode||ngDevMode)&&!this.form)throw function missingFormException(){return new root_effect_scheduler_RuntimeError(1052,`formGroup expects a FormGroup instance. Please pass one in.\n\n      Example:\n\n      ${formControlNameExample}`)}();changes.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(cleanUpValidators(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(dir){const ctrl=this.form.get(dir.path);return setUpControl(ctrl,dir,this.callSetDisabledState),ctrl.updateValueAndValidity({emitEvent:!1}),this.directives.push(dir),ctrl}getControl(dir){return this.form.get(dir.path)}removeControl(dir){cleanUpControl(dir.control||null,dir,!1),function removeListItem$1(list,el){const index=list.indexOf(el);index>-1&&list.splice(index,1)}(this.directives,dir)}addFormGroup(dir){this._setUpFormContainer(dir)}removeFormGroup(dir){this._cleanUpFormContainer(dir)}getFormGroup(dir){return this.form.get(dir.path)}addFormArray(dir){this._setUpFormContainer(dir)}removeFormArray(dir){this._cleanUpFormContainer(dir)}getFormArray(dir){return this.form.get(dir.path)}updateModel(dir,value){this.form.get(dir.path).setValue(value)}onSubmit($event){return this._submittedReactive.set(!0),syncPendingControls(this.form,this.directives),this.ngSubmit.emit($event),this.form._events.next(new FormSubmittedEvent(this.control)),"dialog"===$event?.target?.method}onReset(){this.resetForm()}resetForm(value=void 0,options={}){this.form.reset(value,options),this._submittedReactive.set(!1)}_updateDomValue(){this.directives.forEach(dir=>{const oldCtrl=dir.control,newCtrl=this.form.get(dir.path);oldCtrl!==newCtrl&&(cleanUpControl(oldCtrl||null,dir),newCtrl instanceof FormControl&&(setUpControl(newCtrl,dir,this.callSetDisabledState),dir.control=newCtrl))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(dir){const ctrl=this.form.get(dir.path);setUpFormContainer(ctrl,dir),ctrl.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(dir){if(this.form){const ctrl=this.form.get(dir.path);if(ctrl){const isControlUpdated=function cleanUpFormContainer(control,dir){return cleanUpValidators(control,dir)}(ctrl,dir);isControlUpdated&&ctrl.updateValueAndValidity({emitEvent:!1})}}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){setUpValidators(this.form,this),this._oldForm&&cleanUpValidators(this._oldForm,this)}static ɵfac=function FormGroupDirective_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormGroupDirective)(ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10),ɵɵdirectiveInject(CALL_SET_DISABLED_STATE,8))};static ɵdir=ɵɵdefineDirective({type:FormGroupDirective,selectors:[["","formGroup",""]],hostBindings:function FormGroupDirective_HostBindings(rf,ctx){1&rf&&ɵɵlistener("submit",function FormGroupDirective_submit_HostBindingHandler($event){return ctx.onSubmit($event)})("reset",function FormGroupDirective_reset_HostBindingHandler(){return ctx.onReset()})},inputs:{form:[0,"formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],standalone:!1,features:[ɵɵProvidersFeature([formDirectiveProvider]),ɵɵInheritDefinitionFeature,ɵɵNgOnChangesFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormGroupDirective,[{type:Directive,args:[{selector:"[formGroup]",providers:[formDirectiveProvider],host:{"(submit)":"onSubmit($event)","(reset)":"onReset()"},exportAs:"ngForm",standalone:!1}]}],()=>[{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[CALL_SET_DISABLED_STATE]}]}],{form:[{type:Input,args:["formGroup"]}],ngSubmit:[{type:Output}]});const formGroupNameProvider={provide:ControlContainer,useExisting:forwardRef(()=>FormGroupName)};class FormGroupName extends AbstractFormGroupDirective{name=null;constructor(parent,validators,asyncValidators){super(),this._parent=parent,this._setValidators(validators),this._setAsyncValidators(asyncValidators)}_checkParentType(){if(hasInvalidParent(this._parent)&&("undefined"==typeof ngDevMode||ngDevMode))throw function groupParentException(){return new root_effect_scheduler_RuntimeError(1053,`formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n    directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formGroupNameExample}`)}()}static ɵfac=function FormGroupName_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormGroupName)(ɵɵdirectiveInject(ControlContainer,13),ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10))};static ɵdir=ɵɵdefineDirective({type:FormGroupName,selectors:[["","formGroupName",""]],inputs:{name:[0,"formGroupName","name"]},standalone:!1,features:[ɵɵProvidersFeature([formGroupNameProvider]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormGroupName,[{type:Directive,args:[{selector:"[formGroupName]",providers:[formGroupNameProvider],standalone:!1}]}],()=>[{type:ControlContainer,decorators:[{type:Optional},{type:Host},{type:SkipSelf}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]}],{name:[{type:Input,args:["formGroupName"]}]});const formArrayNameProvider={provide:ControlContainer,useExisting:forwardRef(()=>FormArrayName)};class FormArrayName extends ControlContainer{_parent;name=null;constructor(parent,validators,asyncValidators){super(),this._parent=parent,this._setValidators(validators),this._setAsyncValidators(asyncValidators)}ngOnInit(){if(hasInvalidParent(this._parent)&&("undefined"==typeof ngDevMode||ngDevMode))throw function arrayParentException(){return new root_effect_scheduler_RuntimeError(1054,'formArrayName must be used with a parent formGroup directive.  You\'ll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      \n  <div [formGroup]="myGroup">\n    <div formArrayName="cities">\n      <div *ngFor="let city of cityArray.controls; index as i">\n        <input [formControlName]="i">\n      </div>\n    </div>\n  </div>\n\n  In your class:\n\n  this.cityArray = new FormArray([new FormControl(\'SF\')]);\n  this.myGroup = new FormGroup({\n    cities: this.cityArray\n  });')}();this.formDirective.addFormArray(this)}ngOnDestroy(){this.formDirective?.removeFormArray(this)}get control(){return this.formDirective.getFormArray(this)}get formDirective(){return this._parent?this._parent.formDirective:null}get path(){return controlPath(null==this.name?this.name:this.name.toString(),this._parent)}static ɵfac=function FormArrayName_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormArrayName)(ɵɵdirectiveInject(ControlContainer,13),ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10))};static ɵdir=ɵɵdefineDirective({type:FormArrayName,selectors:[["","formArrayName",""]],inputs:{name:[0,"formArrayName","name"]},standalone:!1,features:[ɵɵProvidersFeature([formArrayNameProvider]),ɵɵInheritDefinitionFeature]})}function hasInvalidParent(parent){return!(parent instanceof FormGroupName||parent instanceof FormGroupDirective||parent instanceof FormArrayName)}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormArrayName,[{type:Directive,args:[{selector:"[formArrayName]",providers:[formArrayNameProvider],standalone:!1}]}],()=>[{type:ControlContainer,decorators:[{type:Optional},{type:Host},{type:SkipSelf}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]}],{name:[{type:Input,args:["formArrayName"]}]});const controlNameBinding={provide:NgControl,useExisting:forwardRef(()=>FormControlName)};class FormControlName extends NgControl{_ngModelWarningConfig;_added=!1;viewModel;control;name=null;set isDisabled(isDisabled){("undefined"==typeof ngDevMode||ngDevMode)&&console.warn(disabledAttrWarning)}model;update=new EventEmitter;static _ngModelWarningSentOnce=!1;_ngModelWarningSent=!1;constructor(parent,validators,asyncValidators,valueAccessors,_ngModelWarningConfig){super(),this._ngModelWarningConfig=_ngModelWarningConfig,this._parent=parent,this._setValidators(validators),this._setAsyncValidators(asyncValidators),this.valueAccessor=selectValueAccessor(this,valueAccessors)}ngOnChanges(changes){this._added||this._setUpControl(),isPropertyUpdated(changes,this.viewModel)&&(("undefined"==typeof ngDevMode||ngDevMode)&&_ngModelWarning("formControlName",FormControlName,this,this._ngModelWarningConfig),this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(newValue){this.viewModel=newValue,this.update.emit(newValue)}get path(){return controlPath(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_setUpControl(){("undefined"==typeof ngDevMode||ngDevMode)&&function checkParentType(parent,name){if(!(parent instanceof FormGroupName)&&parent instanceof AbstractFormGroupDirective)throw function ngModelGroupException(){return new root_effect_scheduler_RuntimeError(1051,`formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.\n\n      Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n      ${formGroupNameExample}\n\n      Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n      ${ngModelGroupExample}`)}();if(!(parent instanceof FormGroupName||parent instanceof FormGroupDirective||parent instanceof FormArrayName))throw function controlParentException(nameOrIndex){return new root_effect_scheduler_RuntimeError(1050,`formControlName must be used with a parent formGroup directive. You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      ${function describeFormControl(nameOrIndex){if(null==nameOrIndex||""===nameOrIndex)return"";return`Affected Form Control ${"string"==typeof nameOrIndex?"name":"index"}: "${nameOrIndex}"`}(nameOrIndex)}\n\n    Example:\n\n    ${formControlNameExample}`)}(name)}(this._parent,this.name),this.control=this.formDirective.addControl(this),this._added=!0}static ɵfac=function FormControlName_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormControlName)(ɵɵdirectiveInject(ControlContainer,13),ɵɵdirectiveInject(NG_VALIDATORS,10),ɵɵdirectiveInject(NG_ASYNC_VALIDATORS,10),ɵɵdirectiveInject(NG_VALUE_ACCESSOR,10),ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING,8))};static ɵdir=ɵɵdefineDirective({type:FormControlName,selectors:[["","formControlName",""]],inputs:{name:[0,"formControlName","name"],isDisabled:[0,"disabled","isDisabled"],model:[0,"ngModel","model"]},outputs:{update:"ngModelChange"},standalone:!1,features:[ɵɵProvidersFeature([controlNameBinding]),ɵɵInheritDefinitionFeature,ɵɵNgOnChangesFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormControlName,[{type:Directive,args:[{selector:"[formControlName]",providers:[controlNameBinding],standalone:!1}]}],()=>[{type:ControlContainer,decorators:[{type:Optional},{type:Host},{type:SkipSelf}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_ASYNC_VALIDATORS]}]},{type:void 0,decorators:[{type:Optional},{type:Self},{type:Inject,args:[NG_VALUE_ACCESSOR]}]},{type:void 0,decorators:[{type:Optional},{type:Inject,args:[NG_MODEL_WITH_FORM_CONTROL_WARNING]}]}],{name:[{type:Input,args:["formControlName"]}],isDisabled:[{type:Input,args:["disabled"]}],model:[{type:Input,args:["ngModel"]}],update:[{type:Output,args:["ngModelChange"]}]});const SELECT_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>SelectControlValueAccessor),multi:!0};function _buildValueString$1(id,value){return null==id?`${value}`:(value&&"object"==typeof value&&(value="Object"),`${id}: ${value}`.slice(0,50))}class SelectControlValueAccessor extends BuiltInControlValueAccessor{value;_optionMap=new Map;_idCounter=0;set compareWith(fn){if("function"!=typeof fn&&("undefined"==typeof ngDevMode||ngDevMode))throw new root_effect_scheduler_RuntimeError(1201,`compareWith must be a function, but received ${JSON.stringify(fn)}`);this._compareWith=fn}_compareWith=Object.is;appRefInjector=root_effect_scheduler_inject(debug_node_ApplicationRef).injector;destroyRef=root_effect_scheduler_inject(DestroyRef);cdr=root_effect_scheduler_inject(ChangeDetectorRef);_queuedWrite=!1;_writeValueAfterRender(){this._queuedWrite||this.appRefInjector.destroyed||(this._queuedWrite=!0,afterNextRender({write:()=>{this.destroyRef.destroyed||(this._queuedWrite=!1,this.writeValue(this.value))}},{injector:this.appRefInjector}))}writeValue(value){this.cdr.markForCheck(),this.value=value;const valueString=_buildValueString$1(this._getOptionId(value),value);this.setProperty("value",valueString)}registerOnChange(fn){this.onChange=valueString=>{this.value=this._getOptionValue(valueString),fn(this.value)}}_registerOption(){return(this._idCounter++).toString()}_getOptionId(value){for(const id of this._optionMap.keys())if(this._compareWith(this._optionMap.get(id),value))return id;return null}_getOptionValue(valueString){const id=function _extractId$1(valueString){return valueString.split(":")[0]}(valueString);return this._optionMap.has(id)?this._optionMap.get(id):valueString}static ɵfac=(()=>{let ɵSelectControlValueAccessor_BaseFactory;return function SelectControlValueAccessor_Factory(__ngFactoryType__){return(ɵSelectControlValueAccessor_BaseFactory||(ɵSelectControlValueAccessor_BaseFactory=ɵɵgetInheritedFactory(SelectControlValueAccessor)))(__ngFactoryType__||SelectControlValueAccessor)}})();static ɵdir=ɵɵdefineDirective({type:SelectControlValueAccessor,selectors:[["select","formControlName","",3,"multiple",""],["select","formControl","",3,"multiple",""],["select","ngModel","",3,"multiple",""]],hostBindings:function SelectControlValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("change",function SelectControlValueAccessor_change_HostBindingHandler($event){return ctx.onChange($event.target.value)})("blur",function SelectControlValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})},inputs:{compareWith:"compareWith"},standalone:!1,features:[ɵɵProvidersFeature([SELECT_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(SelectControlValueAccessor,[{type:Directive,args:[{selector:"select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",host:{"(change)":"onChange($any($event.target).value)","(blur)":"onTouched()"},providers:[SELECT_VALUE_ACCESSOR],standalone:!1}]}],null,{compareWith:[{type:Input}]});class NgSelectOption{_element;_renderer;_select;id;constructor(_element,_renderer,_select){this._element=_element,this._renderer=_renderer,this._select=_select,this._select&&(this.id=this._select._registerOption())}set ngValue(value){null!=this._select&&(this._select._optionMap.set(this.id,value),this._setElementValue(_buildValueString$1(this.id,value)),this._select._writeValueAfterRender())}set value(value){this._setElementValue(value),this._select&&this._select._writeValueAfterRender()}_setElementValue(value){this._renderer.setProperty(this._element.nativeElement,"value",value)}ngOnDestroy(){this._select&&(this._select._optionMap.delete(this.id),this._select._writeValueAfterRender())}static ɵfac=function NgSelectOption_Factory(__ngFactoryType__){return new(__ngFactoryType__||NgSelectOption)(ɵɵdirectiveInject(ElementRef),ɵɵdirectiveInject(Renderer2),ɵɵdirectiveInject(SelectControlValueAccessor,9))};static ɵdir=ɵɵdefineDirective({type:NgSelectOption,selectors:[["option"]],inputs:{ngValue:"ngValue",value:"value"},standalone:!1})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NgSelectOption,[{type:Directive,args:[{selector:"option",standalone:!1}]}],()=>[{type:ElementRef},{type:Renderer2},{type:SelectControlValueAccessor,decorators:[{type:Optional},{type:Host}]}],{ngValue:[{type:Input,args:["ngValue"]}],value:[{type:Input,args:["value"]}]});const SELECT_MULTIPLE_VALUE_ACCESSOR={provide:NG_VALUE_ACCESSOR,useExisting:forwardRef(()=>SelectMultipleControlValueAccessor),multi:!0};function _buildValueString(id,value){return null==id?`${value}`:("string"==typeof value&&(value=`'${value}'`),value&&"object"==typeof value&&(value="Object"),`${id}: ${value}`.slice(0,50))}class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor{value;_optionMap=new Map;_idCounter=0;set compareWith(fn){if("function"!=typeof fn&&("undefined"==typeof ngDevMode||ngDevMode))throw new root_effect_scheduler_RuntimeError(1201,`compareWith must be a function, but received ${JSON.stringify(fn)}`);this._compareWith=fn}_compareWith=Object.is;writeValue(value){let optionSelectedStateSetter;if(this.value=value,Array.isArray(value)){const ids=value.map(v=>this._getOptionId(v));optionSelectedStateSetter=(opt,o)=>{opt._setSelected(ids.indexOf(o.toString())>-1)}}else optionSelectedStateSetter=(opt,o)=>{opt._setSelected(!1)};this._optionMap.forEach(optionSelectedStateSetter)}registerOnChange(fn){this.onChange=element=>{const selected=[],selectedOptions=element.selectedOptions;if(void 0!==selectedOptions){const options=selectedOptions;for(let i=0;i<options.length;i++){const opt=options[i],val=this._getOptionValue(opt.value);selected.push(val)}}else{const options=element.options;for(let i=0;i<options.length;i++){const opt=options[i];if(opt.selected){const val=this._getOptionValue(opt.value);selected.push(val)}}}this.value=selected,fn(selected)}}_registerOption(value){const id=(this._idCounter++).toString();return this._optionMap.set(id,value),id}_getOptionId(value){for(const id of this._optionMap.keys())if(this._compareWith(this._optionMap.get(id)._value,value))return id;return null}_getOptionValue(valueString){const id=function _extractId(valueString){return valueString.split(":")[0]}(valueString);return this._optionMap.has(id)?this._optionMap.get(id)._value:valueString}static ɵfac=(()=>{let ɵSelectMultipleControlValueAccessor_BaseFactory;return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__){return(ɵSelectMultipleControlValueAccessor_BaseFactory||(ɵSelectMultipleControlValueAccessor_BaseFactory=ɵɵgetInheritedFactory(SelectMultipleControlValueAccessor)))(__ngFactoryType__||SelectMultipleControlValueAccessor)}})();static ɵdir=ɵɵdefineDirective({type:SelectMultipleControlValueAccessor,selectors:[["select","multiple","","formControlName",""],["select","multiple","","formControl",""],["select","multiple","","ngModel",""]],hostBindings:function SelectMultipleControlValueAccessor_HostBindings(rf,ctx){1&rf&&ɵɵlistener("change",function SelectMultipleControlValueAccessor_change_HostBindingHandler($event){return ctx.onChange($event.target)})("blur",function SelectMultipleControlValueAccessor_blur_HostBindingHandler(){return ctx.onTouched()})},inputs:{compareWith:"compareWith"},standalone:!1,features:[ɵɵProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(SelectMultipleControlValueAccessor,[{type:Directive,args:[{selector:"select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",host:{"(change)":"onChange($event.target)","(blur)":"onTouched()"},providers:[SELECT_MULTIPLE_VALUE_ACCESSOR],standalone:!1}]}],null,{compareWith:[{type:Input}]});class ɵNgSelectMultipleOption{_element;_renderer;_select;id;_value;constructor(_element,_renderer,_select){this._element=_element,this._renderer=_renderer,this._select=_select,this._select&&(this.id=this._select._registerOption(this))}set ngValue(value){null!=this._select&&(this._value=value,this._setElementValue(_buildValueString(this.id,value)),this._select.writeValue(this._select.value))}set value(value){this._select?(this._value=value,this._setElementValue(_buildValueString(this.id,value)),this._select.writeValue(this._select.value)):this._setElementValue(value)}_setElementValue(value){this._renderer.setProperty(this._element.nativeElement,"value",value)}_setSelected(selected){this._renderer.setProperty(this._element.nativeElement,"selected",selected)}ngOnDestroy(){this._select&&(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}static ɵfac=function ɵNgSelectMultipleOption_Factory(__ngFactoryType__){return new(__ngFactoryType__||ɵNgSelectMultipleOption)(ɵɵdirectiveInject(ElementRef),ɵɵdirectiveInject(Renderer2),ɵɵdirectiveInject(SelectMultipleControlValueAccessor,9))};static ɵdir=ɵɵdefineDirective({type:ɵNgSelectMultipleOption,selectors:[["option"]],inputs:{ngValue:"ngValue",value:"value"},standalone:!1})}function toInteger(value){return"number"==typeof value?value:parseInt(value,10)}function toFloat(value){return"number"==typeof value?value:parseFloat(value)}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ɵNgSelectMultipleOption,[{type:Directive,args:[{selector:"option",standalone:!1}]}],()=>[{type:ElementRef},{type:Renderer2},{type:SelectMultipleControlValueAccessor,decorators:[{type:Optional},{type:Host}]}],{ngValue:[{type:Input,args:["ngValue"]}],value:[{type:Input,args:["value"]}]});class AbstractValidatorDirective{_validator=nullValidator;_onChange;_enabled;ngOnChanges(changes){if(this.inputName in changes){const input=this.normalizeInput(changes[this.inputName].currentValue);this._enabled=this.enabled(input),this._validator=this._enabled?this.createValidator(input):nullValidator,this._onChange&&this._onChange()}}validate(control){return this._validator(control)}registerOnValidatorChange(fn){this._onChange=fn}enabled(input){return null!=input}static ɵfac=function AbstractValidatorDirective_Factory(__ngFactoryType__){return new(__ngFactoryType__||AbstractValidatorDirective)};static ɵdir=ɵɵdefineDirective({type:AbstractValidatorDirective,features:[ɵɵNgOnChangesFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(AbstractValidatorDirective,[{type:Directive}],null,null);const MAX_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>MaxValidator),multi:!0};class MaxValidator extends AbstractValidatorDirective{max;inputName="max";normalizeInput=input=>toFloat(input);createValidator=max=>maxValidator(max);static ɵfac=(()=>{let ɵMaxValidator_BaseFactory;return function MaxValidator_Factory(__ngFactoryType__){return(ɵMaxValidator_BaseFactory||(ɵMaxValidator_BaseFactory=ɵɵgetInheritedFactory(MaxValidator)))(__ngFactoryType__||MaxValidator)}})();static ɵdir=ɵɵdefineDirective({type:MaxValidator,selectors:[["input","type","number","max","","formControlName",""],["input","type","number","max","","formControl",""],["input","type","number","max","","ngModel",""]],hostVars:1,hostBindings:function MaxValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("max",ctx._enabled?ctx.max:null)},inputs:{max:"max"},standalone:!1,features:[ɵɵProvidersFeature([MAX_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(MaxValidator,[{type:Directive,args:[{selector:"input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",providers:[MAX_VALIDATOR],host:{"[attr.max]":"_enabled ? max : null"},standalone:!1}]}],null,{max:[{type:Input}]});const MIN_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>MinValidator),multi:!0};class MinValidator extends AbstractValidatorDirective{min;inputName="min";normalizeInput=input=>toFloat(input);createValidator=min=>minValidator(min);static ɵfac=(()=>{let ɵMinValidator_BaseFactory;return function MinValidator_Factory(__ngFactoryType__){return(ɵMinValidator_BaseFactory||(ɵMinValidator_BaseFactory=ɵɵgetInheritedFactory(MinValidator)))(__ngFactoryType__||MinValidator)}})();static ɵdir=ɵɵdefineDirective({type:MinValidator,selectors:[["input","type","number","min","","formControlName",""],["input","type","number","min","","formControl",""],["input","type","number","min","","ngModel",""]],hostVars:1,hostBindings:function MinValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("min",ctx._enabled?ctx.min:null)},inputs:{min:"min"},standalone:!1,features:[ɵɵProvidersFeature([MIN_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(MinValidator,[{type:Directive,args:[{selector:"input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",providers:[MIN_VALIDATOR],host:{"[attr.min]":"_enabled ? min : null"},standalone:!1}]}],null,{min:[{type:Input}]});const REQUIRED_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>RequiredValidator),multi:!0},CHECKBOX_REQUIRED_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>CheckboxRequiredValidator),multi:!0};class RequiredValidator extends AbstractValidatorDirective{required;inputName="required";normalizeInput=booleanAttribute;createValidator=input=>requiredValidator;enabled(input){return input}static ɵfac=(()=>{let ɵRequiredValidator_BaseFactory;return function RequiredValidator_Factory(__ngFactoryType__){return(ɵRequiredValidator_BaseFactory||(ɵRequiredValidator_BaseFactory=ɵɵgetInheritedFactory(RequiredValidator)))(__ngFactoryType__||RequiredValidator)}})();static ɵdir=ɵɵdefineDirective({type:RequiredValidator,selectors:[["","required","","formControlName","",3,"type","checkbox"],["","required","","formControl","",3,"type","checkbox"],["","required","","ngModel","",3,"type","checkbox"]],hostVars:1,hostBindings:function RequiredValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("required",ctx._enabled?"":null)},inputs:{required:"required"},standalone:!1,features:[ɵɵProvidersFeature([REQUIRED_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(RequiredValidator,[{type:Directive,args:[{selector:":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",providers:[REQUIRED_VALIDATOR],host:{"[attr.required]":'_enabled ? "" : null'},standalone:!1}]}],null,{required:[{type:Input}]});class CheckboxRequiredValidator extends RequiredValidator{createValidator=input=>requiredTrueValidator;static ɵfac=(()=>{let ɵCheckboxRequiredValidator_BaseFactory;return function CheckboxRequiredValidator_Factory(__ngFactoryType__){return(ɵCheckboxRequiredValidator_BaseFactory||(ɵCheckboxRequiredValidator_BaseFactory=ɵɵgetInheritedFactory(CheckboxRequiredValidator)))(__ngFactoryType__||CheckboxRequiredValidator)}})();static ɵdir=ɵɵdefineDirective({type:CheckboxRequiredValidator,selectors:[["input","type","checkbox","required","","formControlName",""],["input","type","checkbox","required","","formControl",""],["input","type","checkbox","required","","ngModel",""]],hostVars:1,hostBindings:function CheckboxRequiredValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("required",ctx._enabled?"":null)},standalone:!1,features:[ɵɵProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(CheckboxRequiredValidator,[{type:Directive,args:[{selector:"input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",providers:[CHECKBOX_REQUIRED_VALIDATOR],host:{"[attr.required]":'_enabled ? "" : null'},standalone:!1}]}],null,null);const EMAIL_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>EmailValidator),multi:!0};class EmailValidator extends AbstractValidatorDirective{email;inputName="email";normalizeInput=booleanAttribute;createValidator=input=>emailValidator;enabled(input){return input}static ɵfac=(()=>{let ɵEmailValidator_BaseFactory;return function EmailValidator_Factory(__ngFactoryType__){return(ɵEmailValidator_BaseFactory||(ɵEmailValidator_BaseFactory=ɵɵgetInheritedFactory(EmailValidator)))(__ngFactoryType__||EmailValidator)}})();static ɵdir=ɵɵdefineDirective({type:EmailValidator,selectors:[["","email","","formControlName",""],["","email","","formControl",""],["","email","","ngModel",""]],inputs:{email:"email"},standalone:!1,features:[ɵɵProvidersFeature([EMAIL_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(EmailValidator,[{type:Directive,args:[{selector:"[email][formControlName],[email][formControl],[email][ngModel]",providers:[EMAIL_VALIDATOR],standalone:!1}]}],null,{email:[{type:Input}]});const MIN_LENGTH_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>MinLengthValidator),multi:!0};class MinLengthValidator extends AbstractValidatorDirective{minlength;inputName="minlength";normalizeInput=input=>toInteger(input);createValidator=minlength=>minLengthValidator(minlength);static ɵfac=(()=>{let ɵMinLengthValidator_BaseFactory;return function MinLengthValidator_Factory(__ngFactoryType__){return(ɵMinLengthValidator_BaseFactory||(ɵMinLengthValidator_BaseFactory=ɵɵgetInheritedFactory(MinLengthValidator)))(__ngFactoryType__||MinLengthValidator)}})();static ɵdir=ɵɵdefineDirective({type:MinLengthValidator,selectors:[["","minlength","","formControlName",""],["","minlength","","formControl",""],["","minlength","","ngModel",""]],hostVars:1,hostBindings:function MinLengthValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("minlength",ctx._enabled?ctx.minlength:null)},inputs:{minlength:"minlength"},standalone:!1,features:[ɵɵProvidersFeature([MIN_LENGTH_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(MinLengthValidator,[{type:Directive,args:[{selector:"[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",providers:[MIN_LENGTH_VALIDATOR],host:{"[attr.minlength]":"_enabled ? minlength : null"},standalone:!1}]}],null,{minlength:[{type:Input}]});const MAX_LENGTH_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>MaxLengthValidator),multi:!0};class MaxLengthValidator extends AbstractValidatorDirective{maxlength;inputName="maxlength";normalizeInput=input=>toInteger(input);createValidator=maxlength=>maxLengthValidator(maxlength);static ɵfac=(()=>{let ɵMaxLengthValidator_BaseFactory;return function MaxLengthValidator_Factory(__ngFactoryType__){return(ɵMaxLengthValidator_BaseFactory||(ɵMaxLengthValidator_BaseFactory=ɵɵgetInheritedFactory(MaxLengthValidator)))(__ngFactoryType__||MaxLengthValidator)}})();static ɵdir=ɵɵdefineDirective({type:MaxLengthValidator,selectors:[["","maxlength","","formControlName",""],["","maxlength","","formControl",""],["","maxlength","","ngModel",""]],hostVars:1,hostBindings:function MaxLengthValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("maxlength",ctx._enabled?ctx.maxlength:null)},inputs:{maxlength:"maxlength"},standalone:!1,features:[ɵɵProvidersFeature([MAX_LENGTH_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(MaxLengthValidator,[{type:Directive,args:[{selector:"[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",providers:[MAX_LENGTH_VALIDATOR],host:{"[attr.maxlength]":"_enabled ? maxlength : null"},standalone:!1}]}],null,{maxlength:[{type:Input}]});const PATTERN_VALIDATOR={provide:NG_VALIDATORS,useExisting:forwardRef(()=>PatternValidator),multi:!0};class PatternValidator extends AbstractValidatorDirective{pattern;inputName="pattern";normalizeInput=input=>input;createValidator=input=>patternValidator(input);static ɵfac=(()=>{let ɵPatternValidator_BaseFactory;return function PatternValidator_Factory(__ngFactoryType__){return(ɵPatternValidator_BaseFactory||(ɵPatternValidator_BaseFactory=ɵɵgetInheritedFactory(PatternValidator)))(__ngFactoryType__||PatternValidator)}})();static ɵdir=ɵɵdefineDirective({type:PatternValidator,selectors:[["","pattern","","formControlName",""],["","pattern","","formControl",""],["","pattern","","ngModel",""]],hostVars:1,hostBindings:function PatternValidator_HostBindings(rf,ctx){2&rf&&ɵɵattribute("pattern",ctx._enabled?ctx.pattern:null)},inputs:{pattern:"pattern"},standalone:!1,features:[ɵɵProvidersFeature([PATTERN_VALIDATOR]),ɵɵInheritDefinitionFeature]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(PatternValidator,[{type:Directive,args:[{selector:"[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",providers:[PATTERN_VALIDATOR],host:{"[attr.pattern]":"_enabled ? pattern : null"},standalone:!1}]}],null,{pattern:[{type:Input}]});const SHARED_FORM_DIRECTIVES=[ɵNgNoValidate,NgSelectOption,ɵNgSelectMultipleOption,DefaultValueAccessor,NumberValueAccessor,RangeValueAccessor,CheckboxControlValueAccessor,SelectControlValueAccessor,SelectMultipleControlValueAccessor,RadioControlValueAccessor,NgControlStatus,NgControlStatusGroup,RequiredValidator,MinLengthValidator,MaxLengthValidator,PatternValidator,CheckboxRequiredValidator,EmailValidator,MinValidator,MaxValidator],TEMPLATE_DRIVEN_DIRECTIVES=[NgModel,NgModelGroup,NgForm],REACTIVE_DRIVEN_DIRECTIVES=[FormControlDirective,FormGroupDirective,FormControlName,FormGroupName,FormArrayName];class ɵInternalFormsSharedModule{static ɵfac=function ɵInternalFormsSharedModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||ɵInternalFormsSharedModule)};static ɵmod=ɵɵdefineNgModule({type:ɵInternalFormsSharedModule,declarations:[ɵNgNoValidate,NgSelectOption,ɵNgSelectMultipleOption,DefaultValueAccessor,NumberValueAccessor,RangeValueAccessor,CheckboxControlValueAccessor,SelectControlValueAccessor,SelectMultipleControlValueAccessor,RadioControlValueAccessor,NgControlStatus,NgControlStatusGroup,RequiredValidator,MinLengthValidator,MaxLengthValidator,PatternValidator,CheckboxRequiredValidator,EmailValidator,MinValidator,MaxValidator],exports:[ɵNgNoValidate,NgSelectOption,ɵNgSelectMultipleOption,DefaultValueAccessor,NumberValueAccessor,RangeValueAccessor,CheckboxControlValueAccessor,SelectControlValueAccessor,SelectMultipleControlValueAccessor,RadioControlValueAccessor,NgControlStatus,NgControlStatusGroup,RequiredValidator,MinLengthValidator,MaxLengthValidator,PatternValidator,CheckboxRequiredValidator,EmailValidator,MinValidator,MaxValidator]});static ɵinj=ɵɵdefineInjector({})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ɵInternalFormsSharedModule,[{type:NgModule,args:[{declarations:SHARED_FORM_DIRECTIVES,exports:SHARED_FORM_DIRECTIVES}]}],null,null);class FormArray extends AbstractControl{constructor(controls,validatorOrOpts,asyncValidator){super(pickValidators(validatorOrOpts),pickAsyncValidators(asyncValidator,validatorOrOpts)),this.controls=controls,this._initObservables(),this._setUpdateStrategy(validatorOrOpts),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}controls;at(index){return this.controls[this._adjustIndex(index)]}push(control,options={}){Array.isArray(control)?control.forEach(ctrl=>{this.controls.push(ctrl),this._registerControl(ctrl)}):(this.controls.push(control),this._registerControl(control)),this.updateValueAndValidity({emitEvent:options.emitEvent}),this._onCollectionChange()}insert(index,control,options={}){this.controls.splice(index,0,control),this._registerControl(control),this.updateValueAndValidity({emitEvent:options.emitEvent})}removeAt(index,options={}){let adjustedIndex=this._adjustIndex(index);adjustedIndex<0&&(adjustedIndex=0),this.controls[adjustedIndex]&&this.controls[adjustedIndex]._registerOnCollectionChange(()=>{}),this.controls.splice(adjustedIndex,1),this.updateValueAndValidity({emitEvent:options.emitEvent})}setControl(index,control,options={}){let adjustedIndex=this._adjustIndex(index);adjustedIndex<0&&(adjustedIndex=0),this.controls[adjustedIndex]&&this.controls[adjustedIndex]._registerOnCollectionChange(()=>{}),this.controls.splice(adjustedIndex,1),control&&(this.controls.splice(adjustedIndex,0,control),this._registerControl(control)),this.updateValueAndValidity({emitEvent:options.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(value,options={}){assertAllValuesPresent(this,!1,value),value.forEach((newValue,index)=>{assertControlPresent(this,!1,index),this.at(index).setValue(newValue,{onlySelf:!0,emitEvent:options.emitEvent})}),this.updateValueAndValidity(options)}patchValue(value,options={}){null!=value&&(value.forEach((newValue,index)=>{this.at(index)&&this.at(index).patchValue(newValue,{onlySelf:!0,emitEvent:options.emitEvent})}),this.updateValueAndValidity(options))}reset(value=[],options={}){this._forEachChild((control,index)=>{control.reset(value[index],{onlySelf:!0,emitEvent:options.emitEvent})}),this._updatePristine(options,this),this._updateTouched(options,this),this.updateValueAndValidity(options),!1!==options?.emitEvent&&this._events.next(new FormResetEvent(this))}getRawValue(){return this.controls.map(control=>control.getRawValue())}clear(options={}){this.controls.length<1||(this._forEachChild(control=>control._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:options.emitEvent}))}_adjustIndex(index){return index<0?index+this.length:index}_syncPendingControls(){let subtreeUpdated=this.controls.reduce((updated,child)=>!!child._syncPendingControls()||updated,!1);return subtreeUpdated&&this.updateValueAndValidity({onlySelf:!0}),subtreeUpdated}_forEachChild(cb){this.controls.forEach((control,index)=>{cb(control,index)})}_updateValue(){this.value=this.controls.filter(control=>control.enabled||this.disabled).map(control=>control.value)}_anyControls(condition){return this.controls.some(control=>control.enabled&&condition(control))}_setUpControls(){this._forEachChild(control=>this._registerControl(control))}_allControlsDisabled(){for(const control of this.controls)if(control.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(control){control.setParent(this),control._registerOnCollectionChange(this._onCollectionChange)}_find(name){return this.at(name)??null}}function isAbstractControlOptions(options){return!!options&&(void 0!==options.asyncValidators||void 0!==options.validators||void 0!==options.updateOn)}class FormBuilder{useNonNullable=!1;get nonNullable(){const nnfb=new FormBuilder;return nnfb.useNonNullable=!0,nnfb}group(controls,options=null){const reducedControls=this._reduceControls(controls);let newOptions={};return isAbstractControlOptions(options)?newOptions=options:null!==options&&(newOptions.validators=options.validator,newOptions.asyncValidators=options.asyncValidator),new FormGroup(reducedControls,newOptions)}record(controls,options=null){const reducedControls=this._reduceControls(controls);return new FormRecord(reducedControls,options)}control(formState,validatorOrOpts,asyncValidator){let newOptions={};return this.useNonNullable?(isAbstractControlOptions(validatorOrOpts)?newOptions=validatorOrOpts:(newOptions.validators=validatorOrOpts,newOptions.asyncValidators=asyncValidator),new FormControl(formState,{...newOptions,nonNullable:!0})):new FormControl(formState,validatorOrOpts,asyncValidator)}array(controls,validatorOrOpts,asyncValidator){const createdControls=controls.map(c=>this._createControl(c));return new FormArray(createdControls,validatorOrOpts,asyncValidator)}_reduceControls(controls){const createdControls={};return Object.keys(controls).forEach(controlName=>{createdControls[controlName]=this._createControl(controls[controlName])}),createdControls}_createControl(controls){if(controls instanceof FormControl)return controls;if(controls instanceof AbstractControl)return controls;if(Array.isArray(controls)){const value=controls[0],validator=controls.length>1?controls[1]:null,asyncValidator=controls.length>2?controls[2]:null;return this.control(value,validator,asyncValidator)}return this.control(controls)}static ɵfac=function FormBuilder_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormBuilder)};static ɵprov=ɵɵdefineInjectable({token:FormBuilder,factory:FormBuilder.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormBuilder,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);class NonNullableFormBuilder{static ɵfac=function NonNullableFormBuilder_Factory(__ngFactoryType__){return new(__ngFactoryType__||NonNullableFormBuilder)};static ɵprov=ɵɵdefineInjectable({token:NonNullableFormBuilder,factory:()=>root_effect_scheduler_inject(FormBuilder).nonNullable,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(NonNullableFormBuilder,[{type:Injectable,args:[{providedIn:"root",useFactory:()=>root_effect_scheduler_inject(FormBuilder).nonNullable}]}],null,null);class UntypedFormBuilder extends FormBuilder{group(controlsConfig,options=null){return super.group(controlsConfig,options)}control(formState,validatorOrOpts,asyncValidator){return super.control(formState,validatorOrOpts,asyncValidator)}array(controlsConfig,validatorOrOpts,asyncValidator){return super.array(controlsConfig,validatorOrOpts,asyncValidator)}static ɵfac=(()=>{let ɵUntypedFormBuilder_BaseFactory;return function UntypedFormBuilder_Factory(__ngFactoryType__){return(ɵUntypedFormBuilder_BaseFactory||(ɵUntypedFormBuilder_BaseFactory=ɵɵgetInheritedFactory(UntypedFormBuilder)))(__ngFactoryType__||UntypedFormBuilder)}})();static ɵprov=ɵɵdefineInjectable({token:UntypedFormBuilder,factory:UntypedFormBuilder.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(UntypedFormBuilder,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);class FormsModule{static withConfig(opts){return{ngModule:FormsModule,providers:[{provide:CALL_SET_DISABLED_STATE,useValue:opts.callSetDisabledState??setDisabledStateDefault}]}}static ɵfac=function FormsModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||FormsModule)};static ɵmod=ɵɵdefineNgModule({type:FormsModule,declarations:[NgModel,NgModelGroup,NgForm],exports:[ɵInternalFormsSharedModule,NgModel,NgModelGroup,NgForm]});static ɵinj=ɵɵdefineInjector({imports:[ɵInternalFormsSharedModule]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(FormsModule,[{type:NgModule,args:[{declarations:TEMPLATE_DRIVEN_DIRECTIVES,exports:[ɵInternalFormsSharedModule,TEMPLATE_DRIVEN_DIRECTIVES]}]}],null,null);class ReactiveFormsModule{static withConfig(opts){return{ngModule:ReactiveFormsModule,providers:[{provide:NG_MODEL_WITH_FORM_CONTROL_WARNING,useValue:opts.warnOnNgModelWithFormControl??"always"},{provide:CALL_SET_DISABLED_STATE,useValue:opts.callSetDisabledState??setDisabledStateDefault}]}}static ɵfac=function ReactiveFormsModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||ReactiveFormsModule)};static ɵmod=ɵɵdefineNgModule({type:ReactiveFormsModule,declarations:[FormControlDirective,FormGroupDirective,FormControlName,FormGroupName,FormArrayName],exports:[ɵInternalFormsSharedModule,FormControlDirective,FormGroupDirective,FormControlName,FormGroupName,FormArrayName]});static ɵinj=ɵɵdefineInjector({imports:[ɵInternalFormsSharedModule]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node_setClassMetadata(ReactiveFormsModule,[{type:NgModule,args:[{declarations:[REACTIVE_DRIVEN_DIRECTIVES],exports:[ɵInternalFormsSharedModule,REACTIVE_DRIVEN_DIRECTIVES]}]}],null,null)}}]);